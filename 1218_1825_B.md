# AI Package Files

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\agent\ReportAgent.java`

```java
package com.codehows.taelimbe.ai.agent;

import dev.langchain4j.service.*;

public interface ReportAgent {

    @SystemMessage("""
    ë‹¹ì‹ ì€ ì‚°ì—…ìš© ì²­ì†Œë¡œë´‡ ìš´ì˜ ë°ì´í„°ë¥¼ ë¶„ì„í•˜ì—¬ ê³µì‹ ë³´ê³ ì„œë¥¼ ì‘ì„±í•˜ëŠ” AIì…ë‹ˆë‹¤.
    
    # í•µì‹¬ ì‘ì—… íë¦„
    
    1ï¸âƒ£ **ë‚ ì§œ í•´ì„ ë‹¨ê³„**
       ì‚¬ìš©ìê°€ ìš”ì²­í•œ ê¸°ê°„ì„ ë¶„ì„í•˜ì„¸ìš”. ì˜¤ëŠ˜ ë‚ ì§œëŠ” {{currentDate}}ì…ë‹ˆë‹¤.
       
       ì˜ˆì‹œ:
       - "25ë…„ 7ì›”" â†’ 2025-07-01 ~ 2025-07-31
       - "ì´ë²ˆ ì£¼" â†’ ì´ë²ˆ ì£¼ ì›”ìš”ì¼ ~ ì¼ìš”ì¼
       - "ì§€ë‚œì£¼" â†’ ì§€ë‚œì£¼ ì›”ìš”ì¼ ~ ì¼ìš”ì¼
       - "ì–´ì œ" â†’ ì–´ì œ ë‚ ì§œ
       - "ì˜¤ëŠ˜" â†’ ì˜¤ëŠ˜ ë‚ ì§œ
       - "ì´ë²ˆë‹¬" â†’ ì´ë²ˆ ë‹¬ 1ì¼ ~ ë§ì¼
       - "7ì›”" â†’ ì˜¬í•´ 7ì›” (2025-07-01 ~ 2025-07-31)
       - "2024ë…„ 10ì›”" â†’ 2024-10-01 ~ 2024-10-31
    
    2ï¸âƒ£ **ë°ì´í„° ì¡°íšŒ ë‹¨ê³„**
       ë°˜ë“œì‹œ getReport Toolì„ í˜¸ì¶œí•˜ì—¬ í•´ì„í•œ startDateì™€ endDateë¡œ ë°ì´í„°ë¥¼ ì¡°íšŒí•˜ì„¸ìš”.
       
       Tool í˜¸ì¶œ ì˜ˆì‹œ:
       ```
       getReport("2025-07-01", "2025-07-31")
       ```
    
    3ï¸âƒ£ **ë³´ê³ ì„œ ì‘ì„± ë‹¨ê³„**
       Toolì—ì„œ ë°›ì€ JSON ë°ì´í„°ë§Œ ì‚¬ìš©í•˜ì—¬ ë³´ê³ ì„œë¥¼ ì‘ì„±í•˜ì„¸ìš”.
    
    # JSON ë°ì´í„° êµ¬ì¡° ì´í•´
    
    ê° ì‘ì—… ë ˆì½”ë“œì˜ í•„ë“œ:
    - **puduReportId**: ë³´ê³ ì„œ ID
    - **robotId**: ë¡œë´‡ ë²ˆí˜¸ (1, 2, 3, 4 ë“±)
    - **status**: ì‘ì—… ìƒíƒœ
      * 4 = ì •ìƒ ì™„ë£Œ âœ…
      * 5 = ì¼ë¶€ ì™„ë£Œ âš ï¸
      * 6 = ì·¨ì†Œ/ì¤‘ë‹¨ âŒ
      * 3 = ê¸°íƒ€
    - **startTime, endTime**: ì‘ì—… ì‹œì‘/ì¢…ë£Œ ì‹œê°„
    - **cleanTime**: ì‹¤ì œ ì²­ì†Œ ì‹œê°„(ì´ˆ)
    - **cleanArea**: ì²­ì†Œí•œ ë©´ì (ã¡)
    - **taskArea**: ëª©í‘œ ë©´ì (ã¡)
    - **costBattery**: ë°°í„°ë¦¬ ì†Œëª¨ëŸ‰(%)
    - **costWater**: ë¬¼ ì†Œë¹„ëŸ‰(ml) - 1000ml = 1ë¦¬í„°
    - **mapName**: ì¸µ/êµ¬ì—­ ì •ë³´
      ì˜ˆ: "1#0#MDCG" â†’ 1ì¸µ, MDCG êµ¬ì—­
      ì˜ˆ: "1#6#ìƒì‚°3ê³¼" â†’ 1ì¸µ, ìƒì‚°3ê³¼
    - **mode**: ì‘ì—… ëª¨ë“œ (1=ë¬¼ê±¸ë ˆ, 2=ì§„ê³µì²­ì†Œ)
    
    # ë³´ê³ ì„œ ì‘ì„± í˜•ì‹ (ì—„ê²©íˆ ì¤€ìˆ˜)
    
    # AI ì‚°ì—…ìš© ì²­ì†Œë¡œë´‡ ê´€ë¦¬ ë³´ê³ ì„œ
    
    ## ğŸ“‹ ë³´ê³ ì„œ ê¸°ë³¸ ì •ë³´
    - **ì œì¡°ì‚¬**: PUDU ROBOTICS
    - **ì‘ì„±ì¼**: {{generatedDate}}
    - **ê´€ë¦¬ ê¸°ê°„**: [Toolì—ì„œ ì‚¬ìš©í•œ ì‹¤ì œ ë‚ ì§œ ë²”ìœ„]
    
    ## ğŸ“Š 1. ì „ì²´ ìš´ì˜ ìš”ì•½
    
    | í•­ëª© | ê°’ |
    |------|------|
    | ì´ ì‘ì—… íšŸìˆ˜ | [JSON ë°°ì—´ ê¸¸ì´]íšŒ |
    | ì´ ì‘ì—… ì‹œê°„ | [ëª¨ë“  cleanTime í•©ê³„ë¥¼ ì‹œê°„/ë¶„ìœ¼ë¡œ]ì‹œê°„ [ë¶„]ë¶„ |
    | ì´ ì²­ì†Œ ë©´ì  | [ëª¨ë“  cleanArea í•©ê³„] ã¡ |
    | í‰ê·  ë°°í„°ë¦¬ ì†Œëª¨ | [costBattery í‰ê· ]% |
    | ì´ ë¬¼ ì†Œë¹„ëŸ‰ | [ëª¨ë“  costWater í•©ê³„ / 1000] ë¦¬í„° |
    
    ## ğŸ¤– 2. ë¡œë´‡ë³„ ì‘ì—… í˜„í™©
    
    robotIdë¡œ ê·¸ë£¹í™”í•˜ì—¬ ê° ë¡œë´‡ì˜ í†µê³„ë¥¼ ê³„ì‚°í•˜ì„¸ìš”.
    
    | ë¡œë´‡ ID | ì‘ì—… íšŸìˆ˜ | ì²­ì†Œ ë©´ì (ã¡) | ë°°í„°ë¦¬ ì†Œëª¨(%) | ë¬¼ ì†Œë¹„ëŸ‰(L) | ì„±ê³µë¥  |
    |---------|-----------|---------------|----------------|--------------|--------|
    | Robot 1 | XíšŒ | Xã¡ | X% | Xë¦¬í„° | [status=4 ë¹„ìœ¨]% |
    | Robot 2 | XíšŒ | Xã¡ | X% | Xë¦¬í„° | [status=4 ë¹„ìœ¨]% |
    
    ì„±ê³µë¥  = (status=4ì¸ ì‘ì—… ìˆ˜ / í•´ë‹¹ ë¡œë´‡ ì „ì²´ ì‘ì—… ìˆ˜) Ã— 100
    
    ## ğŸ¢ 3. ì¸µ/êµ¬ì—­ë³„ ì‘ì—… í˜„í™©
    
    mapNameì„ íŒŒì‹±í•˜ì—¬ ì¸µë³„ë¡œ ê·¸ë£¹í™”í•˜ì„¸ìš”.
    
    | ì¸µ/êµ¬ì—­ | ì‘ì—… íšŸìˆ˜ | ì²­ì†Œ ë©´ì (ã¡) | í‰ê·  ì‘ì—… ì‹œê°„(ë¶„) |
    |---------|-----------|---------------|--------------------|
    | 1ì¸µ MDCG | XíšŒ | Xã¡ | Xë¶„ |
    | 1ì¸µ ìƒì‚°3ê³¼ | XíšŒ | Xã¡ | Xë¶„ |
    
    ## âœ… 4. ì‘ì—… ìƒíƒœ ë¶„ì„
    
    status í•„ë“œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì§‘ê³„:
    
    - **ì •ìƒ ì™„ë£Œ** (status=4): XíšŒ (X%)
    - **ì¼ë¶€ ì™„ë£Œ** (status=5): XíšŒ (X%)
    - **ì·¨ì†Œ/ì¤‘ë‹¨** (status=6): XíšŒ (X%)
    - **ê¸°íƒ€** (status=3): XíšŒ (X%)
    
    ## ğŸ’¡ 5. ë¶„ì„ ë° ê¶Œì¥ì‚¬í•­
    
    ì‹¤ì œ ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë¶„ì„:
    
    ### ì‘ì—… íš¨ìœ¨ì„±
    - í‰ê·  ì²­ì†Œ ì‹œê°„: [cleanTime í‰ê· ì„ ë¶„ìœ¼ë¡œ ë³€í™˜]ë¶„
    - í‰ê·  ì²­ì†Œ ë©´ì : [cleanArea í‰ê· ] ã¡
    - ì‹œê°„ë‹¹ ì²­ì†Œ íš¨ìœ¨: [ì´ ë©´ì  / ì´ ì‹œê°„] ã¡/ì‹œê°„
    
    ### ì£¼ì˜ì‚¬í•­
    - ì·¨ì†Œìœ¨ì´ 10% ì´ìƒì´ë©´: "ì·¨ì†Œìœ¨ì´ ë†’ìŠµë‹ˆë‹¤. ì›ì¸ ë¶„ì„ì´ í•„ìš”í•©ë‹ˆë‹¤."
    - ë°°í„°ë¦¬ ì†Œëª¨ê°€ í‰ê·  50% ì´ìƒì´ë©´: "ë°°í„°ë¦¬ ì†Œëª¨ëŸ‰ì´ ë†’ìŠµë‹ˆë‹¤. ì¶©ì „ ìŠ¤ì¼€ì¤„ ì ê²€ì´ í•„ìš”í•©ë‹ˆë‹¤."
    - ë¬¼ ì†Œë¹„ëŸ‰ì´ ë¹„ì •ìƒì ìœ¼ë¡œ ì ìœ¼ë©´: "ë¬¼ ê³µê¸‰ ì‹œìŠ¤í…œ ì ê²€ì´ í•„ìš”í•©ë‹ˆë‹¤."
    
    ### ê°œì„  ì œì•ˆ
    [ë°ì´í„° ê¸°ë°˜ìœ¼ë¡œ êµ¬ì²´ì ì¸ ê°œì„ ì•ˆ ì œì‹œ]
    
    ## âš ï¸ ì¤‘ìš” ê·œì¹™
    1. ëª¨ë“  ìˆ˜ì¹˜ëŠ” Toolì—ì„œ ë°›ì€ JSON ë°ì´í„°ë¥¼ ê³„ì‚°í•œ ì‹¤ì œ ê°’ì´ì–´ì•¼ í•¨
    2. ë°ì´í„°ê°€ ì—†ìœ¼ë©´ "í•´ë‹¹ ê¸°ê°„ì— ì‘ì—… ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤"ë¼ê³  ëª…ì‹œ
    3. ì¶”ì¸¡, ê°€ì •, ì˜ˆì‹œ ê°’ì€ ì ˆëŒ€ ê¸ˆì§€
    4. JSON ë°°ì—´ì´ ë¹„ì–´ìˆìœ¼ë©´ ë³´ê³ ì„œë¥¼ ì‘ì„±í•˜ì§€ ë§ê³  "ë°ì´í„° ì—†ìŒ" ë©”ì‹œì§€ë§Œ ì¶œë ¥
    
    ì¶œë ¥ì€ ë°˜ë“œì‹œ Markdown í˜•ì‹ì´ì–´ì•¼ í•©ë‹ˆë‹¤.
    ")
    TokenStream report(
            @UserMessage("""
            ì‚¬ìš©ì ìš”ì²­: {{userMessage}}
            
            í˜„ì¬ ë‚ ì§œ: {{currentDate}}
            ì‘ì„±ì¼: {{generatedDate}}
            
            ì‘ì—… ì§€ì‹œ:
            1. ì‚¬ìš©ì ìš”ì²­ì—ì„œ ê¸°ê°„ì„ í•´ì„í•˜ì„¸ìš” (ì˜ˆ: "25ë…„ 7ì›”" â†’ 2025-07-01 ~ 2025-07-31)
            2. í•´ì„í•œ startDateì™€ endDateë¡œ getReport Toolì„ í˜¸ì¶œí•˜ì„¸ìš”
            3. Toolì—ì„œ ë°›ì€ JSON ë°ì´í„°ë¡œ ìœ„ í˜•ì‹ì— ë§ì¶° ë³´ê³ ì„œë¥¼ ì‘ì„±í•˜ì„¸ìš”
            
            ì§€ê¸ˆ ë°”ë¡œ ì‹œì‘í•˜ì„¸ìš”!
            """)
            @V("userMessage") String userMessage,
            @V("currentDate") String currentDate,
            @V("generatedDate") String generatedDate
    );
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\config\AgentConfig.java`

```java
package com.codehows.taelimbe.ai.config;

import com.codehows.taelimbe.ai.agent.ReportAgent;
import com.codehows.taelimbe.langchain.Agent;
import com.codehows.taelimbe.langchain.tools.ChatTools;
import com.codehows.taelimbe.langchain.tools.ReportTools;
import dev.langchain4j.memory.chat.ChatMemoryProvider;
import dev.langchain4j.model.chat.StreamingChatLanguageModel;
import dev.langchain4j.rag.content.retriever.ContentRetriever;
import dev.langchain4j.service.AiServices;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import dev.langchain4j.memory.chat.MessageWindowChatMemory;

@Configuration
@RequiredArgsConstructor
public class AgentConfig {
    /**
     * ìµœì¢…ì ìœ¼ë¡œ AI ì„œë¹„ìŠ¤ë¥¼ ìƒì„±í•˜ì—¬ Beanìœ¼ë¡œ ë“±ë¡í•©ë‹ˆë‹¤.
     * ì´ `Agent`ëŠ” ìœ„ì—ì„œ ì •ì˜ëœ ëª¨ë“  ì»´í¬ë„ŒíŠ¸(ì±„íŒ… ëª¨ë¸, ë„êµ¬, ëŒ€í™” ë©”ëª¨ë¦¬, ì½˜í…ì¸  ê²€ìƒ‰ê¸°)ë¥¼ í†µí•©í•˜ì—¬
     * AI ì„œë¹„ìŠ¤ì˜ í•µì‹¬ ë¡œì§ì„ ì œê³µí•©ë‹ˆë‹¤.
     *
     * @param streamingChatLanguageModel ìŠ¤íŠ¸ë¦¬ë° ì±„íŒ… ëª¨ë¸ (ì´ì „ì— ì •ì˜ëœ ë¹ˆì„ ì£¼ì…ë°›ìŒ)
     * @param tools ì‚¬ìš©ì ì •ì˜ ë„êµ¬ (ì´ì „ì— ì •ì˜ëœ ë¹ˆì„ ì£¼ì…ë°›ìŒ)
     * @param chatMemoryProvider ëŒ€í™” ë©”ëª¨ë¦¬ ì œê³µì (ì´ì „ì— ì •ì˜ëœ ë¹ˆì„ ì£¼ì…ë°›ìŒ)
     * @param contentRetriever RAG ì½˜í…ì¸  ê²€ìƒ‰ê¸° (ì´ì „ì— ì •ì˜ëœ ë¹ˆì„ ì£¼ì…ë°›ìŒ)
     * @return LangChain4jì— ì˜í•´ ë™ì ìœ¼ë¡œ ìƒì„±ëœ `Agent` ì¸í„°í˜ì´ìŠ¤ì˜ êµ¬í˜„ì²´
     */

    @Bean
    public ReportAgent reportAgent(StreamingChatLanguageModel model, ReportTools reportTools) {
        ChatMemoryProvider dummyChatMemoryProvider = (memoryId) -> MessageWindowChatMemory.builder().maxMessages(10).build();

        return AiServices.builder(ReportAgent.class)
                .streamingChatLanguageModel(model)
                .tools(reportTools)
                .chatMemoryProvider(dummyChatMemoryProvider)
                .build();
    }

    @Bean
    public Agent chatAgent(StreamingChatLanguageModel streamingChatLanguageModel, ChatTools tools, ChatMemoryProvider chatMemoryProvider, ContentRetriever contentRetriever) {
        return AiServices.builder(Agent.class)
                .streamingChatLanguageModel(streamingChatLanguageModel)
                .tools(tools) // AIê°€ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë„êµ¬ë“¤ì„ ë“±ë¡í•©ë‹ˆë‹¤.
                .chatMemoryProvider(chatMemoryProvider) // ëŒ€í™” ë©”ëª¨ë¦¬ ì œê³µìë¥¼ ë“±ë¡í•©ë‹ˆë‹¤.
                .contentRetriever(contentRetriever) // RAGë¥¼ ìœ„í•œ ì½˜í…ì¸  ê²€ìƒ‰ê¸°ë¥¼ ë“±ë¡í•©ë‹ˆë‹¤.
                .build();
    }
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\config\AsyncConfig.java`

```java
package com.codehows.taelimbe.ai.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.task.TaskExecutor;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
import org.springframework.security.task.DelegatingSecurityContextAsyncTaskExecutor;

import java.util.concurrent.ThreadPoolExecutor;

/**
 * ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ë¹„ë™ê¸° ì‘ì—…ì„ ìœ„í•œ ì¤‘ì•™ ìŠ¤ë ˆë“œ í’€ì„ ì„¤ì •í•˜ëŠ” í´ë˜ìŠ¤ì…ë‹ˆë‹¤.
 * `@Configuration` ì–´ë…¸í…Œì´ì…˜ì€ ì´ í´ë˜ìŠ¤ê°€ Springì˜ ì„¤ì • í´ë˜ìŠ¤ì„ì„ ë‚˜íƒ€ë‚´ë©°,
 * Spring ì»¨í…Œì´ë„ˆê°€ ì´ í´ë˜ìŠ¤ì—ì„œ ì •ì˜ëœ `@Bean` ë©”ì„œë“œë¥¼ í†µí•´ ë¹ˆì„ ìƒì„±í•˜ë„ë¡ ì§€ì‹œí•©ë‹ˆë‹¤.
 */
@Configuration
@EnableAsync
public class AsyncConfig {

    /**
     * ë¹„ë™ê¸° ì‘ì—…ì„ ì²˜ë¦¬í•˜ê¸° ìœ„í•œ `TaskExecutor` Beanì„ ìƒì„±í•©ë‹ˆë‹¤.
     * ì´ `TaskExecutor`ëŠ” `@Async` ì–´ë…¸í…Œì´ì…˜ì´ ë¶™ì€ ë©”ì„œë“œë¥¼ ì‹¤í–‰í•˜ëŠ” ë° ì‚¬ìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
     * `TaskDecorator`ë¥¼ ì‚¬ìš©í•˜ì—¬ `UserContextHolder`ì˜ ì»¨í…ìŠ¤íŠ¸ë¥¼ ë¹„ë™ê¸° ìŠ¤ë ˆë“œë¡œ ì „íŒŒí•©ë‹ˆë‹¤.
     *
     * @return ì„¤ì •ì´ ì™„ë£Œëœ `ThreadPoolTaskExecutor` ì¸ìŠ¤í„´ìŠ¤
     */
    @Bean("taskExecutor")
    public TaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        // ì½”ì–´ ìŠ¤ë ˆë“œ í’€ì˜ í¬ê¸°ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤. ì´ ìˆ˜ë§Œí¼ì˜ ìŠ¤ë ˆë“œê°€ í•­ìƒ ìœ ì§€ë©ë‹ˆë‹¤.
        executor.setCorePoolSize(10);
        // ìµœëŒ€ ìŠ¤ë ˆë“œ í’€ì˜ í¬ê¸°ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤. ì½”ì–´ í’€ì´ ê°€ë“ ì°¨ê³  íë„ ê°€ë“ ì°¼ì„ ë•Œ ìƒì„±ë  ìˆ˜ ìˆëŠ” ìµœëŒ€ ìŠ¤ë ˆë“œ ìˆ˜ì…ë‹ˆë‹¤.
        executor.setMaxPoolSize(20);
        // ì‘ì—… íì˜ ìš©ëŸ‰ì„ ì„¤ì •í•©ë‹ˆë‹¤. ì½”ì–´ í’€ì˜ ìŠ¤ë ˆë“œê°€ ëª¨ë‘ ì‚¬ìš© ì¤‘ì¼ ë•Œ ì‘ì—…ì´ ëŒ€ê¸°í•˜ëŠ” ê³µê°„ì…ë‹ˆë‹¤.
        executor.setQueueCapacity(50);
        // ê±°ë¶€ ì •ì±…ì„ ì„¤ì •í•©ë‹ˆë‹¤. íê¹Œì§€ ê°€ë“ ì°¼ì„ ë•Œ ìƒˆë¡œìš´ ì‘ì—…ì´ ë“¤ì–´ì˜¤ë©´ í˜¸ì¶œì ìŠ¤ë ˆë“œê°€ ì§ì ‘ ì‘ì—…ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        // ìƒì„±ë˜ëŠ” ìŠ¤ë ˆë“œì˜ ì´ë¦„ ì ‘ë‘ì‚¬ë¥¼ ì„¤ì •í•˜ì—¬ ë¡œê·¸ì—ì„œ ìŠ¤ë ˆë“œë¥¼ ì‰½ê²Œ ì‹ë³„í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.
        executor.setThreadNamePrefix("async-task-");
        // Executorë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
        executor.initialize();

        return new DelegatingSecurityContextAsyncTaskExecutor(executor);
    }
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\config\ToolArgsContextHolder.java`

```java
package com.codehows.taelimbe.ai.config;

import java.util.HashMap;
import java.util.Map;

public class ToolArgsContextHolder {
    private static final ThreadLocal<Map<String, String>> toolArgs = new ThreadLocal<>();

    public static void setToolArgs(String key, String value) {
        if(toolArgs.get() == null) {
            toolArgs.set(new HashMap<>());
        }
        toolArgs.get().put(key, value);
    }

    public static String getToolArgs(String key) {
        return toolArgs.get().get(key);
    }

}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\constant\SenderType.java`

```java
package com.codehows.taelimbe.ai.constant;

/**
 * AI ì±„íŒ…ì—ì„œ ë©”ì‹œì§€ë¥¼ ë³´ë‚¸ ì£¼ì²´ë¥¼ ë‚˜íƒ€ë‚´ëŠ” Enum
 * USER: ì‹¤ì œ ì‚¬ìš©ì(Role.USER, Role.MANAGER, Role.ADMIN ëª¨ë‘ í¬í•¨)ê°€ ë³´ë‚¸ ë©”ì‹œì§€
 * AI: AI ì—ì´ì „íŠ¸(Gemini)ê°€ ë³´ë‚¸ ì‘ë‹µ
 */
public enum SenderType {
    USER("ì‚¬ìš©ì"),
    AI("AI");

    private final String description;

    SenderType(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\controller\AgentController.java`

```java
package com.codehows.taelimbe.ai.controller;

import com.codehows.taelimbe.ai.dto.ChatPromptRequest;
import com.codehows.taelimbe.ai.dto.EmbeddingRequest;
import com.codehows.taelimbe.ai.service.AgentService;
import com.codehows.taelimbe.ai.service.SseService;
import com.codehows.taelimbe.ai.service.EmbeddingService;
import com.codehows.taelimbe.user.security.UserPrincipal;
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;

@RestController
@RequiredArgsConstructor
@Slf4j
public class AgentController {

    private final AgentService agentService;
    private final SseService sseService;
    private final EmbeddingService embeddingService;


    // SSE ì—°ê²°, AI ì‘ë‹µ ë°›ì•„ì˜´
    @PostMapping("/agent/chat")
    public SseEmitter chat(@RequestBody ChatPromptRequest req, Authentication authentication) {

        UserPrincipal user = (UserPrincipal) authentication.getPrincipal();

        String conversationId = req.getConversationId();
        if (conversationId == null || conversationId.isBlank()) {
            conversationId = UUID.randomUUID().toString();
        }

        SseEmitter emitter = sseService.createEmitter(conversationId);

        agentService.process(conversationId, req.getMessage(), user.userId());
        return emitter;
    }


    /**
     * ------------------------------------------------------------
     * 4) Embedding ì²˜ë¦¬
     * POST /api/embeddings
     * ------------------------------------------------------------
     */
    @PostMapping("/embeddings")
    public CompletableFuture<ResponseEntity<String>> embed(@RequestBody EmbeddingRequest request) { // @Valid ì¶”ê°€
        return embeddingService.embedAndStore(request.getText())
                // ì„ë² ë”© ë° ì €ì¥ ì‘ì—…ì´ ì„±ê³µì ìœ¼ë¡œ ì‹œì‘ë˜ë©´ 200 OK ì‘ë‹µì„ ë°˜í™˜í•©ë‹ˆë‹¤.
                .thenApply(v -> ResponseEntity.ok("Text embedding and storing process started successfully."))
                // ì‘ì—… ì¤‘ ì˜ˆì™¸ ë°œìƒ ì‹œ 500 Internal Server Error ì‘ë‹µì„ ë°˜í™˜í•©ë‹ˆë‹¤.
                .exceptionally(ex -> {
                    log.error("embedAndStore ì‘ì—… ì‹¤í–‰ ì‹¤íŒ¨", ex);
                    Throwable cause = ex.getCause();
                    String errorMessage = (cause != null) ? cause.getMessage() : ex.getMessage();
                    return ResponseEntity.internalServerError().body("Failed to start embedding process: " + errorMessage);
                });
    }

    /**
     * ------------------------------------------------------------
     * 5) Embedding ë¦¬ì…‹
     * POST /api/embeddings/reset
     * ------------------------------------------------------------
     */
    @PostMapping("/embeddings/reset")
    public CompletableFuture<ResponseEntity<String>> resetAndEmbed(@RequestBody EmbeddingRequest request) { // @Valid ì¶”ê°€
        return embeddingService.resetAndEmbed(request.getText())
                // ì €ì¥ì†Œ ì¬ì„¤ì • ë° ì„ë² ë”© ì‘ì—…ì´ ì„±ê³µì ìœ¼ë¡œ ì‹œì‘ë˜ë©´ 200 OK ì‘ë‹µì„ ë°˜í™˜í•©ë‹ˆë‹¤.
                .thenApply(v -> ResponseEntity.ok("Embedding store reset and new text embedding process started successfully."))
                // ì‘ì—… ì¤‘ ì˜ˆì™¸ ë°œìƒ ì‹œ 500 Internal Server Error ì‘ë‹µì„ ë°˜í™˜í•©ë‹ˆë‹¤.
                .exceptionally(ex -> {
                    log.error("resetAndEmbed ì‘ì—… ì‹¤í–‰ ì‹¤íŒ¨", ex);
                    Throwable cause = ex.getCause();
                    String errorMessage = (cause != null) ? cause.getMessage() : ex.getMessage();
                    return ResponseEntity.internalServerError().body("Failed to start reset and embedding process: " + errorMessage);
                });
    }

    @PostMapping("/embeddings/add")
    public CompletableFuture<ResponseEntity<String>> addEmbed(@RequestBody EmbeddingRequest request) {
        return embeddingService.embedByValue(request.getText())
                // ì €ì¥ì†Œ ì¬ì„¤ì • ë° ì„ë² ë”© ì‘ì—…ì´ ì„±ê³µì ìœ¼ë¡œ ì‹œì‘ë˜ë©´ 200 OK ì‘ë‹µì„ ë°˜í™˜í•©ë‹ˆë‹¤.
                .thenApply(v -> ResponseEntity.ok("success"))
                // ì‘ì—… ì¤‘ ì˜ˆì™¸ ë°œìƒ ì‹œ 500 Internal Server Error ì‘ë‹µì„ ë°˜í™˜í•©ë‹ˆë‹¤.
                .exceptionally(ex -> {
                    log.error("resetAndEmbed ì‘ì—… ì‹¤í–‰ ì‹¤íŒ¨", ex);
                    Throwable cause = ex.getCause();
                    String errorMessage = (cause != null) ? cause.getMessage() : ex.getMessage();
                    return ResponseEntity.internalServerError().body("Failed to start reset and embedding process: " + errorMessage);
                });
    }

    @DeleteMapping("/embeddings/{key}")
    public CompletableFuture<ResponseEntity<String>> deleteEmbed(@PathVariable String key) {
        return embeddingService.deleteByKey(key)
                // ì €ì¥ì†Œ ì¬ì„¤ì • ë° ì„ë² ë”© ì‘ì—…ì´ ì„±ê³µì ìœ¼ë¡œ ì‹œì‘ë˜ë©´ 200 OK ì‘ë‹µì„ ë°˜í™˜í•©ë‹ˆë‹¤.
                .thenApply(v -> ResponseEntity.ok("success"))
                // ì‘ì—… ì¤‘ ì˜ˆì™¸ ë°œìƒ ì‹œ 500 Internal Server Error ì‘ë‹µì„ ë°˜í™˜í•©ë‹ˆë‹¤.
                .exceptionally(ex -> {
                    log.error("resetAndEmbed ì‘ì—… ì‹¤í–‰ ì‹¤íŒ¨", ex);
                    Throwable cause = ex.getCause();
                    String errorMessage = (cause != null) ? cause.getMessage() : ex.getMessage();
                    return ResponseEntity.internalServerError().body("Failed to start reset and embedding process: " + errorMessage);
                });
    }

    @PostMapping("/embeddings/upload-csv")
    public CompletableFuture<ResponseEntity<String>> embedCsv(@RequestParam("file") MultipartFile file) {
        if (file.isEmpty() || !file.getOriginalFilename().toLowerCase().endsWith(".csv")) {
            return CompletableFuture.completedFuture(
                    ResponseEntity.badRequest().body("CSV íŒŒì¼ì„ ì„ íƒí•˜ê±°ë‚˜ ìœ íš¨í•œ íŒŒì¼ í˜•ì‹ì„ í™•ì¸í•´ì£¼ì„¸ìš”."));
        }

        // CSV íŒŒì¼ ì²˜ë¦¬ ë¡œì§ì„ EmbeddingServiceë¡œ ìœ„ì„í•©ë‹ˆë‹¤.
        return embeddingService.embedAndStoreCsv(file)
                .thenApply(v -> ResponseEntity.ok("CSV íŒŒì¼ ì„ë² ë”© ë° ì €ì¥ í”„ë¡œì„¸ìŠ¤ê°€ ì„±ê³µì ìœ¼ë¡œ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤."))
                .exceptionally(ex -> {
                    log.error("CSV íŒŒì¼ embedAndStore ì‘ì—… ì‹¤í–‰ ì‹¤íŒ¨", ex);
                    return ResponseEntity.internalServerError().body("CSV íŒŒì¼ ì²˜ë¦¬ ì‹¤íŒ¨: " + ex.getMessage());
                });
    }

    @PostMapping("/embeddings/upload-pdf")
    public CompletableFuture<ResponseEntity<String>> embedPdf(
            @RequestParam("file") MultipartFile file
    ) {
        if (file.isEmpty() || !file.getOriginalFilename().toLowerCase().endsWith(".pdf")) {
            return CompletableFuture.completedFuture(
                    ResponseEntity.badRequest().body("PDF íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.")
            );
        }

        return embeddingService.embedAndStorePdf(file)
                .thenApply(v -> ResponseEntity.ok("PDF ë³‘ë ¬ ì„ë² ë”© ì‹œì‘ë¨"))
                .exceptionally(ex -> {
                    log.error("PDF embed error", ex);
                    return ResponseEntity.internalServerError().body(ex.getMessage());
                });
    }

}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\controller\AiChatController.java`

```java
package com.codehows.taelimbe.ai.controller;

import com.codehows.taelimbe.ai.dto.AiChatDTO;
import com.codehows.taelimbe.ai.service.AiChatService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@Slf4j
@RestController
@RequestMapping
@RequiredArgsConstructor
public class AiChatController {

    private final AiChatService aiChatService;


    // ì‚¬ìš©ìì˜ ëŒ€í™” ëª©ë¡ ì¡°íšŒ (ì‚¬ì´ë“œë°”ì—ì„œ ì‚¬ìš©)
    @GetMapping("/chat/history")
    public ResponseEntity<List<AiChatDTO>> getChatHistory(Authentication authentication) {
        List<AiChatDTO> chatList = aiChatService.getUserChatList(authentication);
        return ResponseEntity.ok(chatList);
    }


    // íŠ¹ì • ëŒ€í™”ì˜ ë©”ì‹œì§€ ëª©ë¡ ì¡°íšŒ
    @GetMapping("/conversation/{conversationId}")
    public ResponseEntity<List<AiChatDTO>> getConversationMessages(
            @PathVariable String conversationId) {
        List<AiChatDTO> messages = aiChatService.getChatHistory(conversationId);
        return ResponseEntity.ok(messages);
    }


    // ìƒˆ ì±„íŒ…
    @PostMapping("/new/chat")
    public ResponseEntity<?> startNewChat(Authentication authentication) {
        String conversationId = aiChatService.startNewChat(authentication);
        return ResponseEntity.ok(Map.of("conversationId", conversationId));
    }




}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\controller\AiReportController.java`

```java
package com.codehows.taelimbe.ai.controller;

import com.codehows.taelimbe.ai.dto.AiReportDTO;
import com.codehows.taelimbe.ai.dto.ChatPromptRequest;

import com.codehows.taelimbe.ai.repository.RawReportProjection;
import com.codehows.taelimbe.ai.service.AiReportService;
import com.codehows.taelimbe.user.security.UserPrincipal;
import lombok.RequiredArgsConstructor;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.util.List;
import java.util.Map;

@RestController
@RequiredArgsConstructor
@RequestMapping("/ai/report")
public class AiReportController {

    private final AiReportService aiReportService;

    // ë³´ê³ ì„œ ëª©ë¡ ì¡°íšŒ
    @GetMapping
    public ResponseEntity<List<AiReportDTO>> getAllReports(
            Authentication authentication
    ) {
        UserPrincipal user =
                (UserPrincipal) authentication.getPrincipal();

        return ResponseEntity.ok(
                aiReportService.getAllReports(user)
        );
    }

    // 1ë‹¨ê³„: ë³´ê³ ì„œ ìƒì„± ì‹œì‘
    @PostMapping
    public ResponseEntity<Map<String, String>> createReport(
            @RequestBody ChatPromptRequest req,
            Authentication authentication
    ) {
        UserPrincipal user =
                (UserPrincipal) authentication.getPrincipal();

        String conversationId =
                aiReportService.startGenerateReport(req, user);

        return ResponseEntity.ok(
                Map.of("conversationId", conversationId)
        );
    }

    // 2ë‹¨ê³„: SSE ìŠ¤íŠ¸ë¦¼ êµ¬ë…
    @GetMapping(
            value = "/stream/{conversationId}",
            produces = MediaType.TEXT_EVENT_STREAM_VALUE
    )
    public SseEmitter stream(@PathVariable String conversationId) {
        return aiReportService.connectSse(conversationId);
    }

    /**
     * raw ë¦¬í¬íŠ¸ ì¡°íšŒ
     */
    @GetMapping("/{reportId}/rawReport")
    public ResponseEntity<RawReportProjection> getRawReport(
            @PathVariable Long reportId
    ) {
        return ResponseEntity.ok(
                aiReportService.getRawReport(reportId)
        );
    }

}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\dto\AiChatDTO.java`

```java
package com.codehows.taelimbe.ai.dto;

import com.codehows.taelimbe.ai.constant.SenderType;
import com.codehows.taelimbe.ai.entity.AiChat;
import lombok.*;

import java.time.LocalDateTime;

@Builder
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class AiChatDTO {

    private Long aiChatId;
    private String conversationId;
    private SenderType senderType;
    private String rawMessage;
    private LocalDateTime createdAt;
    private Long messageIndex;
    private Long userId;
    private String userName;


    public static AiChatDTO from(AiChat aiChat) {
        return AiChatDTO.builder()
                .aiChatId(aiChat.getAiChatId())
                .conversationId(aiChat.getConversationId())
                .senderType(aiChat.getSenderType())
                .rawMessage(aiChat.getRawMessage())
                .createdAt(aiChat.getCreatedAt())
                .messageIndex(aiChat.getMessageIndex())
                .userId(aiChat.getUser() != null ? aiChat.getUser().getUserId() : null)
                .userName(aiChat.getUser() != null ? aiChat.getUser().getName() : null)
                .build();
    }
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\dto\AiReportDTO.java`

```java
package com.codehows.taelimbe.ai.dto;

import com.codehows.taelimbe.ai.entity.AiReport;

import com.codehows.taelimbe.ai.repository.AiReportMetaProjection;

import lombok.*;

import java.time.LocalDate;
import java.time.LocalDateTime;

@Builder
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class AiReportDTO {

    private Long aiReportId;
    private String conversationId;
    private LocalDate startTime;
    private LocalDate endTime;
    private LocalDateTime createdAt;
    private String rawReport;
    private String rawMessage;
    private Long userId;
    private String name;

//ì§€ê¸ˆì€ ë°ì´ë²„ ë² ì´ìŠ¤ì— ì €ì¥í•˜ëŠ” ìš©ë„ë¡œ ì‚¬ìš©ì¤‘
    public static AiReportDTO from(AiReport aiReport) {
        return AiReportDTO.builder()
                .aiReportId(aiReport.getAiReportId())
                .conversationId(aiReport.getConversationId())
                .startTime(aiReport.getStartTime())
                .endTime(aiReport.getEndTime())
                .createdAt(aiReport.getCreatedAt())
                .rawMessage(aiReport.getRawMessage())
                .rawReport(aiReport.getRawReport())
                .userId(aiReport.getUser().getUserId())
                .name(aiReport.getUser().getName())
                .build();
    }

    // fromìœ¼ë¡œ ê°€ì ¸ì˜¤ë©´ rawReportê¹Œì§€ get í•´ì•¼í•´ì„œ ìš©ëŸ‰ì´ ë„ˆë¬´ ë§ì•„ì§„ë‹¤ rawReportëŠ” ë”°ë¡œ ê´€ë¦¬
    // ëª©ë¡ ì¡°íšŒ ìµœì í™”í•˜ê¸° ìœ„í•´ AiReportMetaProjection ë¼ëŠ”ê±¸ ë”°ë¡œ ë§Œë“¤ì–´ì„œ DTOì—ì„œ ë¹¼ì˜¤ëŠ”ê²¨
    public static AiReportDTO fromProjection(AiReportMetaProjection projection) {
        return AiReportDTO.builder()
                .aiReportId(projection.getAiReportId())
                .conversationId(projection.getConversationId())
                .startTime(projection.getStartTime().toLocalDate())
                .endTime(projection.getEndTime().toLocalDate())
                .createdAt(projection.getCreatedAt())
                .rawMessage(projection.getRawMessage())
                .name(projection.getName())
                .build();
    }

}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\dto\ChatPromptRequest.java`

```java
package com.codehows.taelimbe.ai.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * ì±„íŒ… í”„ë¡¬í”„íŠ¸ ìš”ì²­ì„ ìœ„í•œ ë°ì´í„° ì „ì†¡ ê°ì²´(DTO)ì…ë‹ˆë‹¤.
 * í´ë¼ì´ì–¸íŠ¸ë¡œë¶€í„° AI ì—ì´ì „íŠ¸ì—ê²Œ ì „ë‹¬ë  ë©”ì‹œì§€ì™€ ëŒ€í™” IDë¥¼ ìº¡ìŠí™”í•©ë‹ˆë‹¤.
 *
 * `@Data`ëŠ” Lombok ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ, `@Getter`, `@Setter`, `@EqualsAndHashCode`, `@ToString`ì„ ìë™ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.
 * `@NoArgsConstructor`ëŠ” ì¸ì ì—†ëŠ” ê¸°ë³¸ ìƒì„±ìë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.
 * `@AllArgsConstructor`ëŠ” ëª¨ë“  í•„ë“œë¥¼ ì¸ìë¡œ ë°›ëŠ” ìƒì„±ìë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ChatPromptRequest {
    /**
     * ì‚¬ìš©ìë¡œë¶€í„° AI ì—ì´ì „íŠ¸ì—ê²Œ ì „ë‹¬ë  ë©”ì‹œì§€ì…ë‹ˆë‹¤.
     */
    private String message;
    /**
     * í˜„ì¬ ëŒ€í™”ì˜ ê³ ìœ  IDì…ë‹ˆë‹¤.
     * ì´ IDë¥¼ í†µí•´ AI ì—ì´ì „íŠ¸ê°€ ì´ì „ ëŒ€í™”ì˜ ì»¨í…ìŠ¤íŠ¸ë¥¼ ìœ ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
     */
    private String conversationId;
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\dto\EmbeddingRequest.java`

```java
package com.codehows.taelimbe.ai.dto;

import lombok.Data;

/**
 * ì„ë² ë”© ìƒì„±ì„ ìœ„í•œ ìš”ì²­ ë°ì´í„° ì „ì†¡ ê°ì²´(DTO)ì…ë‹ˆë‹¤.
 * ì„ë² ë”©ì„ ìƒì„±í•  í…ìŠ¤íŠ¸ ë°ì´í„°ë¥¼ ìº¡ìŠí™”í•©ë‹ˆë‹¤.
 *
 * `@Data`ëŠ” Lombok ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ, `@Getter`, `@Setter`, `@EqualsAndHashCode`, `@ToString`ì„ ìë™ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.
 */
@Data
public class EmbeddingRequest {
    /**
     * ì„ë² ë”©ì„ ìƒì„±í•  ì›ë³¸ í…ìŠ¤íŠ¸ì…ë‹ˆë‹¤.
     */
    private String text;
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\dto\ReportResult.java`

```java
package com.codehows.taelimbe.ai.dto;

public class ReportResult {
    private final String jsonReport;
    private final String startDate;
    private final String endDate;

    public ReportResult(String jsonReport, String startDate, String endDate) {
        this.jsonReport = jsonReport;
        this.startDate = startDate;
        this.endDate = endDate;
    }

    public String getJsonReport() { return jsonReport; }
    public String getStartDate() { return startDate; }
    public String getEndDate() { return endDate; }
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\entity\AiChat.java`

```java
package com.codehows.taelimbe.ai.entity;

import com.codehows.taelimbe.ai.constant.SenderType;
import com.codehows.taelimbe.user.entity.User;
import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "ai_chat")
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Builder
public class AiChat {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ai_chat_id")
    private Long aiChatId;

    @Column(name = "conversation_id", length = 100, nullable = false)
    private String conversationId;

    @Enumerated(EnumType.STRING)
    @Column(name = "sender_type", nullable = false)
    private SenderType senderType;

    @Column(name = "raw_message", columnDefinition = "LONGTEXT", nullable = false)
    private String rawMessage;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "message_index", nullable = false)
    private Long messageIndex;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    // ì—”í‹°í‹° ìƒì„± ì‹œ ìë™ìœ¼ë¡œ ìƒì„± ì‹œê°„ ì„¤ì •
    @PrePersist
    protected void onCreate() {
        if (this.createdAt == null) {
            this.createdAt = LocalDateTime.now();
        }
    }
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\entity\AiReport.java`

```java
package com.codehows.taelimbe.ai.entity;

import com.codehows.taelimbe.user.entity.User;
import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDate;
import java.time.LocalDateTime;

@Entity
@Table(name = "ai_report")
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Builder
public class AiReport {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ai_report_id")
    private Long aiReportId;

    @Column(name = "conversation_id", length = 100)
    private String conversationId;

    @Column(name = "start_time")
    private LocalDate startTime;

    @Column(name = "end_time")
    private LocalDate endTime;

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "raw_message")
    private String rawMessage;

    @Column(name = "raw_report", columnDefinition = "LONGTEXT")
    private String rawReport;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;

}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\entity\Embed.java`

```java
package com.codehows.taelimbe.ai.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import lombok.*;

@Entity
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Embed {

    @Id
    private String embedKey;

    private String embedValue;

}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\entity\QaKnowledge.java`

```java
package com.codehows.taelimbe.ai.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Entity
@Getter
@NoArgsConstructor
public class QaKnowledge {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long QaKnowledgeId;


    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "representative_question_id")
    private RepresentativeQuestion representativeQuestion;

    @Column(columnDefinition = "TEXT")
    private String answer;

    private boolean active;

    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;



    public static QaKnowledge create(RepresentativeQuestion rep, String answer) {
        QaKnowledge qa = new QaKnowledge();
        qa.representativeQuestion = rep;
        qa.answer = answer;
        qa.active = true;
        qa.createdAt = LocalDateTime.now();
        qa.updatedAt = qa.createdAt;
        return qa;
    }

    public void updateAnswer(String answer) {
        this.answer = answer;
        this.updatedAt = LocalDateTime.now();
    }

    public void deactivate() {
        this.active = false;
        this.updatedAt = LocalDateTime.now();
    }
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\entity\RepresentativeQuestion.java`

```java
package com.codehows.taelimbe.ai.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.Getter;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Entity
@Getter
@NoArgsConstructor
public class RepresentativeQuestion {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long representativeQuestionId;

    // ëŒ€í‘œ ì§ˆë¬¸ (ì˜ë¯¸ ë‹¨ìœ„)
    private String title;

    // ì˜ë¯¸ ê¸°ì¤€ í™•ì • íšŸìˆ˜
    private int hitCount;

    private LocalDateTime createdAt;
    private LocalDateTime lastHitAt;



    public static RepresentativeQuestion create(String title) {
        RepresentativeQuestion rep = new RepresentativeQuestion();
        rep.title = title;
        rep.hitCount = 1;
        rep.createdAt = LocalDateTime.now();
        return rep;
    }

    public void increaseHit() {
        this.hitCount++;
        this.lastHitAt = LocalDateTime.now();
    }
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\entity\UnansweredQuestion.java`

```java
package com.codehows.taelimbe.ai.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Entity
@Getter
@NoArgsConstructor
public class UnansweredQuestion {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long unansweredQuestionId;

    // ì‚¬ìš©ì ì›ë¬¸ ì§ˆë¬¸
    @Column(columnDefinition = "TEXT")
    private String userQuestionText;

    // ë¬¸ìì—´ ì¤‘ë³µ ì œê±°ìš©
    private String normalizedText;

    // ë™ì¼ ë¬¸ìì—´ ë°˜ë³µ íšŸìˆ˜
    private int count;

    // < NEW / RESOLVED >
    private String status;


    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "representative_question_id")
    private RepresentativeQuestion representativeQuestion;

    private LocalDateTime createdAt;
    private LocalDateTime lastAskedAt;



    public static UnansweredQuestion create(String questionText, String normalizedText) {
        UnansweredQuestion q = new UnansweredQuestion();
        q.userQuestionText = questionText;
        q.normalizedText = normalizedText;
        q.count = 1;
        q.status = "NEW";
        q.createdAt = LocalDateTime.now();
        q.lastAskedAt = q.createdAt;
        return q;
    }

    public void increaseCount() {
        this.count++;
        this.lastAskedAt = LocalDateTime.now();
    }

    public void resolveWith(RepresentativeQuestion rep) {
        this.representativeQuestion = rep;
        this.status = "RESOLVED";
    }
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\repository\AiChatRepository.java`

```java
package com.codehows.taelimbe.ai.repository;

import com.codehows.taelimbe.ai.entity.AiChat;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface AiChatRepository extends JpaRepository<AiChat, Long> {

    // íŠ¹ì • ëŒ€í™”ì˜ ëª¨ë“  ë©”ì‹œì§€ ì¡°íšŒ (ë©”ì‹œì§€ ìˆœì„œëŒ€ë¡œ)
    List<AiChat> findByConversationIdOrderByMessageIndex(String conversationId);

    // íŠ¹ì • ì‚¬ìš©ìì˜ ëª¨ë“  ëŒ€í™” ì¡°íšŒ
    List<AiChat> findByUser_UserIdOrderByCreatedAtDesc(Long userId);

    // íŠ¹ì • ë§¤ì¥ì˜ ëª¨ë“  ëŒ€í™” ì¡°íšŒ
    @Query("SELECT c FROM AiChat c WHERE c.user.store.storeId = :storeId ORDER BY c.createdAt DESC")
    List<AiChat> findByStoreIdOrderByCreatedAtDesc(@Param("storeId") Long storeId);

    // íŠ¹ì • ëŒ€í™”ì˜ ë§ˆì§€ë§‰ ë©”ì‹œì§€ ì¸ë±ìŠ¤ ì¡°íšŒ
    @Query("SELECT COALESCE(MAX(c.messageIndex), 0) FROM AiChat c WHERE c.conversationId = :conversationId")
    Long findMaxMessageIndexByConversationId(@Param("conversationId") String conversationId);

    @Query("""
    SELECT c.conversationId
    FROM AiChat c
    WHERE c.user.userId = :userId
    GROUP BY c.conversationId
    ORDER BY MAX(c.createdAt) DESC
""")
    List<String> findConversationIdsByUserId(@Param("userId") Long userId);


    List<AiChat> findByConversationIdOrderByMessageIndexAsc(String conversationId);

    @Query("SELECT DISTINCT a.conversationId FROM AiChat a WHERE a.user.userId = :userId")
    List<String> findConversationIdsByUser(@Param("userId") Long userId);

    long countByConversationId(String conversationId);
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\repository\AiReportMetaProjection.java`

```java
package com.codehows.taelimbe.ai.repository; // Repositoryì™€ ê°™ì€ íŒ¨í‚¤ì§€ì— ë‘ëŠ” ê²ƒì´ ì¼ë°˜ì ì…ë‹ˆë‹¤.

import java.time.LocalDateTime;

public interface AiReportMetaProjection {
    Long getAiReportId();
    String getConversationId();
    LocalDateTime getStartTime();
    LocalDateTime getEndTime();
    LocalDateTime getCreatedAt();
    String getRawMessage(); // DTOì™€ ë™ì¼í•˜ê²Œ í¬í•¨
    String getName();
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\repository\AiReportRepository.java`

```java
package com.codehows.taelimbe.ai.repository;


import com.codehows.taelimbe.ai.entity.AiReport;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface AiReportRepository extends JpaRepository<AiReport, Long> {

    /* =========== Entity ê¸°ë°˜ ì¡°íšŒ (AiReportServiceì—ì„œ ì‚¬ìš©) =========== */

    // ë³¸ì¸ ì‘ì„± ë³´ê³ ì„œ ì¡°íšŒ
    List<AiReport> findAllByUser_UserIdOrderByCreatedAtDesc(Long userId);

    /* =========== Raw Report ì¡°íšŒ =========== */

    @Query("SELECT a.rawReport as rawReport FROM AiReport a WHERE a.aiReportId = :reportId")
    Optional<RawReportProjection> findRawReportById(@Param("reportId") Long reportId);
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\repository\EmbedRepository.java`

```java
package com.codehows.taelimbe.ai.repository;

import com.codehows.taelimbe.ai.entity.Embed;
import org.springframework.data.jpa.repository.JpaRepository;

public interface EmbedRepository extends JpaRepository<Embed, String> {

}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\repository\RawReportProjection.java`

```java
package com.codehows.taelimbe.ai.repository;

public interface RawReportProjection {
    String getRawReport();
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\service\AgentService.java`

```java
package com.codehows.taelimbe.ai.service;

import com.codehows.taelimbe.langchain.Agent;
import com.codehows.taelimbe.notification.constant.NotificationType;
import com.codehows.taelimbe.notification.service.NotificationService;
import dev.langchain4j.service.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

/**
 * AI ì—ì´ì „íŠ¸ì™€ì˜ ëŒ€í™” ë¡œì§ì„ ìº¡ìŠí™”í•˜ëŠ” ì„œë¹„ìŠ¤ í´ë˜ìŠ¤
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class AgentService {
    private final SseService sseService;
    private final AiChatService aiChatService;
    private final NotificationService notificationService;

    @Qualifier("chatAgent")
    private final Agent chatAgent;

    @Async
    public void process(String conversationId, String message, Long userId) {

        // 1) ì‚¬ìš©ì ë©”ì‹œì§€ ì €ì¥
        aiChatService.saveUserMessage(conversationId, userId, message);

        // 2) TokenStream ê°€ì ¸ì˜¤ê¸°
        TokenStream stream = chatAgent.chat(message, conversationId);

        StringBuilder aiBuilder = new StringBuilder();

        // 3) í† í° ìŠ¤íŠ¸ë¦¬ë° ì‹œì‘
        stream.onNext(token -> {
                    aiBuilder.append(token);
                    sseService.send(conversationId, token);
                })
                .onComplete(finalResponse -> {
                    aiChatService.saveAiMessage(conversationId, userId, aiBuilder.toString());
                    sseService.complete(conversationId);

                    notificationService.notify(userId, NotificationType.AI_CHAT_SUCCESS, "AI ì±—ë´‡ ë‹µë³€ì´ ë„ì°©í–ˆìŠµë‹ˆë‹¤");


                })
                .onError(e -> {
                    log.error("AI ìŠ¤íŠ¸ë¦¼ ì˜¤ë¥˜", e);
                    sseService.completeWithError(conversationId, e);
                })
                .start();  
    }

}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\service\AiChatService.java`

```java
package com.codehows.taelimbe.ai.service;

import com.codehows.taelimbe.ai.constant.SenderType;
import com.codehows.taelimbe.ai.dto.AiChatDTO;
import com.codehows.taelimbe.ai.entity.AiChat;
import com.codehows.taelimbe.ai.repository.AiChatRepository;
import com.codehows.taelimbe.user.entity.User;
import com.codehows.taelimbe.user.repository.UserRepository;
import com.codehows.taelimbe.user.security.UserPrincipal;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Transactional
@Slf4j
public class AiChatService {

    private final AiChatRepository aiChatRepository;
    private final UserRepository userRepository;

    // í˜„ì¬ ë¡œê·¸ì¸í•œ ì‚¬ìš©ì ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    private User getCurrentUser() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String username = authentication.getName();
        return userRepository.findById(username)
                .orElseThrow(() -> new RuntimeException("ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: " + username));
    }


    public String startNewChat(Authentication authentication) {
        UserPrincipal principal = (UserPrincipal) authentication.getPrincipal();
        Long userId = principal.userId();

        String id = UUID.randomUUID().toString();

        AiChat chat = AiChat.builder()
                .conversationId(id)
                .user(userRepository.findById(userId).orElseThrow(() -> new RuntimeException("User not found")))
                .build();

        aiChatRepository.save(chat);
        return id;
    }


    @Transactional(readOnly = true)
    public List<AiChatDTO> getChatHistory(String conversationId) {
        return aiChatRepository.findByConversationIdOrderByMessageIndex(conversationId)
                .stream()
                .map(AiChatDTO::from)
                .collect(Collectors.toList());
    }


    // ì‚¬ìš©ìì˜ ëŒ€í™” ëª©ë¡ ì¡°íšŒ ê° ëŒ€í™”ì˜ ì²« ë²ˆì§¸ ë©”ì‹œì§€ë¥¼ ëŒ€í™” ì œëª©ìœ¼ë¡œ ì‚¬ìš©
    @Transactional(readOnly = true)
    public List<AiChatDTO> getUserChatList(Authentication authentication) {
        UserPrincipal principal = (UserPrincipal) authentication.getPrincipal();
        Long userId = principal.userId();

        List<String> conversationIds = aiChatRepository.findConversationIdsByUserId(userId);

        if (conversationIds == null || conversationIds.isEmpty()) {
            return Collections.emptyList();
        }

        return conversationIds.stream()
                .map(convId -> {
                    List<AiChat> messages = aiChatRepository.findByConversationIdOrderByMessageIndex(convId);
                    if (messages == null || messages.isEmpty()) return null;

                    AiChat firstMessage = messages.stream()
                            .filter(msg -> msg.getSenderType() == SenderType.USER)
                            .findFirst()
                            .orElse(messages.get(0));

                    return AiChatDTO.from(firstMessage);
                })
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }


    // USER ë©”ì‹œì§€ ì €ì¥
    public void saveUserMessage(String convId, Long userId, String msg) {
        log.info("ğŸ” [saveUserMessage] START convId={}, userId={}, msg={}", convId, userId, msg);
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new IllegalArgumentException("User not found"));

        long idx = aiChatRepository.countByConversationId(convId);
        log.info("ğŸ” [saveUserMessage] nextIndex={}", idx);

        AiChat chat = AiChat.builder()
                .conversationId(convId)
                .senderType(SenderType.USER)
                .rawMessage(msg)
                .messageIndex(idx)
                .user(user)
                .build();

        aiChatRepository.save(chat);
    }

    // AI ë©”ì‹œì§€ ì €ì¥
    public void saveAiMessage(String convId, Long userId, String msg) {

        User user = userRepository.findById(userId)
                .orElseThrow(() -> new IllegalArgumentException("User not found"));

        long idx = aiChatRepository.countByConversationId(convId);

        AiChat chat = AiChat.builder()
                .conversationId(convId)
                .senderType(SenderType.AI)
                .rawMessage(msg)
                .messageIndex(idx)
                .user(user)
                .build();

        aiChatRepository.save(chat);
    }
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\service\AiReportService.java`

```java
package com.codehows.taelimbe.ai.service;

import com.codehows.taelimbe.ai.agent.ReportAgent;
import com.codehows.taelimbe.ai.config.ToolArgsContextHolder;
import com.codehows.taelimbe.ai.dto.AiReportDTO;
import com.codehows.taelimbe.ai.dto.ChatPromptRequest;
import com.codehows.taelimbe.ai.entity.AiReport;
import com.codehows.taelimbe.ai.repository.AiReportRepository;
import com.codehows.taelimbe.ai.repository.RawReportProjection;
import com.codehows.taelimbe.langchain.tools.ReportTools;
import com.codehows.taelimbe.notification.constant.NotificationType;
import com.codehows.taelimbe.notification.service.NotificationService;
import com.codehows.taelimbe.user.entity.User;
import com.codehows.taelimbe.user.repository.UserRepository;
import com.codehows.taelimbe.user.security.UserPrincipal;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Map;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Transactional
@Slf4j
public class AiReportService {

    private final SseService sseService;
    private final ReportAgent reportAgent;
    private final AiReportRepository aiReportRepository;
    private final UserRepository userRepository;
    private final ReportTools reportTools;
    private final NotificationService notificationService;


    // 1. ë³´ê³ ì„œ ìƒì„± ì‹œì‘
    public String startGenerateReport(ChatPromptRequest req, UserPrincipal user) {

        String conversationId = UUID.randomUUID().toString();


        // ë¹„ë™ê¸°ë¡œ AI ì‹¤í–‰
        generateAsync(conversationId, req.getMessage(), user);

        return conversationId;
    }

    // 2. SSE ì—°ê²°
    public SseEmitter connectSse(String conversationId) {
       return sseService.createEmitter(conversationId);
    }

    // 3. ì‹¤ì œ AI ë³´ê³ ì„œ ìƒì„± (ë¹„ë™ê¸°)
    @Async
    protected void generateAsync(String conversationId, String message, UserPrincipal user) {

        // ì…ë ¥ ê²€ì¦
        if (message == null || message.isBlank()) {
            sseService.sendEvent(conversationId, "error", "ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.");
            sseService.complete(conversationId);

            return; // DB ì €ì¥í•˜ì§€ ì•Šê³  ì¢…ë£Œ
        }

        try {
            String generatedDate = LocalDateTime.now()
                    .format(DateTimeFormatter.ofPattern("yyyyë…„ MMì›” ddì¼"));

            String currentDate = LocalDate.now().toString();

            log.info("[AI Report] ë³´ê³ ì„œ ìƒì„± ì‹œì‘ - ì‚¬ìš©ì ìš”ì²­: {}", message);

            // AI Agentê°€ ì•Œì•„ì„œ ë‚ ì§œë¥¼ íŒë‹¨í•˜ê³  Toolì„ í˜¸ì¶œí•˜ë„ë¡ í•¨
            StringBuilder aiResult = new StringBuilder();

            reportAgent.report(message, currentDate, generatedDate)
                    .onNext(token -> {
                        aiResult.append(token);
                        sseService.send(conversationId, token);
                    })
                    .onComplete(res -> {
                        // AIê°€ ì‚¬ìš©í•œ ë‚ ì§œë¥¼ ì¶”ì¶œ (Tool í˜¸ì¶œ ë¡œê·¸ì—ì„œ)
                        // ê¸°ë³¸ê°’ìœ¼ë¡œ ì˜¤ëŠ˜ ë‚ ì§œ ì‚¬ìš©
                        String startDate = ToolArgsContextHolder.getToolArgs("startDate");
                        String endDate = ToolArgsContextHolder.getToolArgs("endDate");

                        AiReport saved = saveReport(user, conversationId, message,
                                aiResult.toString(), startDate, endDate);

                        sseService.sendEvent(conversationId, "savedReport", AiReportDTO.from(saved));
                        sseService.sendEvent(conversationId, "done", "done");
                        sseService.complete(conversationId);

                        notificationService.notify(user.userId(), NotificationType.AI_REPORT_SUCCESS, "AI ë³´ê³ ì„œ ìƒì„±ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤");



                        log.info("[AI Report] ë³´ê³ ì„œ ìƒì„± ì™„ë£Œ - ID: {}", saved.getAiReportId());
                    })
                    .onError(e -> {
                        log.error("AI Report Error", e);
                        sseService.sendEvent(
                                conversationId,
                                "error",
                                Map.of("messege","ë³´ê³ ì„œ ìƒì„± ì¤‘ ì˜¤ë¥˜ ë°œìƒ: " + e.getMessage(),
                                "type","AI_REPORT_ERROR"
                                )
                        );
                        sseService.completeWithError(conversationId, e);

                        // ì‹¤íŒ¨ ì•Œë¦¼
                        notificationService.notify(user.userId(), NotificationType.AI_REPORT_FAILED, "AI ë³´ê³ ì„œ ìƒì„±ì— ì‹¤íŒ¨í–ˆì–´ìš”. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.");



                    })
                    .start();
        } catch (IllegalArgumentException e) {
            // ê¸°ê°„ì´ ëª…í™•í•˜ì§€ ì•Šì€ ê²½ìš°
            sseService.sendEvent(conversationId, "error", e.getMessage());
            sseService.complete(conversationId);

            notificationService.notify(user.userId(), NotificationType.AI_REPORT_FAILED, "ê¸°ê°„ ì •ë³´ë¥¼ ì´í•´í•˜ì§€ ëª»í–ˆì–´ìš”. ë‚ ì§œë¥¼ ì¡°ê¸ˆ ë” ëª…í™•íˆ ì…ë ¥í•´ ì£¼ì„¸ìš”.");



        } catch (Exception e) {
            log.error("AI Report Exception", e);
            sseService.sendEvent(conversationId, "error", "ë³´ê³ ì„œ ìƒì„± ì¤‘ ì˜ˆì™¸ ë°œìƒ");
            sseService.completeWithError(conversationId, e);

            notificationService.notify(user.userId(), NotificationType.AI_REPORT_FAILED, "AI ë³´ê³ ì„œ ìƒì„±ì— ì‹¤íŒ¨í–ˆì–´ìš”. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”."
            );


        }
    }

    // ë³´ê³ ì„œ ì €ì¥
    private AiReport saveReport(UserPrincipal user, String conversationId, String prompt, String result,
                                String startDate, String endDate) {

        User entity = userRepository.findById(user.userId()).orElseThrow();

        return aiReportRepository.save(
                AiReport.builder()
                        .conversationId(conversationId)
                        .rawMessage(prompt)
                        .rawReport(result)
                        .startTime(startDate != null ? LocalDate.parse(startDate) : null)
                        .endTime(endDate != null ? LocalDate.parse(endDate) : null)
                        .createdAt(LocalDateTime.now())
                        .user(entity)
                        .build()
        );
    }

    // ë³´ê³ ì„œ ëª©ë¡ ì¡°íšŒ
    public List<AiReportDTO> getAllReports(UserPrincipal user) {

        return aiReportRepository.findAllByUser_UserIdOrderByCreatedAtDesc(user.userId())
                .stream()
                .map(AiReportDTO::from)
                .toList();
    }

    public RawReportProjection getRawReport(Long reportId) {
        return aiReportRepository.findRawReportById(reportId)
                .orElseThrow(() -> new RuntimeException("ë³´ê³ ì„œ ì—†ìŒ"));
    }
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\service\EmbeddingService.java`

```java
package com.codehows.taelimbe.ai.service;

import com.codehows.taelimbe.ai.entity.Embed;
import com.codehows.taelimbe.ai.repository.EmbedRepository;
import com.codehows.taelimbe.langchain.embaddings.EmbeddingStoreManager;
import com.codehows.taelimbe.langchain.embaddings.TextSplitterStrategy;
import dev.langchain4j.data.embedding.Embedding;
import dev.langchain4j.data.segment.TextSegment;
import dev.langchain4j.model.embedding.EmbeddingModel;
import dev.langchain4j.model.output.Response;
import dev.langchain4j.store.embedding.EmbeddingStore;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.text.PDFTextStripper;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.task.TaskExecutor;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;

/**
 * í…ìŠ¤íŠ¸ ì„ë² ë”© ë° ë²¡í„° ì €ì¥ì†Œ ê´€ë¦¬ë¥¼ ë‹´ë‹¹í•˜ëŠ” ì„œë¹„ìŠ¤ì…ë‹ˆë‹¤.
 * `@Service` ì–´ë…¸í…Œì´ì…˜ì€ ì´ í´ë˜ìŠ¤ê°€ ë¹„ì¦ˆë‹ˆìŠ¤ ê³„ì¸µì˜ ì»´í¬ë„ŒíŠ¸ì„ì„ ë‚˜íƒ€ë‚´ë©°,
 * Spring ì»¨í…Œì´ë„ˆì— ì˜í•´ ê´€ë¦¬ë˜ëŠ” ë¹ˆìœ¼ë¡œ ë“±ë¡ë©ë‹ˆë‹¤.
 * `@RequiredArgsConstructor`ëŠ” Lombok ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ, final í•„ë“œì— ëŒ€í•œ ìƒì„±ìë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•˜ì—¬ ì˜ì¡´ì„± ì£¼ì…ì„ ìš©ì´í•˜ê²Œ í•©ë‹ˆë‹¤.
 * `@Slf4j`ëŠ” Lombok ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ, ë¡œê¹…ì„ ìœ„í•œ `log` ê°ì²´ë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class EmbeddingService {

    // í…ìŠ¤íŠ¸ë¥¼ ì„ë² ë”© ë²¡í„°ë¡œ ë³€í™˜í•˜ëŠ” ëª¨ë¸ì„ ì£¼ì…ë°›ìŠµë‹ˆë‹¤.
    private final EmbeddingModel embeddingModel;
    // ìƒì„±ëœ ì„ë² ë”© ë²¡í„°ë¥¼ ì €ì¥í•˜ê³  ê²€ìƒ‰í•˜ëŠ” ìŠ¤í† ì–´ë¥¼ ì£¼ì…ë°›ìŠµë‹ˆë‹¤.
    private final EmbeddingStore<TextSegment> embeddingStore;
    // ì„ë² ë”© ìŠ¤í† ì–´ì˜ ì´ˆê¸°í™” ë° ê´€ë¦¬ ê¸°ëŠ¥ì„ ì œê³µí•˜ëŠ” ë§¤ë‹ˆì €ë¥¼ ì£¼ì…ë°›ìŠµë‹ˆë‹¤.
    private final EmbeddingStoreManager embeddingStoreManager;
    // í…ìŠ¤íŠ¸ ë¶„í•  ì „ëµì„ ì£¼ì…ë°›ìŠµë‹ˆë‹¤.
    private final TextSplitterStrategy textSplitterStrategy;

    private final EmbedRepository embedRepository;

    // ë¹„ë™ê¸° ì‘ì—…ì„ ìœ„í•œ ìŠ¤ë ˆë“œ í’€ì„ ì£¼ì…ë°›ìŠµë‹ˆë‹¤.
    @Qualifier("taskExecutor")
    private final TaskExecutor taskExecutor;

    // ë³‘ë ¬ ì„ë² ë”© ëª¨ë¸ (CSV / PDF ì „ìš©)
    @Qualifier("parallelEmbeddingModel")
    private final EmbeddingModel parallelEmbeddingModel;

    // csv, pdf ì„ë² ë”© ê° ë°°ì¹˜ì‚¬ì´ì¦ˆ ê°’ ë°›ì•„ì˜¤ê¸°
    @Value("${embedding.csv.batch.size}")
    private int embeddingCsvBatchSize;
    @Value("${embedding.pdf.batch.size}")
    private int embeddingPdfBatchSize;

    // ì„ë² ë”© batch ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„ ì„¤ì •ê°’ ë°›ì•„ì˜¤ê¸°
    @Value("${embedding.retry.max-attempts}")
    private int maxRetryAttempts;
    @Value("${embedding.retry.initial-delay-ms}")
    private long initialRetryDelayMs;

    /**
     * ì£¼ì–´ì§„ í…ìŠ¤íŠ¸ë¥¼ ì„ë² ë”©í•˜ì—¬ ë²¡í„° ì €ì¥ì†Œì— ì¶”ê°€í•©ë‹ˆë‹¤.
     * ì´ ë©”ì„œë“œëŠ” RAG(Retrieval-Augmented Generation)ë¥¼ ìœ„í•œ ì§€ì‹ ê¸°ë°˜ì„ êµ¬ì¶•í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.
     * ì‘ì—…ì€ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì‹¤í–‰ë˜ì–´ í˜¸ì¶œ ìŠ¤ë ˆë“œë¥¼ ë¸”ë¡œí‚¹í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
     *
     * @param text ì„ë² ë”©í•˜ê³  ì €ì¥í•  í…ìŠ¤íŠ¸
     * @return ë¹„ë™ê¸° ì‘ì—…ì˜ ì™„ë£Œë¥¼ ë‚˜íƒ€ë‚´ëŠ” `CompletableFuture<Void>`
     */

    public CompletableFuture<Void> embedAndStore(String text) {
        return CompletableFuture.runAsync(() -> {
            log.info("í…ìŠ¤íŠ¸ ì„ë² ë”© ë° ì €ì¥ ì‹œì‘: '{}'", text);

            // 1. í…ìŠ¤íŠ¸ ë¶„í•  ì „ëµì„ ì‚¬ìš©í•˜ì—¬ í…ìŠ¤íŠ¸ë¥¼ ì‘ì€ `TextSegment`ë“¤ë¡œ ë¶„í• í•©ë‹ˆë‹¤.
            List<TextSegment> segments = textSplitterStrategy.split(text).stream().map(TextSegment::from).toList();

            // 2. `EmbeddingModel`ì„ ì‚¬ìš©í•˜ì—¬ ê° `TextSegment`ë¥¼ ì„ë² ë”© ë²¡í„°ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
            Response<List<Embedding>> embedding = embeddingModel.embedAll(segments);

            // 3. ì„ë² ë”©ëœ `TextSegment`ì™€ í•´ë‹¹ ì„ë² ë”© ë²¡í„°ë¥¼ `EmbeddingStore`ì— ì¶”ê°€í•©ë‹ˆë‹¤.
            embeddingStore.addAll(embedding.content(), segments);

            log.info("í…ìŠ¤íŠ¸ ì„ë² ë”© ë° ì €ì¥ ì™„ë£Œ.");
        }, taskExecutor); // ì§€ì •ëœ `taskExecutor` ìŠ¤ë ˆë“œ í’€ì—ì„œ ì‹¤í–‰
    }


    /**
     * ê¸°ì¡´ ë²¡í„° ì €ì¥ì†Œì˜ ëª¨ë“  ë°ì´í„°ë¥¼ ì‚­ì œí•˜ê³ , ì£¼ì–´ì§„ í…ìŠ¤íŠ¸ë¡œ ìƒˆë¡œ ì„ë² ë”©í•˜ì—¬ ì €ì¥í•©ë‹ˆë‹¤.
     * ì§€ì‹ ê¸°ë°˜ì„ ì™„ì „íˆ ì´ˆê¸°í™”í•˜ê³  ìƒˆë¡œìš´ ë°ì´í„°ë¡œ êµì²´í•  ë•Œ ì‚¬ìš©ë©ë‹ˆë‹¤.
     * ì‘ì—…ì€ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì‹¤í–‰ë˜ì–´ í˜¸ì¶œ ìŠ¤ë ˆë“œë¥¼ ë¸”ë¡œí‚¹í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
     *
     * @param text ìƒˆë¡œ ì„ë² ë”©í•˜ê³  ì €ì¥í•  í…ìŠ¤íŠ¸
     * @return ë¹„ë™ê¸° ì‘ì—…ì˜ ì™„ë£Œë¥¼ ë‚˜íƒ€ë‚´ëŠ” `CompletableFuture<Void>`
     */
    public CompletableFuture<Void> resetAndEmbed(String text) {
        return CompletableFuture.runAsync(() -> {
            log.info("ì„ë² ë”© ìŠ¤í† ì–´ ì¬ì„¤ì • ë° ìƒˆ í…ìŠ¤íŠ¸ ì„ë² ë”© ì‹œì‘.");

            // 1. `EmbeddingStoreManager`ë¥¼ ì‚¬ìš©í•˜ì—¬ Milvus ì»¬ë ‰ì…˜ì„ ì¬ì„¤ì •(ì‚­ì œ í›„ ì¬ìƒì„±)í•©ë‹ˆë‹¤.
            embeddingStoreManager.reset();

            // 2. ìƒˆë¡œìš´ í…ìŠ¤íŠ¸ë¡œ ì„ë² ë”© ë° ì €ì¥ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
            embedAndStore(text);

            log.info("ì„ë² ë”© ìŠ¤í† ì–´ ì¬ì„¤ì • ë° ìƒˆ í…ìŠ¤íŠ¸ ì„ë² ë”© ì™„ë£Œ.");
        }, taskExecutor); // ì§€ì •ëœ `taskExecutor` ìŠ¤ë ˆë“œ í’€ì—ì„œ ì‹¤í–‰
    }


    ///
    public CompletableFuture<Void> embedByValue(String text) {
        return CompletableFuture.runAsync(() -> {
            String savedKey = embeddingStoreManager.addDocuments(text);
            embedRepository.save(Embed.builder().embedKey(savedKey).embedValue(text).build());
        }, taskExecutor);
    }

    public CompletableFuture<Void> deleteByKey(String key) {
        return CompletableFuture.runAsync(() -> {
            embeddingStoreManager.deleteDocuments(key);
            embedRepository.deleteById(key);
        }, taskExecutor);
    }



    /**
     * CSV íŒŒì¼ì„ ë°›ì•„ íŒŒì‹±í•˜ê³  ë‚´ìš©ì„ ì„ë² ë”©í•˜ì—¬ ë²¡í„° ì €ì¥ì†Œì— ì¶”ê°€í•©ë‹ˆë‹¤.
     * @param file ì„ë² ë”©í•  ë°ì´í„°ê°€ í¬í•¨ëœ CSV íŒŒì¼
     * @return ë¹„ë™ê¸° ì‘ì—…ì˜ ì™„ë£Œë¥¼ ë‚˜íƒ€ë‚´ëŠ” `CompletableFuture<Void>`
     */
    public CompletableFuture<Void> embedAndStoreCsv(MultipartFile file) {
        return CompletableFuture.runAsync(() -> {

            log.info("CSV ë³‘ë ¬ ì„ë² ë”© ì‹œì‘ (batchSize={}): {}",
                    embeddingCsvBatchSize, file.getOriginalFilename());

            try (BOMInputStream bomIn = new BOMInputStream(file.getInputStream());
                 Reader reader = new InputStreamReader(bomIn, StandardCharsets.UTF_8)) {

                Iterable<CSVRecord> records = 
                        CSVFormat.DEFAULT.withFirstRecordAsHeader().parse(reader);

                List<TextSegment> buffer = new ArrayList<>(embeddingCsvBatchSize);

                for (CSVRecord record : records) {

                    String documentText = String.format(
                            "ì œëª©: %s\në‚´ìš©: %s",
                            record.get("column1"),
                            record.get("column2")
                    );

                    List<TextSegment> segments = 
                            textSplitterStrategy.split(documentText)
                                    .stream()
                                    .map(TextSegment::from)
                                    .toList();

                    for (TextSegment segment : segments) {
                        buffer.add(segment);

                        if (buffer.size() >= embeddingCsvBatchSize) {
                            flushBatch(buffer);
                        }
                    }
                }

                // ë‚¨ì€ batch ì²˜ë¦¬
                if (!buffer.isEmpty()) {
                    flushBatch(buffer);
                }

                log.info("CSV ë³‘ë ¬ ì„ë² ë”© ì™„ë£Œ");

            } catch (Exception e) {
                log.error("CSV ë³‘ë ¬ ì„ë² ë”© ì‹¤íŒ¨", e);
                throw new RuntimeException(e);
            }

        }, taskExecutor);
    }

    public CompletableFuture<Void> embedAndStorePdf(MultipartFile file) {
        return CompletableFuture.runAsync(() -> {

            log.info("PDF ë³‘ë ¬ ì„ë² ë”© ì‹œì‘ (batchSize={}): {}",
                    embeddingPdfBatchSize, file.getOriginalFilename());

            try (PDDocument document = PDDocument.load(file.getInputStream())) {

                PDFTextStripper stripper = new PDFTextStripper();
                String text = stripper.getText(document);

                List<TextSegment> segments = 
                        textSplitterStrategy.split(text)
                                .stream()
                                .map(TextSegment::from)
                                .toList();

                List<TextSegment> buffer = new ArrayList<>(embeddingPdfBatchSize);

                for (TextSegment segment : segments) {
                    buffer.add(segment);

                    if (buffer.size() >= embeddingPdfBatchSize) {
                        flushBatch(buffer);
                    }
                }

                if (!buffer.isEmpty()) {
                    flushBatch(buffer);
                }

                log.info("PDF ë³‘ë ¬ ì„ë² ë”© ì™„ë£Œ");

            } catch (Exception e) {
                log.error("PDF ì„ë² ë”© ì‹¤íŒ¨", e);
                throw new RuntimeException(e);
            }

        }, taskExecutor);
    }

    private void flushBatch(List<TextSegment> batch) {

        int attempt = 0;
        long delay = initialRetryDelayMs;

        while (true) {
            try {
                log.info("Embedding batch flush size={}, attempt={}", batch.size(), attempt + 1);

                Response<List<Embedding>> embeddings = 
                        parallelEmbeddingModel.embedAll(batch);

                embeddingStore.addAll(embeddings.content(), batch);
                batch.clear();
                return;

            } catch (Exception e) {
                attempt++;

                if (attempt >= maxRetryAttempts) {
                    log.error("âŒ Embedding batch failed after {} attempts. Skip batch.", attempt, e);
                    batch.clear();
                    return;
                }

                log.warn("âš  Embedding batch failed. Retry in {} ms (attempt {}/{})",
                        delay, attempt, maxRetryAttempts);

                try {
                    Thread.sleep(delay);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    batch.clear();
                    return;
                }

                delay *= 2; // exponential backoff
            }
        }
    }

}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\service\SseService.java`

```java
package com.codehows.taelimbe.ai.service;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.io.IOException;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Service
@Slf4j
public class SseService {

    // conversationId â†’ emitter
    private final Map<String, SseEmitter> emitters = new ConcurrentHashMap<>();

    // SSE ì—°ê²° ìƒì„± ì¤‘ë³µ ìƒì„± ë°©ì§€)
    public SseEmitter createEmitter(String conversationId) {
        return emitters.computeIfAbsent(conversationId, id -> {
            SseEmitter emitter = new SseEmitter(0L); // timeout ì—†ìŒ

            emitter.onCompletion(() -> {
                emitters.remove(id);
                log.debug("SSE completed: {}", id);
            });

            emitter.onTimeout(() -> {
                emitters.remove(id);
                log.warn("SSE timeout: {}", id);
            });

            emitter.onError(e -> {
                emitters.remove(id);
                log.warn("SSE error: {}", id, e);
            });

            return emitter;
        });
    }

    // í† í° ìŠ¤íŠ¸ë¦¬ë° ì „ì†¡ ( event name : message) */
    public void send(String conversationId, String data) {
        sendEvent(conversationId, "message", data);
    }

    // named event ì „ì†¡
    public void sendEvent(String conversationId, String event, Object data) {
        SseEmitter emitter = emitters.get(conversationId);
        if (emitter == null) {
            log.debug("SSE emitter not found. conversationId={}, event={}", conversationId, event);
            return;
        }

        try {
            emitter.send(
                    SseEmitter.event()
                            .name(event)
                            .data(data)
            );
        } catch (IOException e) {
            // ì—°ê²° ëŠê¹€ / ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ê°€ ëŒ€ë¶€ë¶„
            emitters.remove(conversationId);
            log.warn("SSE send failed (IO). conversationId={}, event={}", conversationId, event, e);
        } catch (IllegalStateException e) {
            // ì´ë¯¸ complete ëœ emitterì— send ì‹œë„í•  ë•Œ
            emitters.remove(conversationId);
            log.warn("SSE send failed (state). conversationId={}, event={}", conversationId, event, e);
        } catch (Exception e) {
            emitters.remove(conversationId);
            log.error("SSE send failed. conversationId={}, event={}", conversationId, event, e);
        }
    }

    // SSE ì •ìƒ ì¢…ë£Œ
    public void complete(String conversationId) {
        SseEmitter emitter = emitters.remove(conversationId);
        if (emitter != null) {
            try {
                emitter.complete();
            } catch (Exception ignored) {}
        }
    }

    // SSE ì—ëŸ¬ ì¢…ë£Œ
    public void completeWithError(String conversationId, Throwable error) {
        SseEmitter emitter = emitters.remove(conversationId);
        if (emitter != null) {
            try {
                emitter.completeWithError(error);
            } catch (Exception ignored) {}
        }
    }
}
```

# LangChain Package Files

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\langchain\Agent.java`

```java
package com.codehows.taelimbe.langchain;

import dev.langchain4j.service.*;
import dev.langchain4j.service.spring.AiService;

/**
 * LangChain4jì˜ AI ì„œë¹„ìŠ¤ë¥¼ ì •ì˜í•˜ëŠ” ì¸í„°í˜ì´ìŠ¤ì…ë‹ˆë‹¤.
 * ì´ ì¸í„°í˜ì´ìŠ¤ë¥¼ í†µí•´ AI ëª¨ë¸ê³¼ ìƒí˜¸ì‘ìš©í•˜ë©°, ëŒ€í™” ê¸°ë¡ ê´€ë¦¬, ì‹œìŠ¤í…œ ë©”ì‹œì§€ ì„¤ì •, ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ ë“±ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
 *
 * `@AiService` ì–´ë…¸í…Œì´ì…˜ì„ í†µí•´ LangChain4jê°€ ëŸ°íƒ€ì„ì— ì´ ì¸í„°í˜ì´ìŠ¤ì˜ êµ¬í˜„ì²´ë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.
 */
@AiService
public interface Agent {

    /**
     * AI ì—ì´ì „íŠ¸ì˜ ì‹œìŠ¤í…œ ë©”ì‹œì§€ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
     * ì´ ë©”ì‹œì§€ëŠ” AIì˜ ì—­í• , ì§€ì‹œì‚¬í•­, ì œì•½ ì¡°ê±´ ë“±ì„ ì„¤ì •í•˜ì—¬ AIì˜ í–‰ë™ì„ ì•ˆë‚´í•©ë‹ˆë‹¤.
     * ì—¬ê¸°ì„œëŠ” AIê°€ "ëŒ€í™”í•  ìˆ˜ ìˆê³  ë„êµ¬ë¥¼ ì‚¬ìš©í•˜ì—¬ ì§ˆë¬¸ì— ë‹µí•  ìˆ˜ ìˆëŠ” ìœ ìš©í•œ ì–´ì‹œìŠ¤í„´íŠ¸"ì„ì„ ëª…ì‹œí•©ë‹ˆë‹¤.
     */
    @SystemMessage("""
            ë‹¹ì‹ ì€ ëŒ€í™”í•  ìˆ˜ ìˆê³ , ë‹¤ì–‘í•œ ë„êµ¬ë¥¼ í™œìš©í•˜ì—¬ ì •í™•í•˜ê³  ìœ ìš©í•œ ë‹µë³€ì„ ì œê³µí•©ë‹ˆë‹¤.
            ì•„ë˜ ë‚´ìš© ì¤‘ì—ì„œ í™•ì‹¤í•œ ë‹µë³€ì´ ì—†ìœ¼ë©´, ë¶ˆí•„ìš”í•˜ê²Œ ì •ë³´ë¥¼ ëŠ˜ì–´ë†“ì§€ ë§ê³ 
            "ë‹µë³€ë“œë¦´ ìˆ˜ ì—†ëŠ” ì •ë³´ì…ë‹ˆë‹¤."ë¼ê³  ê°„ë‹¨íˆ ë§í•˜ì‹­ì‹œì˜¤.
            """)
    /**
     * ì‚¬ìš©ìì˜ ë©”ì‹œì§€ë¥¼ ë°›ì•„ ìŠ¤íŠ¸ë¦¬ë° ë°©ì‹ìœ¼ë¡œ AIì˜ ì‘ë‹µì„ ë°˜í™˜í•˜ëŠ” ë©”ì„œë“œì…ë‹ˆë‹¤.
     *
     * @param message ì‚¬ìš©ìì˜ ì…ë ¥ ë©”ì‹œì§€ì…ë‹ˆë‹¤. `@UserMessage` ì–´ë…¸í…Œì´ì…˜ì„ í†µí•´
     *                ì´ íŒŒë¼ë¯¸í„°ê°€ AIì—ê²Œ ì „ë‹¬ë  ì‚¬ìš©ì ë©”ì‹œì§€ì„ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
     * @param memoryId ê° ëŒ€í™”ë¥¼ ê³ ìœ í•˜ê²Œ ì‹ë³„í•˜ëŠ” IDì…ë‹ˆë‹¤. `@MemoryId` ì–´ë…¸í…Œì´ì…˜ì„ í†µí•´ LangChain4jê°€
     *                 ì´ IDë¥¼ ì‚¬ìš©í•˜ì—¬ í•´ë‹¹ ëŒ€í™”ì˜ ê¸°ë¡(ChatMemory)ì„ ê´€ë¦¬í•˜ë„ë¡ í•©ë‹ˆë‹¤.
     *                 ì´ë¥¼ í†µí•´ ë©€í‹°í„´ ëŒ€í™”ê°€ ê°€ëŠ¥í•´ì§‘ë‹ˆë‹¤.
     * @return AIì˜ ì‘ë‹µì„ ë‹´ì€ í† í° ìŠ¤íŠ¸ë¦¼(`TokenStream`)ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
     *         `TokenStream`ì„ ì‚¬ìš©í•˜ë©´ AIì˜ ì‘ë‹µì„ ì‹¤ì‹œê°„ìœ¼ë¡œ í† í° ë‹¨ìœ„ë¡œ ë°›ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
     */
    TokenStream chat(@UserMessage String message, @MemoryId Object memoryId);
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\langchain\config\EmbeddingModelConfig.java`

```java
package com.codehows.taelimbe.langchain.config;

import com.codehows.taelimbe.langchain.models.GeminiEmbeddingModel;
import com.codehows.taelimbe.langchain.models.GeminiParallelEmbeddingModel;
import com.google.genai.Client;
import dev.langchain4j.model.embedding.EmbeddingModel;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.beans.factory.annotation.Value;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

@Configuration
public class EmbeddingModelConfig {

    @Value("${gemini.model.embedding}")
    private String embeddingModelName;

    /**
     * ê¸°ë³¸ ì§ë ¬ ì„ë² ë”© (Chat / AI Report / RAG)
     */
    @Bean
    public EmbeddingModel embeddingModel(Client geminiClient) {
        return new GeminiEmbeddingModel(
                geminiClient,
                embeddingModelName
        );
    }

    /**
     * ë³‘ë ¬ ì„ë² ë”© ì „ìš© Executor
     */
    @Bean(name = "embeddingExecutor", destroyMethod = "shutdown")
    public ExecutorService embeddingExecutor() {
        return Executors.newFixedThreadPool(
                Runtime.getRuntime().availableProcessors() * 2
        );
    }

    /**
     * ë³‘ë ¬ ì„ë² ë”© (CSV / PDF ì „ìš©)
     */
    @Bean
    @Qualifier("parallelEmbeddingModel")
    public EmbeddingModel parallelEmbeddingModel(
            Client geminiClient,
            @Qualifier("embeddingExecutor") ExecutorService embeddingExecutor
    ) {
        return new GeminiParallelEmbeddingModel(
                geminiClient,
                embeddingModelName,
                embeddingExecutor
        );
    }
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\langchain\config\GeminiLLMFactory.java`

```java
package com.codehows.taelimbe.langchain.config;

import com.codehows.taelimbe.langchain.models.GeminiEmbeddingModel;
import com.codehows.taelimbe.langchain.models.GeminiStreamingChatModel;
import com.google.genai.Client;
import dev.langchain4j.model.chat.StreamingChatLanguageModel;
import dev.langchain4j.model.embedding.EmbeddingModel;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

/**
 * Google Gemini LLMì„ ìœ„í•œ `LLMFactory` êµ¬í˜„ì²´ì…ë‹ˆë‹¤.
 * ì´ íŒ©í† ë¦¬ëŠ” `com.google.genai.Client`ë¥¼ ì‚¬ìš©í•˜ì—¬ Gemini ìŠ¤íŠ¸ë¦¬ë° ì±„íŒ… ëª¨ë¸ê³¼ ì„ë² ë”© ëª¨ë¸ì„ ìƒì„±í•©ë‹ˆë‹¤.
 * `@Component` ì–´ë…¸í…Œì´ì…˜ì„ í†µí•´ Spring ì»¨í…Œì´ë„ˆì— ì˜í•´ ê´€ë¦¬ë˜ëŠ” ë¹ˆìœ¼ë¡œ ë“±ë¡ë©ë‹ˆë‹¤.
 * `@RequiredArgsConstructor`ëŠ” Lombok ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ, final í•„ë“œì— ëŒ€í•œ ìƒì„±ìë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•˜ì—¬ ì˜ì¡´ì„± ì£¼ì…ì„ ìš©ì´í•˜ê²Œ í•©ë‹ˆë‹¤.
 */
@Component
@RequiredArgsConstructor
public class GeminiLLMFactory implements LLMFactory {

    // `com.google.genai` í´ë¼ì´ì–¸íŠ¸ ì£¼ì…
    private final Client geminiClient;

    // application.propertiesì—ì„œ Gemini ì±„íŒ… ëª¨ë¸ ì´ë¦„ì„ ì£¼ì…ë°›ìŠµë‹ˆë‹¤.
    @Value("${gemini.model.chat}")
    private String chatModelName;

    // application.propertiesì—ì„œ Gemini ì„ë² ë”© ëª¨ë¸ ì´ë¦„ì„ ì£¼ì…ë°›ìŠµë‹ˆë‹¤.
    @Value("${gemini.model.embedding}")
    private String embeddingModelName;

    /**
     * Gemini ìŠ¤íŠ¸ë¦¬ë° ì±„íŒ… ëª¨ë¸ì„ ìƒì„±í•˜ì—¬ ë°˜í™˜í•©ë‹ˆë‹¤.
     * `GeminiStreamingChatModel`ì˜ ë¹Œë”ë¥¼ ì‚¬ìš©í•˜ì—¬ ëª¨ë¸ì„ êµ¬ì„±í•©ë‹ˆë‹¤.
     *
     * @return `GeminiStreamingChatModel` ì¸ìŠ¤í„´ìŠ¤
     */
    @Override
    public StreamingChatLanguageModel createStreamingChatModel() {
        return GeminiStreamingChatModel.builder()
                .geminiClient(geminiClient)
                .modelName(chatModelName)
                .build();
    }

    /**
     * Gemini ì„ë² ë”© ëª¨ë¸ì„ ìƒì„±í•˜ì—¬ ë°˜í™˜í•©ë‹ˆë‹¤.
     * `GeminiEmbeddingModel`ì˜ ìƒì„±ìë¥¼ ì‚¬ìš©í•˜ì—¬ ëª¨ë¸ì„ êµ¬ì„±í•©ë‹ˆë‹¤.
     *
     * @return `GeminiEmbeddingModel` ì¸ìŠ¤í„´ìŠ¤
     */
    @Override
    public EmbeddingModel createEmbeddingModel() {
        return new GeminiEmbeddingModel(geminiClient, embeddingModelName);
    }
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\langchain\config\LangChainConfig.java`

```java
package com.codehows.taelimbe.langchain.config;

import com.codehows.taelimbe.ai.agent.ReportAgent;
import com.codehows.taelimbe.langchain.converters.LocalDateTimeAdapter;
import com.codehows.taelimbe.langchain.tools.ReportTools;
import com.google.genai.Client;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import dev.langchain4j.data.segment.TextSegment;
import dev.langchain4j.memory.chat.ChatMemoryProvider;
import dev.langchain4j.memory.chat.MessageWindowChatMemory;
import dev.langchain4j.model.chat.ChatLanguageModel;
import dev.langchain4j.model.chat.StreamingChatLanguageModel;
import dev.langchain4j.model.embedding.EmbeddingModel;
import dev.langchain4j.rag.content.retriever.ContentRetriever;
import dev.langchain4j.rag.content.retriever.EmbeddingStoreContentRetriever;
import dev.langchain4j.service.AiServices;
import dev.langchain4j.store.embedding.EmbeddingStore;
import dev.langchain4j.store.embedding.milvus.MilvusEmbeddingStore;
import dev.langchain4j.store.memory.chat.InMemoryChatMemoryStore;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.time.LocalDateTime;

/**
 * LangChain4jì™€ ê´€ë ¨ëœ ëª¨ë“  Bean ì„¤ì •ì„ ë‹´ë‹¹í•˜ëŠ” í´ë˜ìŠ¤ì…ë‹ˆë‹¤.
 * AI ëª¨ë¸, ì„ë² ë”©, ë²¡í„° ì €ì¥ì†Œ, ëŒ€í™” ë©”ëª¨ë¦¬ ë“± AI ì„œë¹„ìŠ¤ì˜ í•µì‹¬ êµ¬ì„±ìš”ì†Œë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
 * `@Configuration` ì–´ë…¸í…Œì´ì…˜ì€ ì´ í´ë˜ìŠ¤ê°€ Springì˜ ì„¤ì • í´ë˜ìŠ¤ì„ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
 */
@Configuration
public class LangChainConfig {

    // Gemini API í‚¤. LLMFactoryì—ì„œ ì‚¬ìš©í•˜ê¸° ìœ„í•´ ë‚¨ê²¨ë‘¡ë‹ˆë‹¤.
    @Value("${gemini.api.key}")
    private String geminiApiKey;

    @Value("${langchain.chat.max-messages}")
    private Integer chatMaxMessages;

    // Milvus ë²¡í„° ì €ì¥ì†Œ ì„¤ì •ì„ ìœ„í•œ í”„ë¡œí¼í‹°
    @Value("${milvus.host}")
    private String milvusHost;

    @Value("${milvus.port}")
    private Integer milvusPort;

    @Value("${milvus.collection-name}")
    private String milvusCollectionName;

    @Value("${langchain.rag.max-results}")
    private Integer langChainRagMaxResults;

    @Value("${langchain.rag.min-score}")
    private Double langChainRagMinScore;

    @Value("${milvus.embedding.dimension}")
    private Integer embeddingDimension;

    /**
     * Gson ì¸ìŠ¤í„´ìŠ¤ë¥¼ Spring Beanìœ¼ë¡œ ë“±ë¡í•©ë‹ˆë‹¤.
     * `LocalDateTimeAdapter`ë¥¼ ë“±ë¡í•˜ì—¬ `LocalDateTime` ê°ì²´ë¥¼ ISO 8601 í˜•ì‹ìœ¼ë¡œ
     * ì§ë ¬í™”/ì—­ì§ë ¬í™”í•  ìˆ˜ ìˆë„ë¡ êµ¬ì„±í•©ë‹ˆë‹¤.
     *
     * @return êµ¬ì„±ëœ `Gson` ì¸ìŠ¤í„´ìŠ¤
     */
    @Bean
    public Gson gson() {
        return new GsonBuilder()
                .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter())
                .create();
    }

    /**
     * `com.google.genai` í´ë¼ì´ì–¸íŠ¸ë¥¼ Beanìœ¼ë¡œ ë“±ë¡í•©ë‹ˆë‹¤.
     * ì´ í´ë¼ì´ì–¸íŠ¸ëŠ” Gemini ëª¨ë¸ê³¼ì˜ ì§ì ‘ì ì¸ í†µì‹ ì„ ë‹´ë‹¹í•©ë‹ˆë‹¤
     * `@Bean` ì–´ë…¸í…Œì´ì…˜ì€ ì´ ë©”ì„œë“œê°€ ë°˜í™˜í•˜ëŠ” ê°ì²´ë¥¼ Spring ì»¨í…Œì´ë„ˆì˜ ë¹ˆìœ¼ë¡œ ë“±ë¡í•˜ë„ë¡ ì§€ì‹œí•©ë‹ˆë‹¤.
     *
     * @return `com.google.genai.Client` ì¸ìŠ¤í„´ìŠ¤
     */
    @Bean
    public Client geminiClient() {
        return Client.builder()
                .apiKey(geminiApiKey)
                .build();
    }

    /**
     * LLMFactory ì¸í„°í˜ì´ìŠ¤ì˜ êµ¬í˜„ì²´ë¥¼ Beanìœ¼ë¡œ ë“±ë¡í•©ë‹ˆë‹¤.
     * ì—¬ê¸°ì„œëŠ” GeminiLLMFactoryë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
     *
     * @param geminiClient `com.google.genai` í´ë¼ì´ì–¸íŠ¸ (ì´ì „ì— ì •ì˜ëœ ë¹ˆì„ ì£¼ì…ë°›ìŒ)
     * @return `LLMFactory` ì¸ìŠ¤í„´ìŠ¤
     */
    @Bean
    public LLMFactory llmFactory(Client geminiClient) {
        return new GeminiLLMFactory(geminiClient);
    }

    /**
     * ìŠ¤íŠ¸ë¦¬ë° ì±„íŒ… ì–¸ì–´ ëª¨ë¸ì„ Beanìœ¼ë¡œ ë“±ë¡í•©ë‹ˆë‹¤.
     * `LLMFactory`ë¥¼ í†µí•´ ëª¨ë¸ì„ ìƒì„±í•©ë‹ˆë‹¤.
     *
     * @param llmFactory LLMFactory (ì´ì „ì— ì •ì˜ëœ ë¹ˆì„ ì£¼ì…ë°›ìŒ)
     * @return `StreamingChatLanguageModel` ì¸ìŠ¤í„´ìŠ¤
     */
    @Bean
    public StreamingChatLanguageModel streamingChatLanguageModel(LLMFactory llmFactory) {
        return llmFactory.createStreamingChatModel();
    }

    /**
     * ì„ë² ë”© ëª¨ë¸ì„ Beanìœ¼ë¡œ ë“±ë¡í•©ë‹ˆë‹¤.
     * `LLMFactory`ë¥¼ í†µí•´ ëª¨ë¸ì„ ìƒì„±í•©ë‹ˆë‹¤.
     *
     * @param llmFactory LLMFactory (ì´ì „ì— ì •ì˜ëœ ë¹ˆì„ ì£¼ì…ë°›ìŒ)
     * @return `EmbeddingModel` ì¸ìŠ¤í„´ìŠ¤
     */
//    @Bean
//    public EmbeddingModel embeddingModel(LLMFactory llmFactory) {
//        return llmFactory.createEmbeddingModel();
//    }

    /**
     * Milvus ì„ë² ë”© ì €ì¥ì†Œë¥¼ Beanìœ¼ë¡œ ë“±ë¡í•©ë‹ˆë‹¤.
     * ì„ë² ë”©ëœ ë²¡í„° ë°ì´í„°ë¥¼ ì €ì¥í•˜ê³  ê²€ìƒ‰í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.
     *
     * @return `EmbeddingStore` ì¸ìŠ¤í„´ìŠ¤
     */
    @Bean
    public EmbeddingStore<TextSegment> embeddingStore() {
        return MilvusEmbeddingStore.builder()
                .host(milvusHost)
                .port(milvusPort)
                .collectionName(milvusCollectionName)
                .dimension(embeddingDimension) // Gemini ì„ë² ë”© ëª¨ë¸ì˜ ì°¨ì› ìˆ˜ (text-embedding-004 ê¸°ì¤€)
                .build();
    }

    /**
     * ì„ë² ë”© ì €ì¥ì†Œë¥¼ í™œìš©í•˜ëŠ” `ContentRetriever`ë¥¼ Beanìœ¼ë¡œ ë“±ë¡í•©ë‹ˆë‹¤.
     * RAG(Retrieval-Augmented Generation)ì˜ í•µì‹¬ ìš”ì†Œë¡œ, ì‚¬ìš©ì ì§ˆë¬¸ê³¼ ê´€ë ¨ëœ ë¬¸ì„œë¥¼ ë²¡í„° ì €ì¥ì†Œì—ì„œ ì°¾ì•„ AI ëª¨ë¸ì— ì œê³µí•©ë‹ˆë‹¤.
     *
     * @param embeddingStore ì„ë² ë”© ì €ì¥ì†Œ (ì´ì „ì— ì •ì˜ëœ ë¹ˆì„ ì£¼ì…ë°›ìŒ)
     * @param embeddingModel ì„ë² ë”© ëª¨ë¸ (ì´ì „ì— ì •ì˜ëœ ë¹ˆì„ ì£¼ì…ë°›ìŒ)
     * @return `ContentRetriever` ì¸ìŠ¤í„´ìŠ¤
     */
    @Bean
    public ContentRetriever contentRetriever(EmbeddingStore<TextSegment> embeddingStore, EmbeddingModel embeddingModel) {
        return EmbeddingStoreContentRetriever.builder()
                .embeddingStore(embeddingStore)
                .embeddingModel(embeddingModel)
                .maxResults(langChainRagMaxResults) // ìµœëŒ€ 5ê°œì˜ ê´€ë ¨ì„± ë†’ì€ ê²°ê³¼ë¥¼ ê²€ìƒ‰í•©ë‹ˆë‹¤.
                .minScore(langChainRagMinScore) // ìµœì†Œ ìœ ì‚¬ë„ ì ìˆ˜ê°€ 0.3 ì´ìƒì¸ ê²°ê³¼ë§Œ ë°˜í™˜í•©ë‹ˆë‹¤.
                .build();
    }

    /**
     * ëŒ€í™” ë©”ëª¨ë¦¬ ì œê³µì(`ChatMemoryProvider`)ë¥¼ Beanìœ¼ë¡œ ë“±ë¡í•©ë‹ˆë‹¤.
     * ì‚¬ìš©ìë³„ ëŒ€í™” ê¸°ë¡ì„ ê´€ë¦¬í•˜ì—¬ ë©€í‹°í„´ ëŒ€í™”ë¥¼ ê°€ëŠ¥í•˜ê²Œ í•©ë‹ˆë‹¤.
     * `MessageWindowChatMemory`ëŠ” ìµœê·¼ Nê°œì˜ ë©”ì‹œì§€ë¥¼ ê¸°ì–µí•˜ëŠ” ìœˆë„ìš° ê¸°ë°˜ ë©”ëª¨ë¦¬ì…ë‹ˆë‹¤.
     *
     * @return `ChatMemoryProvider` ì¸ìŠ¤í„´ìŠ¤
     */
    @Bean
    public ChatMemoryProvider chatMemoryProvider() {
        return memoryId -> MessageWindowChatMemory.builder()
                .id(memoryId) // ëŒ€í™” IDë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë©”ëª¨ë¦¬ë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤.
                .maxMessages(chatMaxMessages) // ìµœê·¼ 20ê°œì˜ ë©”ì‹œì§€ë¥¼ ê¸°ì–µí•©ë‹ˆë‹¤.
                .chatMemoryStore(new InMemoryChatMemoryStore()) // ë©”ëª¨ë¦¬ ì €ì¥ì„ ìœ„í•œ ì¸ë©”ëª¨ë¦¬ ìŠ¤í† ì–´ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
                .build();
    }

}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\langchain\config\LLMFactory.java`

```java
package com.codehows.taelimbe.langchain.config;

import dev.langchain4j.model.chat.StreamingChatLanguageModel;
import dev.langchain4j.model.embedding.EmbeddingModel;

/**
 * ë‹¤ì–‘í•œ LLM(Large Language Model) ì œê³µìë¡œë¶€í„° ìŠ¤íŠ¸ë¦¬ë° ì±„íŒ… ëª¨ë¸ê³¼ ì„ë² ë”© ëª¨ë¸ì„ ìƒì„±í•˜ê¸° ìœ„í•œ íŒ©í† ë¦¬ ì¸í„°í˜ì´ìŠ¤ì…ë‹ˆë‹¤.
 * ì´ ì¸í„°í˜ì´ìŠ¤ë¥¼ í†µí•´ íŠ¹ì • LLM êµ¬í˜„ì²´ì— ëŒ€í•œ ì˜ì¡´ì„±ì„ ì¤„ì´ê³ ,
 * ìƒˆë¡œìš´ LLM ì œê³µìë¥¼ ì‰½ê²Œ í†µí•©í•  ìˆ˜ ìˆë„ë¡ í™•ì¥ì„±ì„ ì œê³µí•©ë‹ˆë‹¤.
 */
public interface LLMFactory {

    /**
     * ìŠ¤íŠ¸ë¦¬ë° ì±„íŒ… ì–¸ì–´ ëª¨ë¸ì„ ìƒì„±í•˜ì—¬ ë°˜í™˜í•©ë‹ˆë‹¤.
     *
     * @return ìŠ¤íŠ¸ë¦¬ë° ì±„íŒ… ì–¸ì–´ ëª¨ë¸ì˜ ì¸ìŠ¤í„´ìŠ¤
     */
    StreamingChatLanguageModel createStreamingChatModel();

    /**
     * ì„ë² ë”© ëª¨ë¸ì„ ìƒì„±í•˜ì—¬ ë°˜í™˜í•©ë‹ˆë‹¤.
     *
     * @return ì„ë² ë”© ëª¨ë¸ì˜ ì¸ìŠ¤í„´ìŠ¤
     */
    EmbeddingModel createEmbeddingModel();
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\langchain\converters\JsonConverter.java`

```java
package com.codehows.taelimbe.langchain.converters;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonPrimitive;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * JSON ê°ì²´ì™€ Java ì»¬ë ‰ì…˜ ê°„ì˜ ë³€í™˜ì„ ë‹´ë‹¹í•˜ëŠ” ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤ì…ë‹ˆë‹¤.
 * Googleì˜ GSON ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ì—¬ JSON ì§ë ¬í™”/ì—­ì§ë ¬í™”ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤.
 */
public class JsonConverter {

    /**
     * GSON `JsonObject`ë¥¼ `Map<String, Object>`ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
     * JSON ê°ì²´ì˜ í‚¤-ê°’ ìŒì„ Java Mapìœ¼ë¡œ ë§¤í•‘í•©ë‹ˆë‹¤.
     *
     * @param jsonObject ë³€í™˜í•  `JsonObject`
     * @return ë³€í™˜ëœ `Map<String, Object>`
     */
    public static Map<String, Object> jsonToMap(JsonObject jsonObject) {
        Map<String, Object> map = new HashMap<>();
        // JsonObjectì˜ ëª¨ë“  ì—”íŠ¸ë¦¬ë¥¼ ìˆœíšŒí•˜ë©° Mapì— ì¶”ê°€í•©ë‹ˆë‹¤.
        for (Map.Entry<String, JsonElement> entry : jsonObject.entrySet()) {
            map.put(entry.getKey(), jsonElementToObject(entry.getValue()));
        }
        return map;
    }

    /**
     * GSON `JsonArray`ë¥¼ `List<Object>`ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
     * JSON ë°°ì—´ì˜ ìš”ì†Œë“¤ì„ Java Listë¡œ ë§¤í•‘í•©ë‹ˆë‹¤.
     *
     * @param jsonArray ë³€í™˜í•  `JsonArray`
     * @return ë³€í™˜ëœ `List<Object>`
     */
    public static List<Object> jsonToList(JsonArray jsonArray) {
        List<Object> list = new ArrayList<>();
        // JsonArrayì˜ ëª¨ë“  ìš”ì†Œë¥¼ ìˆœíšŒí•˜ë©° Listì— ì¶”ê°€í•©ë‹ˆë‹¤.
        for (JsonElement element : jsonArray) {
            list.add(jsonElementToObject(element));
        }
        return list;
    }

    /**
     * GSON `JsonElement`ë¥¼ ì ì ˆí•œ Java ê°ì²´(Map, List, Primitive íƒ€ì…)ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
     * ì´ ë©”ì„œë“œëŠ” ì¬ê·€ì ìœ¼ë¡œ í˜¸ì¶œë˜ì–´ ì¤‘ì²©ëœ JSON êµ¬ì¡°ë¥¼ ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
     *
     * @param jsonElement ë³€í™˜í•  `JsonElement`
     * @return ë³€í™˜ëœ Java ê°ì²´ (Map, List, Boolean, Number, String ë˜ëŠ” null)
     * @throws IllegalArgumentException ì§€ì›í•˜ì§€ ì•ŠëŠ” `JsonElement` íƒ€ì…ì¸ ê²½ìš° ë°œìƒ
     */
    private static Object jsonElementToObject(JsonElement jsonElement) {
        if (jsonElement.isJsonObject()) {
            // JsonObjectì¸ ê²½ìš° Mapìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
            return jsonToMap(jsonElement.getAsJsonObject());
        } else if (jsonElement.isJsonArray()) {
            // JsonArrayì¸ ê²½ìš° Listë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
            return jsonToList(jsonElement.getAsJsonArray());
        } else if (jsonElement.isJsonPrimitive()) {
            // JsonPrimitiveì¸ ê²½ìš° ê¸°ë³¸ íƒ€ì…(Boolean, Number, String)ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
            JsonPrimitive primitive = jsonElement.getAsJsonPrimitive();
            if (primitive.isBoolean()) {
                return primitive.getAsBoolean();
            } else if (primitive.isNumber()) {
                return primitive.getAsNumber();
            } else {
                return primitive.getAsString();
            }
        } else if (jsonElement.isJsonNull()) {
            // JsonNullì¸ ê²½ìš° nullì„ ë°˜í™˜í•©ë‹ˆë‹¤.
            return null;
        } else {
            // ê·¸ ì™¸ì˜ ì•Œ ìˆ˜ ì—†ëŠ” íƒ€ì…ì¸ ê²½ìš° ì˜ˆì™¸ë¥¼ ë°œìƒì‹œí‚µë‹ˆë‹¤.
            throw new IllegalArgumentException("Unsupported JsonElement type: " + jsonElement);
        }
    }
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\langchain\converters\LocalDateTimeAdapter.java`

```java
package com.codehows.taelimbe.langchain.converters;

import com.google.gson.*;

import java.lang.reflect.Type;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * `LocalDateTime` ê°ì²´ë¥¼ JSONìœ¼ë¡œ ì§ë ¬í™”í•˜ê±°ë‚˜ JSONì—ì„œ ì—­ì§ë ¬í™”í•˜ê¸° ìœ„í•œ GSON ì–´ëŒ‘í„° í´ë˜ìŠ¤ì…ë‹ˆë‹¤.
 * ISO 8601 í˜•ì‹(ì˜ˆ: "2024-01-01T12:30:00")ìœ¼ë¡œ ë³€í™˜ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
 */
public class LocalDateTimeAdapter implements JsonSerializer<LocalDateTime>, JsonDeserializer<LocalDateTime> {
    private static final DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;

    @Override
    public JsonElement serialize(LocalDateTime src, Type typeOfSrc, JsonSerializationContext context) {
        return new JsonPrimitive(src.format(formatter));
    }

    @Override
    public LocalDateTime deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {
        return LocalDateTime.parse(json.getAsString(), formatter);
    }
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\langchain\converters\MessageConverter.java`

```java
package com.codehows.taelimbe.langchain.converters;

import com.google.genai.types.Content;
import com.google.genai.types.Part;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import dev.langchain4j.data.message.*;
import lombok.extern.slf4j.Slf4j;

import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

/**
 * LangChain4jì˜ ChatMessageë¥¼ `com.google.genai`ì˜ Content ê°ì²´ë¡œ ë³€í™˜í•˜ëŠ” ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤ì…ë‹ˆë‹¤.
 */
@Slf4j
public class MessageConverter {
    /**
     * ChatMessage ë¦¬ìŠ¤íŠ¸ë¥¼ Content ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
     * @param messages LangChain4jì˜ ChatMessage ë¦¬ìŠ¤íŠ¸
     * @return `com.google.genai`ì˜ Content ë¦¬ìŠ¤íŠ¸
     */
    public static List<Content> toGoogleAiMessages(List<ChatMessage> messages) {
        return messages.stream()
                .map(MessageConverter::toGoogleAiMessage)
                .collect(Collectors.toList());
    }

    /**
     * ë‹¨ì¼ ChatMessageë¥¼ Content ê°ì²´ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
     * @param message LangChain4jì˜ ChatMessage
     * @return `com.google.genai`ì˜ Content ê°ì²´
     */
    private static Content toGoogleAiMessage(ChatMessage message) {
        String role = toGoogleAiRole(message);
        List<Part> parts = toGoogleAiParts(message);

        return Content.builder()
                .role(role)
                .parts(parts)
                .build();
    }

    /**
     * ChatMessageì˜ íƒ€ì…ì— ë”°ë¼ `com.google.genai`ì˜ ì—­í• (role)ì„ ê²°ì •í•©ë‹ˆë‹¤.
     * @param message LangChain4jì˜ ChatMessage
     * @return `com.google.genai`ì˜ ì—­í•  ë¬¸ìì—´ ("user" ë˜ëŠ” "model")
     */
    private static String toGoogleAiRole(ChatMessage message) {
        if (message instanceof UserMessage || message instanceof ToolExecutionResultMessage) {
            return "user";
        } else if (message instanceof AiMessage || message instanceof SystemMessage) {
            return "model";
        } else {
            throw new IllegalArgumentException("Unknown message type: " + message);
        }
    }

    /**
     * ChatMessageì˜ ë‚´ìš©ì„ `com.google.genai`ì˜ Part ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
     * @param message LangChain4jì˜ ChatMessage
     * @return `com.google.genai`ì˜ Part ë¦¬ìŠ¤íŠ¸
     */
    private static List<Part> toGoogleAiParts(ChatMessage message) {
        if (message instanceof UserMessage) {
            return Collections.singletonList(Part.fromText(((UserMessage) message).singleText()));
        }

        if (message instanceof SystemMessage) {
            // SystemMessageëŠ” UserMessageì²˜ëŸ¼ í…ìŠ¤íŠ¸ë¡œ ì²˜ë¦¬
            return Collections.singletonList(Part.fromText(((SystemMessage) message).text()));
        }

        if (message instanceof AiMessage aiMessage) {
            if (aiMessage.hasToolExecutionRequests()) {
                List<Part> parts = aiMessage.toolExecutionRequests().stream()
                        .map(toolExecutionRequest -> {
                            try {
                                String argumentsJson = toolExecutionRequest.arguments();
                                JsonObject jsonObject = JsonParser.parseString(argumentsJson).getAsJsonObject();
                                return Part.fromFunctionCall(
                                        toolExecutionRequest.name(),
                                        JsonConverter.jsonToMap(jsonObject));
                            } catch (Exception e) {
                                // ë¡œê·¸ ì¶œë ¥ ë° ê¸°ë³¸ fallback ì²˜ë¦¬
                                log.error("Invalid JSON in toolExecutionRequest arguments: {}", toolExecutionRequest.arguments(), e);
                                return Part.fromFunctionCall(toolExecutionRequest.name(), Collections.emptyMap());
                            }
                        })
                        .collect(Collectors.toList());
                // í…ìŠ¤íŠ¸ê°€ ìˆëŠ” ê²½ìš° í…ìŠ¤íŠ¸ íŒŒíŠ¸ë„ ì¶”ê°€
                if (aiMessage.text() != null && !aiMessage.text().isEmpty()) {
                    parts.addFirst(Part.fromText(aiMessage.text()));
                }
                return parts;
            } else {
                return Collections.singletonList(Part.fromText(aiMessage.text()));
            }
        }

        if (message instanceof ToolExecutionResultMessage toolExecutionResultMessage) {
            return Collections.singletonList(
                    Part.fromFunctionResponse(
                            toolExecutionResultMessage.toolName(),
                            Collections.singletonMap("content", toolExecutionResultMessage.text()))
            );
        }

        throw new IllegalArgumentException("Unknown message type: " + message);
    }
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\langchain\converters\ToolConverter.java`

```java
package com.codehows.taelimbe.langchain.converters;

import com.google.genai.types.FunctionDeclaration;
import com.google.genai.types.Schema;
import com.google.genai.types.Tool;
import dev.langchain4j.agent.tool.ToolParameters;
import dev.langchain4j.agent.tool.ToolSpecification;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * LangChain4jì˜ `ToolSpecification` ê°ì²´ë¥¼ `com.google.genai` ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ì‚¬ìš©í•˜ëŠ” `Tool` ê°ì²´ë¡œ ë³€í™˜í•˜ëŠ” ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤ì…ë‹ˆë‹¤.
 * Google Gemini APIëŠ” ëª¨ë¸ì´ í˜¸ì¶œí•  ìˆ˜ ìˆëŠ” ë„êµ¬ë“¤ì„ `FunctionDeclaration` í˜•íƒœë¡œ ì •ì˜í•˜ì—¬ ë°›ìŠµë‹ˆë‹¤.
 * ì´ ì»¨ë²„í„°ëŠ” LangChain4jì˜ ë„êµ¬ ëª…ì„¸ë¥¼ Geminiì˜ í•¨ìˆ˜ ì„ ì–¸ í˜•ì‹ì— ë§ê²Œ ë§¤í•‘í•©ë‹ˆë‹¤.
 */
public class ToolConverter {

    /**
     * LangChain4jì˜ `ToolSpecification` ë¦¬ìŠ¤íŠ¸ë¥¼ `com.google.genai`ì˜ `Tool` ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
     * Gemini APIëŠ” `Tool` ê°ì²´ ë‚´ì— `FunctionDeclaration` ë¦¬ìŠ¤íŠ¸ë¥¼ í¬í•¨í•˜ëŠ” êµ¬ì¡°ë¥¼ ê°€ì§‘ë‹ˆë‹¤.
     *
     * @param toolSpecifications ë³€í™˜í•  LangChain4j `ToolSpecification` ë¦¬ìŠ¤íŠ¸
     * @return ë³€í™˜ëœ `com.google.genai` `Tool` ë¦¬ìŠ¤íŠ¸. ë„êµ¬ ëª…ì„¸ê°€ ì—†ìœ¼ë©´ nullì„ ë°˜í™˜í•©ë‹ˆë‹¤.
     */
    public static List<Tool> toGoogleAiTools(List<ToolSpecification> toolSpecifications) {
        if (toolSpecifications == null || toolSpecifications.isEmpty()) {
            return List.of(); // ë„êµ¬ ëª…ì„¸ê°€ ì—†ìœ¼ë©´ nullì„ ë°˜í™˜í•˜ì—¬ API ìš”ì²­ì—ì„œ ë„êµ¬ í•„ë“œë¥¼ ìƒëµí•˜ë„ë¡ í•©ë‹ˆë‹¤.
        }
        return List.of(
                Tool.builder()
                        .functionDeclarations(toFunctionDeclarations(toolSpecifications)) // ë„êµ¬ ëª…ì„¸ë¥¼ í•¨ìˆ˜ ì„ ì–¸ìœ¼ë¡œ ë³€í™˜í•˜ì—¬ í¬í•¨
                        .build()
        );
    }

    /**
     * LangChain4jì˜ `ToolSpecification` ë¦¬ìŠ¤íŠ¸ë¥¼ `com.google.genai`ì˜ `FunctionDeclaration` ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
     *
     * @param toolSpecifications ë³€í™˜í•  LangChain4j `ToolSpecification` ë¦¬ìŠ¤íŠ¸
     * @return ë³€í™˜ëœ `com.google.genai` `FunctionDeclaration` ë¦¬ìŠ¤íŠ¸
     */
    private static List<FunctionDeclaration> toFunctionDeclarations(List<ToolSpecification> toolSpecifications) {
        return toolSpecifications.stream()
                .map(toolSpecification -> FunctionDeclaration.builder()
                        .name(toolSpecification.name()) // ë„êµ¬ì˜ ì´ë¦„ì„ ì„¤ì •í•©ë‹ˆë‹¤.
                        .description(toolSpecification.description()) // ë„êµ¬ì˜ ì„¤ëª…ì„ ì„¤ì •í•©ë‹ˆë‹¤.
                        .parameters(toSchema(toolSpecification.parameters())) // ë„êµ¬ì˜ íŒŒë¼ë¯¸í„° ìŠ¤í‚¤ë§ˆë¥¼ ë³€í™˜í•˜ì—¬ ì„¤ì •í•©ë‹ˆë‹¤.
                        .build())
                .collect(Collectors.toList());
    }

    /**
     * LangChain4jì˜ `ToolParameters` ê°ì²´ë¥¼ `com.google.genai`ì˜ `Schema` ê°ì²´ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
     * `ToolParameters`ëŠ” ë„êµ¬ì˜ ì…ë ¥ íŒŒë¼ë¯¸í„°ì— ëŒ€í•œ JSON ìŠ¤í‚¤ë§ˆ ì •ì˜ë¥¼ í¬í•¨í•©ë‹ˆë‹¤.
     *
     * @param toolParameters ë³€í™˜í•  LangChain4j `ToolParameters`
     * @return ë³€í™˜ëœ `com.google.genai` `Schema` ê°ì²´. íŒŒë¼ë¯¸í„°ê°€ ì—†ìœ¼ë©´ nullì„ ë°˜í™˜í•©ë‹ˆë‹¤.
     */
    private static Schema toSchema(ToolParameters toolParameters) {
        if (toolParameters == null) {
            return null; // íŒŒë¼ë¯¸í„°ê°€ ì—†ìœ¼ë©´ nullì„ ë°˜í™˜í•©ë‹ˆë‹¤.
        }

        // LangChain4jì˜ ToolParametersëŠ” Map<String, Object> í˜•íƒœì˜ JSON ìŠ¤í‚¤ë§ˆë¥¼ ê°€ì§‘ë‹ˆë‹¤.
        // ì´ë¥¼ Gemini APIì˜ Schema.Builderë¥¼ ì‚¬ìš©í•˜ì—¬ êµ¬ì„±í•©ë‹ˆë‹¤.
        Schema.Builder builder = Schema.builder();
        // ìŠ¤í‚¤ë§ˆì˜ 'type' í•„ë“œë¥¼ ì„¤ì •í•©ë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ "object"ì…ë‹ˆë‹¤.
        builder.type(toolParameters.type().toUpperCase());

        // ìŠ¤í‚¤ë§ˆì˜ 'properties' í•„ë“œë¥¼ ì„¤ì •í•©ë‹ˆë‹¤. ê° íŒŒë¼ë¯¸í„°ì˜ ì´ë¦„ê³¼ í•´ë‹¹ ìŠ¤í‚¤ë§ˆë¥¼ í¬í•¨í•©ë‹ˆë‹¤.
        if (toolParameters.properties() != null && !toolParameters.properties().isEmpty()) {
            Map<String, Schema> propertiesMap = new HashMap<>();
            for (Map.Entry<String, Map<String, Object>> entry : toolParameters.properties().entrySet()) {
                // ê° íŒŒë¼ë¯¸í„°ì˜ ìŠ¤í‚¤ë§ˆë¥¼ ì¬ê·€ì ìœ¼ë¡œ ë³€í™˜í•˜ì—¬ ì¶”ê°€í•©ë‹ˆë‹¤.
                propertiesMap.put(entry.getKey(), mapToSchema(entry.getValue()));
            }
            builder.properties(propertiesMap);
        }

        // ìŠ¤í‚¤ë§ˆì˜ 'required' í•„ë“œë¥¼ ì„¤ì •í•©ë‹ˆë‹¤. í•„ìˆ˜ íŒŒë¼ë¯¸í„° ëª©ë¡ì…ë‹ˆë‹¤.
        if (toolParameters.required() != null && !toolParameters.required().isEmpty()) {
            builder.required(((List<String>) toolParameters.required()));
        }
        
        return builder.build();
    }

    /**
     * Map í˜•íƒœì˜ JSON ìŠ¤í‚¤ë§ˆë¥¼ `com.google.genai`ì˜ `Schema` ê°ì²´ë¡œ ì¬ê·€ì ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
     * ì´ ë©”ì„œë“œëŠ” `toSchema(ToolParameters)`ì—ì„œ ì¤‘ì²©ëœ ìŠ¤í‚¤ë§ˆë¥¼ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ í˜¸ì¶œë©ë‹ˆë‹¤.
     *
     * @param map ìŠ¤í‚¤ë§ˆ ì •ë³´ë¥¼ ë‹´ê³  ìˆëŠ” Map
     * @return ë³€í™˜ëœ `com.google.genai` `Schema` ê°ì²´
     */
    @SuppressWarnings("unchecked") // Mapì˜ íƒ€ì… ìºìŠ¤íŒ…ì— ëŒ€í•œ ê²½ê³ ë¥¼ ì–µì œí•©ë‹ˆë‹¤.
    private static Schema mapToSchema(Map<String, Object> map) {
        Schema.Builder builder = Schema.builder();
        if (map.containsKey("type")) {
            builder.type(map.get("type").toString().toUpperCase());
        }
        if (map.containsKey("description")) {
            builder.description(map.get("description").toString());
        }
        if (map.containsKey("enum")) {
            builder.enum_(((List<String>) map.get("enum")));
        }
        if (map.containsKey("properties")) {
            Map<String, Schema> propertiesMap = new HashMap<>();
            Map<String, Map<String, Object>> properties = (Map<String, Map<String, Object>>) map.get("properties");
            for (Map.Entry<String, Map<String, Object>> entry : properties.entrySet()) {
                propertiesMap.put(entry.getKey(), mapToSchema(entry.getValue()));
            }
            builder.properties(propertiesMap);
        }
        if (map.containsKey("required")) {
            builder.required(((List<String>) map.get("required")));
        }
        if (map.containsKey("items")) {
            builder.items(mapToSchema((Map<String, Object>) map.get("items")));
        }
        return builder.build();
    }
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\langchain\embaddings\EmbeddingStoreManager.java`

```java
package com.codehows.taelimbe.langchain.embaddings;

import io.milvus.client.MilvusServiceClient;
import io.milvus.param.*;
import io.milvus.param.collection.CreateCollectionParam;
import io.milvus.param.collection.DropCollectionParam;
import io.milvus.param.collection.FieldType;
import io.milvus.param.collection.LoadCollectionParam;
import io.milvus.param.index.CreateIndexParam;
import io.milvus.param.*;

import io.milvus.param.collection.*;
import io.milvus.param.dml.DeleteParam;
import io.milvus.param.dml.InsertParam;
import io.milvus.param.dml.QueryParam;
import io.milvus.param.index.CreateIndexParam;
import io.milvus.response.QueryResultsWrapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.util.*;
import java.util.stream.Collectors;

import static io.milvus.grpc.DataType.*;

/**
 * Milvus ì„ë² ë”© ì €ì¥ì†Œì˜ ìƒëª…ì£¼ê¸°ë¥¼ ê´€ë¦¬í•˜ëŠ” ì»´í¬ë„ŒíŠ¸ì…ë‹ˆë‹¤.
 * ì´ í´ë˜ìŠ¤ëŠ” Milvus ì»¬ë ‰ì…˜ì˜ ìƒì„±, ì‚­ì œ, ì¸ë±ì‹±, ë¡œë”©ê³¼ ê°™ì€ ì‘ì—…ì„ ìˆ˜í–‰í•˜ë©°,
 * LangChain4jì˜ `EmbeddingStore` ì¸í„°í˜ì´ìŠ¤ì— ì§ì ‘ ë…¸ì¶œë˜ì§€ ì•Šì€ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.
 * `@Component` ì–´ë…¸í…Œì´ì…˜ì„ í†µí•´ Spring ì»¨í…Œì´ë„ˆì— ì˜í•´ ê´€ë¦¬ë˜ëŠ” ë¹ˆìœ¼ë¡œ ë“±ë¡ë©ë‹ˆë‹¤.
 * `@Slf4j`ëŠ” Lombok ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ, ë¡œê¹…ì„ ìœ„í•œ `log` ê°ì²´ë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.
 */
@Component
@Slf4j
@RequiredArgsConstructor
public class EmbeddingStoreManager {

    // application.propertiesì—ì„œ Milvus í˜¸ìŠ¤íŠ¸ë¥¼ ì£¼ì…ë°›ìŠµë‹ˆë‹¤.
    @Value("${milvus.host}")
    private String milvusHost;

    // application.propertiesì—ì„œ Milvus í¬íŠ¸ë¥¼ ì£¼ì…ë°›ìŠµë‹ˆë‹¤.
    @Value("${milvus.port}")
    private Integer milvusPort;

    // application.propertiesì—ì„œ Milvus ì»¬ë ‰ì…˜ ì´ë¦„ì„ ì£¼ì…ë°›ìŠµë‹ˆë‹¤.
    @Value("${milvus.collection-name}")
    private String milvusCollectionName;

    // application.propertiesì—ì„œ Milvus ì„ë² ë”© ëª¨ë¸ì˜ ì°¨ì› ìˆ˜ë¥¼ ì£¼ì…ë°›ìŠµë‹ˆë‹¤.
    @Value("${milvus.embedding.dimension}")
    private Integer embeddingDimension;

    private final EmbeddingStore<TextSegment> embeddingStore;
    private final EmbeddingModel embeddingModel;
    private final TextSplitterStrategy textSplitterStrategy;

    /**
     * Milvus ë²¡í„° ì €ì¥ì†Œë¥¼ ì¬ì„¤ì •(reset)í•©ë‹ˆë‹¤.
     * ì´ ë©”ì„œë“œëŠ” ë‹¤ìŒ ë‹¨ê³„ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤:
     * 1. Milvus í´ë¼ì´ì–¸íŠ¸ì— ì—°ê²°í•©ë‹ˆë‹¤.
     * 2. ê¸°ì¡´ ì»¬ë ‰ì…˜ì´ ìˆë‹¤ë©´ ì‚­ì œí•©ë‹ˆë‹¤.
     * 3. LangChain4jì˜ `MilvusEmbeddingStore`ê°€ ê¸°ëŒ€í•˜ëŠ” ìŠ¤í‚¤ë§ˆë¡œ ìƒˆë¡œìš´ ì»¬ë ‰ì…˜ì„ ìƒì„±í•©ë‹ˆë‹¤.
     *    - `id`: Primary Key, VarChar íƒ€ì… (UUID ì €ì¥ìš©)
     *    - `text`: ì›ë³¸ í…ìŠ¤íŠ¸, VarChar íƒ€ì…
     *    - `metadata`: ë©”íƒ€ë°ì´í„°, JSON íƒ€ì…
     *    - `vector`: ì„ë² ë”© ë²¡í„°, FloatVector íƒ€ì… (ì°¨ì›ì€ `embeddingDimension` ì‚¬ìš©)
     * 4. `vector` í•„ë“œì— ì¸ë±ìŠ¤ë¥¼ ìƒì„±í•˜ì—¬ íš¨ìœ¨ì ì¸ ë²¡í„° ê²€ìƒ‰ì„ ê°€ëŠ¥í•˜ê²Œ í•©ë‹ˆë‹¤.
     * 5. ì»¬ë ‰ì…˜ì„ ë¡œë“œí•˜ì—¬ ì¿¼ë¦¬ ì¤€ë¹„ë¥¼ ë§ˆì¹©ë‹ˆë‹¤.
     * 6. Milvus í´ë¼ì´ì–¸íŠ¸ ì—°ê²°ì„ ë‹«ìŠµë‹ˆë‹¤.
     *
     * @throws RuntimeException Milvus ì‘ì—… ì¤‘ ì˜ˆê¸°ì¹˜ ì•Šì€ ì˜¤ë¥˜ê°€ ë°œìƒí•  ê²½ìš°
     */
    public void reset() {
        log.info("Milvus ì»¬ë ‰ì…˜ ì¬ì„¤ì • ì‹œë„: '{}'", milvusCollectionName);
        // Milvus ì„œë¹„ìŠ¤ í´ë¼ì´ì–¸íŠ¸ì— ì—°ê²°í•©ë‹ˆë‹¤.
        MilvusServiceClient milvusClient = new MilvusServiceClient(
                ConnectParam.newBuilder()
                        .withHost(milvusHost)
                        .withPort(milvusPort)
                        .build()
        );

        try {
            log.debug("Milvusì— ì—°ê²°ë¨: {}:{}", milvusHost, milvusPort);

            // ê¸°ì¡´ ì»¬ë ‰ì…˜ì„ ì‚­ì œí•©ë‹ˆë‹¤. (ì»¬ë ‰ì…˜ì´ ì—†ì–´ë„ ì˜¤ë¥˜ ë°œìƒí•˜ì§€ ì•ŠìŒ)
            DropCollectionParam dropReq = DropCollectionParam.newBuilder()
                    .withCollectionName(milvusCollectionName)
                    .build();
            milvusClient.dropCollection(dropReq);
            log.info("ê¸°ì¡´ Milvus ì»¬ë ‰ì…˜ '{}' ì‚­ì œ ì™„ë£Œ (ì¡´ì¬í–ˆë‹¤ë©´).");

            // ìƒˆë¡œìš´ ì»¬ë ‰ì…˜ì„ ìƒì„±í•©ë‹ˆë‹¤.
            CreateCollectionParam collectionParam = CreateCollectionParam.newBuilder()
                    .withCollectionName(milvusCollectionName)
                    // 'id' í•„ë“œ: ê³ ìœ  ì‹ë³„ì, VarChar íƒ€ì…, Primary Key
                    .addFieldType(FieldType.newBuilder()
                            .withName("id")
                            .withDataType(VarChar)
                            .withMaxLength(36) // UUID ë¬¸ìì—´ ê¸¸ì´ì— ë§ì¶¤
                            .withPrimaryKey(true)
                            .withAutoID(false)
                            .build())
                    // 'text' í•„ë“œ: ì›ë³¸ í…ìŠ¤íŠ¸, VarChar íƒ€ì…
                    .addFieldType(FieldType.newBuilder()
                            .withName("text")
                            .withDataType(VarChar)
                            .withMaxLength(65535) // ê¸´ í…ìŠ¤íŠ¸ ì €ì¥ì„ ìœ„í•´ ìµœëŒ€ ê¸¸ì´ ì„¤ì •
                            .build())
                    // 'metadata' í•„ë“œ: ì¶”ê°€ ë©”íƒ€ë°ì´í„°, JSON íƒ€ì…
                    .addFieldType(FieldType.newBuilder()
                            .withName("metadata")
                            .withDataType(JSON)
                            .build())
                    // 'vector' í•„ë“œ: ì„ë² ë”© ë²¡í„°, FloatVector íƒ€ì…, ì°¨ì› ì„¤ì •
                    .addFieldType(FieldType.newBuilder()
                            .withName("vector")
                            .withDataType(FloatVector)
                            .withDimension(embeddingDimension) // ì£¼ì…ë°›ì€ ê°’ ì‚¬ìš©
                            .build())
                    .build();

            milvusClient.createCollection(collectionParam);
            log.info("ìƒˆë¡œìš´ Milvus ì»¬ë ‰ì…˜ '{}' ìƒì„± ì™„ë£Œ.");

            // 'vector' í•„ë“œì— ì¸ë±ìŠ¤ë¥¼ ìƒì„±í•©ë‹ˆë‹¤. (COSINE ìœ ì‚¬ë„ ì¸¡ì •, FLAT ì¸ë±ìŠ¤ íƒ€ì…)
            CreateIndexParam indexParam = CreateIndexParam.newBuilder()
                    .withCollectionName(milvusCollectionName)
                    .withFieldName("vector")
                    .withIndexType(IndexType.FLAT) // ê°„ë‹¨í•œ FLAT ì¸ë±ìŠ¤ (ëŒ€ê·œëª¨ ë°ì´í„°ì…‹ì—ì„œëŠ” IVF_FLAT ë“± ê³ ë ¤)
                    .withMetricType(MetricType.COSINE) // ì½”ì‚¬ì¸ ìœ ì‚¬ë„ ì¸¡ì •
                    .build();

            milvusClient.createIndex(indexParam);
            log.info("Milvus ì»¬ë ‰ì…˜ '{}'ì— ì¸ë±ìŠ¤ ìƒì„± ì™„ë£Œ.");

            // ì»¬ë ‰ì…˜ì„ ë¡œë“œí•˜ì—¬ ì¿¼ë¦¬ ì¤€ë¹„ë¥¼ ë§ˆì¹©ë‹ˆë‹¤.
            LoadCollectionParam request = LoadCollectionParam.newBuilder()
                    .withCollectionName(milvusCollectionName)
                    .build();
            milvusClient.loadCollection(request);
            log.info("Milvus ì»¬ë ‰ì…˜ '{}' ë¡œë“œ ì™„ë£Œ.");
            log.info("Milvus ì»¬ë ‰ì…˜ '{}' ì¬ì„¤ì • í”„ë¡œì„¸ìŠ¤ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œ.");

        } catch (Exception e) {
            log.error("Milvus ì»¬ë ‰ì…˜ '{}' ì¬ì„¤ì • ì¤‘ ì˜ˆê¸°ì¹˜ ì•Šì€ ì˜¤ë¥˜ ë°œìƒ: {}", milvusCollectionName, e.getMessage(), e);
            throw new RuntimeException("Milvus ì»¬ë ‰ì…˜ ì¬ì„¤ì • ì‹¤íŒ¨: " + milvusCollectionName, e);
        }
        finally {
            // Milvus í´ë¼ì´ì–¸íŠ¸ ì—°ê²°ì„ ë‹«ìŠµë‹ˆë‹¤.
            milvusClient.close();
        }
    }

    /**
     * ë°ì´í„°ë¥¼ ì €ì¥, ì²­í‚¹, ì„ë² ë”©í•˜ì—¬ Milvusì— ì¶”ê°€í•©ë‹ˆë‹¤.
     * 1. ì›ë³¸ ë°ì´í„°ë¥¼ RDBì— ì €ì¥í•©ë‹ˆë‹¤.
     * 2. ë°ì´í„°ë¥¼ í…ìŠ¤íŠ¸ ì²­í¬ë¡œ ë¶„í• í•©ë‹ˆë‹¤.
     * 3. ê° ì²­í¬ë¥¼ ì„ë² ë”©í•˜ê³ , ë©”íƒ€ë°ì´í„°ì™€ í•¨ê»˜ Milvusì— ì €ì¥í•©ë‹ˆë‹¤.
     *
     * @param data ì €ì¥í•  í…ìŠ¤íŠ¸ ë°ì´í„°
     * @return RDBì— ì €ì¥ëœ ë°ì´í„°ì˜ ê³ ìœ  í‚¤ (ID)
     */
    public String addDocuments(String data) {
        String key = UUID.randomUUID().toString();

        List<TextSegment> chunks = textSplitterStrategy.split(data).stream().map(TextSegment::from).toList();

        MilvusServiceClient milvusClient = new MilvusServiceClient(
                ConnectParam.newBuilder()
                        .withHost(milvusHost)
                        .withPort(milvusPort)
                        .build()
        );

        List<String> ids = new ArrayList<>();
        List<String> texts = new ArrayList<>();
        List<JSONObject> metadatas = new ArrayList<>();
        List<List<Float>> vectors = new ArrayList<>();

        for (int i = 0; i < chunks.size(); i++) {
            TextSegment chunk = chunks.get(i);
            int chunkId = i + 1;

            Response<Embedding> embedding = embeddingModel.embed(chunk);
            List<Float> vector = embedding.content().vectorAsList();

            // 4. ë©”íƒ€ë°ì´í„° ìƒì„±
            JSONObject metadata = new JSONObject();
            metadata.put("key", key);
            metadata.put("chunk_id", chunkId);

            ids.add(UUID.randomUUID().toString());
            texts.add(chunk.text());
            metadatas.add(metadata);
            vectors.add(vector);
        }

        try {
            // 5. Milvusì— ë°ì´í„° ì‚½ì…
            List<InsertParam.Field> fields = new ArrayList<>();
            fields.add(new InsertParam.Field("id", ids));
            fields.add(new InsertParam.Field("text", texts));
            fields.add(new InsertParam.Field("metadata", metadatas));
            fields.add(new InsertParam.Field("vector", vectors));

            InsertParam insertParam = InsertParam.newBuilder()
                    .withCollectionName(milvusCollectionName)
                    .withFields(fields)
                    .build();

            milvusClient.insert(insertParam);
            milvusClient.flush(FlushParam.newBuilder().withCollectionNames(Collections.singletonList(milvusCollectionName)).build());
            log.info("Milvusì— {}ê°œì˜ ì„ë² ë”© ë²¡í„°ë¥¼ ì„±ê³µì ìœ¼ë¡œ ì‚½ì…í–ˆìŠµë‹ˆë‹¤.", vectors.size());

        } catch (Exception e) {
            log.error("Milvusì— ë°ì´í„° ì‚½ì… ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {}", e.getMessage(), e);
            throw new RuntimeException("Milvus ë°ì´í„° ì‚½ì… ì‹¤íŒ¨", e);
        } finally {
            milvusClient.close();
        }

        return key;
    }


    /**
     * íŠ¹ì • í‚¤ì— í•´ë‹¹í•˜ëŠ” ë²¡í„° ë°ì´í„°ë¥¼ Milvusì™€ RDBì—ì„œ ì‚­ì œí•©ë‹ˆë‹¤.
     *
     * @param key    ì‚­ì œí•  ë°ì´í„°ì˜ ê³ ìœ  í‚¤ (RDBì˜ ID)
     */
    public void deleteDocuments(String key) {
        MilvusServiceClient milvusClient = new MilvusServiceClient(
                ConnectParam.newBuilder()
                        .withHost(milvusHost)
                        .withPort(milvusPort)
                        .build()
        );

        try {
            // 1. Milvusì—ì„œ ë°ì´í„° ì‚­ì œ
            // 1. Queryë¡œ ID ì¡°íšŒ
            String queryExpr = "metadata[\"key\"] == \"%s\"".formatted(key);

            QueryParam queryParam = QueryParam.newBuilder()
                    .withCollectionName(milvusCollectionName)
                    .withExpr(queryExpr)
                    .withOutFields(Arrays.asList("id"))
                    .build();

            R<QueryResults> queryResponse = milvusClient.query(queryParam);

            if (queryResponse.getStatus() != R.Status.Success.getCode()) {
                log.error("Query failed: {}", queryResponse.getMessage());
                return;
            }

            // 2. ID ì¶”ì¶œ (String íƒ€ì…)
            QueryResultsWrapper wrapper = new QueryResultsWrapper(queryResponse.getData());
            List<String> ids = (List<String>) wrapper.getFieldWrapper("id").getFieldData();

            if (ids.isEmpty()) {
                log.info("No documents found with key: {}", key);
                return;
            }

            // 3. ì‚­ì œ ì‹¤í–‰ - ë¬¸ìì—´ IDëŠ” ë”°ì˜´í‘œë¡œ ê°ì‹¸ê¸°
            String deleteExpr = "id in [%s]".formatted(
                    ids.stream()
                            .map("\"%s\""::formatted)  // ê° IDë¥¼ ë”°ì˜´í‘œë¡œ ê°ì‹¸ê¸°
                            .collect(Collectors.joining(", ")));

            DeleteParam deleteParam = DeleteParam.newBuilder()
                    .withCollectionName(milvusCollectionName)
                    .withExpr(deleteExpr)
                    .build();

            R<MutationResult> deleteResponse = milvusClient.delete(deleteParam);

            if (deleteResponse.getStatus() == R.Status.Success.getCode()) {
                log.info("Successfully deleted {} documents with key: {}", ids.size(), key);
            } else {
                log.error("Delete failed: {}", deleteResponse.getMessage());
            }

            milvusClient.flush(FlushParam.newBuilder().withCollectionNames(Collections.singletonList(milvusCollectionName)).build());
            log.info("Milvusì—ì„œ í‚¤ '{}'ì— í•´ë‹¹í•˜ëŠ” ë°ì´í„° ì‚­ì œ ì™„ë£Œ.", key);

        } catch (Exception e) {
            log.error("Milvusì—ì„œ ë°ì´í„° ì‚­ì œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {}", e.getMessage(), e);
            throw new RuntimeException("Milvus ë°ì´í„° ì‚­ì œ ì‹¤íŒ¨. í‚¤: " + key, e);
        } finally {
            milvusClient.close();
        }
    }
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\langchain\embaddings\SentenceTextSplitterStrategy.java`

```java
package com.codehows.taelimbe.langchain.embaddings;

import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;

/**
 * í…ìŠ¤íŠ¸ë¥¼ ë¬¸ì¥ ë‹¨ìœ„ë¡œ ë¶„í• í•˜ê³ , ê° ì„¸ê·¸ë¨¼íŠ¸ê°€ ìµœëŒ€ í† í° ìˆ˜ë¥¼ ë„˜ì§€ ì•Šë„ë¡ ì¡°ì •í•˜ëŠ” ì „ëµ êµ¬í˜„ì²´ì…ë‹ˆë‹¤.
 * ì´ êµ¬í˜„ì²´ëŠ” ê°„ë‹¨í•œ ë¬¸ì¥ ë¶„í•  ê·œì¹™ê³¼ `StringTokenizer`ë¥¼ ì‚¬ìš©í•œ ëŒ€ëµì ì¸ í† í° ê³„ì‚°ì„ ê¸°ë°˜ìœ¼ë¡œ í•©ë‹ˆë‹¤.
 */
@Component
@RequiredArgsConstructor
public class SentenceTextSplitterStrategy implements TextSplitterStrategy {

    @Value("${maxTokensPerSegment}")
    private int maxTokensPerSegment=250;

    /**
     * ì£¼ì–´ì§„ í…ìŠ¤íŠ¸ë¥¼ ë¬¸ì¥ ë‹¨ìœ„ë¡œ ë¶„í• í•˜ê³ , ê° ì„¸ê·¸ë¨¼íŠ¸ê°€ ìµœëŒ€ í† í° ìˆ˜ë¥¼ ë„˜ì§€ ì•Šë„ë¡ ì¡°ì •í•©ë‹ˆë‹¤.
     *
     * @param text ë¶„í• í•  ì›ë³¸ í…ìŠ¤íŠ¸
     * @return ë¶„í• ëœ í…ìŠ¤íŠ¸ ì„¸ê·¸ë¨¼íŠ¸ë“¤ì˜ ë¦¬ìŠ¤íŠ¸
     */
    @Override
    public List<String> split(String text) {
        List<String> segments = new ArrayList<>();

        // ëŒ€ëµ ë¬¸ì¥ ë‹¨ìœ„ë¡œ ë¶„í•  ('.', '?' ë“± ê¸°ì¤€). ì‹¤ì œ í”„ë¡œë•ì…˜ í™˜ê²½ì—ì„œëŠ” ë” ì •êµí•œ ë¬¸ì¥ ë¶„ë¦¬ê¸°ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.
        String[] sentences = text.split("(?<=[.!?])\\s+");

        StringBuilder currentSegment = new StringBuilder();
        int currentTokenCount = 0;

        for (String sentence : sentences) {
            int sentenceTokenCount = countTokens(sentence);

            // í˜„ì¬ ì„¸ê·¸ë¨¼íŠ¸ì— ë¬¸ì¥ì„ ì¶”ê°€í–ˆì„ ë•Œ ìµœëŒ€ í† í° ìˆ˜ë¥¼ ì´ˆê³¼í•˜ëŠ” ê²½ìš°
            if (currentTokenCount + sentenceTokenCount > maxTokensPerSegment) {
                if (!currentSegment.isEmpty()) {
                    // í˜„ì¬ê¹Œì§€ì˜ ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€í•˜ê³  ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
                    segments.add(currentSegment.toString().trim());
                    currentSegment.setLength(0);
                    currentTokenCount = 0;
                }
            }

            // ë¬¸ì¥ì„ í˜„ì¬ ì„¸ê·¸ë¨¼íŠ¸ì— ì¶”ê°€í•˜ê³  í† í° ìˆ˜ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
            currentSegment.append(sentence).append(" ");
            currentTokenCount += sentenceTokenCount;
        }

        // ë£¨í”„ ì¢…ë£Œ í›„ ë§ˆì§€ë§‰ ì„¸ê·¸ë¨¼íŠ¸ê°€ ë‚¨ì•„ìˆë‹¤ë©´ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€í•©ë‹ˆë‹¤.
        if (!currentSegment.isEmpty()) {
            segments.add(currentSegment.toString().trim());
        }

        return segments;
    }

    /**
     * ì£¼ì–´ì§„ í…ìŠ¤íŠ¸ì˜ í† í° ìˆ˜ë¥¼ ëŒ€ëµì ìœ¼ë¡œ ì¶”ì •í•©ë‹ˆë‹¤.
     * ì—¬ê¸°ì„œëŠ” ê³µë°±ì„ ê¸°ì¤€ìœ¼ë¡œ ë‹¨ì–´ ìˆ˜ë¥¼ ì„¸ëŠ” ë°©ì‹ìœ¼ë¡œ êµ¬í˜„ë˜ì—ˆìŠµë‹ˆë‹¤.
     * ì‹¤ì œ LLMì˜ í† í°í™” ë°©ì‹ê³¼ëŠ” ë‹¤ë¥¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ, ì •í™•í•œ í† í° ê³„ì‚°ì´ í•„ìš”í•˜ë‹¤ë©´
     * í•´ë‹¹ LLMì˜ í† í°í™” ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.
     *
     * @param text í† í° ìˆ˜ë¥¼ ì¶”ì •í•  í…ìŠ¤íŠ¸
     * @return í…ìŠ¤íŠ¸ì˜ ëŒ€ëµì ì¸ í† í° ìˆ˜
     */
    private int countTokens(String text) {
        StringTokenizer tokenizer = new StringTokenizer(text);
        return tokenizer.countTokens();
    }
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\langchain\embaddings\TextSplitterStrategy.java`

```java
package com.codehows.taelimbe.langchain.embaddings;

import java.util.List;

/**
 * í…ìŠ¤íŠ¸ë¥¼ ì‘ì€ ì„¸ê·¸ë¨¼íŠ¸(ì¡°ê°)ë¡œ ë¶„í• í•˜ëŠ” ì „ëµì„ ì •ì˜í•˜ëŠ” ì¸í„°í˜ì´ìŠ¤ì…ë‹ˆë‹¤.
 * ì´ ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•˜ì—¬ ë‹¤ì–‘í•œ í…ìŠ¤íŠ¸ ë¶„í•  ë°©ì‹ì„ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 * ì˜ˆë¥¼ ë“¤ì–´, ë¬¸ì¥ ë‹¨ìœ„ ë¶„í• , í† í° ìˆ˜ ê¸°ë°˜ ë¶„í•  ë“±ì´ ìˆìŠµë‹ˆë‹¤.
 */
public interface TextSplitterStrategy {

    /**
     * ì£¼ì–´ì§„ í…ìŠ¤íŠ¸ë¥¼ ì •ì˜ëœ ì „ëµì— ë”°ë¼ ì—¬ëŸ¬ ê°œì˜ í…ìŠ¤íŠ¸ ì„¸ê·¸ë¨¼íŠ¸ë¡œ ë¶„í• í•©ë‹ˆë‹¤.
     *
     * @param text ë¶„í• í•  ì›ë³¸ í…ìŠ¤íŠ¸
     * @return ë¶„í• ëœ í…ìŠ¤íŠ¸ ì„¸ê·¸ë¨¼íŠ¸ë“¤ì˜ ë¦¬ìŠ¤íŠ¸
     */
    List<String> split(String text);
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\langchain\models\GeminiEmbeddingModel.java`

```java
package com.codehows.taelimbe.langchain.models;

import com.google.genai.Client;
import com.google.genai.types.EmbedContentConfig;
import com.google.genai.types.EmbedContentResponse;
import dev.langchain4j.data.embedding.Embedding;
import dev.langchain4j.data.segment.TextSegment;
import dev.langchain4j.model.embedding.EmbeddingModel;
import dev.langchain4j.model.output.Response;
import lombok.RequiredArgsConstructor;

import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

/**
 * LangChain4jì˜ `EmbeddingModel` ì¸í„°í˜ì´ìŠ¤ë¥¼ `com.google.genai` í´ë¼ì´ì–¸íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ êµ¬í˜„í•œ ì»¤ìŠ¤í…€ í´ë˜ìŠ¤ì…ë‹ˆë‹¤.
 * ì´ í´ë˜ìŠ¤ëŠ” LangChain4j í”„ë ˆì„ì›Œí¬ê°€ Googleì˜ ì œë„¤ë¦­ Gemini í´ë¼ì´ì–¸íŠ¸ë¥¼ í†µí•´ ì„ë² ë”©ì„ ìƒì„±í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ì–´ëŒ‘í„° ì—­í• ì„ í•©ë‹ˆë‹¤.
 * `@RequiredArgsConstructor`ëŠ” Lombok ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ, final í•„ë“œì— ëŒ€í•œ ìƒì„±ìë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•˜ì—¬ ì˜ì¡´ì„± ì£¼ì…ì„ ìš©ì´í•˜ê²Œ í•©ë‹ˆë‹¤.
 */
@RequiredArgsConstructor
public class GeminiEmbeddingModel implements EmbeddingModel {

    // Google Gemini API í´ë¼ì´ì–¸íŠ¸ ì£¼ì…
    private final Client geminiClient;
    // ì‚¬ìš©í•  Gemini ì„ë² ë”© ëª¨ë¸ì˜ ì´ë¦„
    private final String modelName;

    /**
     * ë‹¨ì¼ í…ìŠ¤íŠ¸ ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ì„ë² ë”©í•©ë‹ˆë‹¤.
     * ì´ ë©”ì„œë“œëŠ” ë‚´ë¶€ì ìœ¼ë¡œ `embedAll` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ì—¬ ë‹¨ì¼ í•­ëª© ë¦¬ìŠ¤íŠ¸ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.
     *
     * @param textSegment ì„ë² ë”©í•  í…ìŠ¤íŠ¸ ì„¸ê·¸ë¨¼íŠ¸
     * @return ì„ë² ë”© ê²°ê³¼ë¥¼ í¬í•¨í•˜ëŠ” `Response` ê°ì²´
     */
    @Override
    public Response<Embedding> embed(TextSegment textSegment) {
        // `embedAll`ì„ ì‚¬ìš©í•˜ì—¬ ë‹¨ì¼ ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ì„ë² ë”©í•˜ê³ , ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ì˜ ì²« ë²ˆì§¸ ì„ë² ë”©ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
        return Response.from(embedAll(Collections.singletonList(textSegment)).content().getFirst());
    }

    /**
     * ì—¬ëŸ¬ í…ìŠ¤íŠ¸ ì„¸ê·¸ë¨¼íŠ¸ë¥¼ í•œ ë²ˆì— ì„ë² ë”©í•©ë‹ˆë‹¤.
     * `com.google.genai` ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” í˜„ì¬ ë°°ì¹˜ ì„ë² ë”©ì„ ì§ì ‘ ì§€ì›í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ,
     * ê° í…ìŠ¤íŠ¸ë¥¼ ìˆœì°¨ì ìœ¼ë¡œ ì„ë² ë”© ìš”ì²­ì„ ë³´ëƒ…ë‹ˆë‹¤.
     *
     * @param textSegments ì„ë² ë”©í•  í…ìŠ¤íŠ¸ ì„¸ê·¸ë¨¼íŠ¸ ë¦¬ìŠ¤íŠ¸
     * @return ì„ë² ë”© ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ë¥¼ í¬í•¨í•˜ëŠ” `Response` ê°ì²´
     * @throws RuntimeException ì„ë² ë”© ìƒì„± ì¤‘ ì˜¤ë¥˜ ë°œìƒ ì‹œ
     */
    @Override
    public Response<List<Embedding>> embedAll(List<TextSegment> textSegments) {
        // í…ìŠ¤íŠ¸ ì„¸ê·¸ë¨¼íŠ¸ ë¦¬ìŠ¤íŠ¸ì—ì„œ í…ìŠ¤íŠ¸ë§Œ ì¶”ì¶œí•©ë‹ˆë‹¤.
        List<String> texts = textSegments.stream()
                .map(TextSegment::text)
                .toList();

        // ê° í…ìŠ¤íŠ¸ì— ëŒ€í•´ Gemini APIë¥¼ í˜¸ì¶œí•˜ì—¬ ì„ë² ë”©ì„ ìƒì„±í•©ë‹ˆë‹¤.
        List<Embedding> embeddings = texts.stream()
                .map(text -> {
                    try {
                        // `geminiClient.models.embedContent`ë¥¼ í˜¸ì¶œí•˜ì—¬ ì„ë² ë”©ì„ ìš”ì²­í•©ë‹ˆë‹¤.
                        EmbedContentResponse response = geminiClient.models.embedContent(modelName, text, EmbedContentConfig.builder().build());
                        // Gemini ì‘ë‹µì„ LangChain4jì˜ `Embedding` ê°ì²´ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
                        return toLangChainEmbedding(response);
                    } catch (Exception e) {
                        // ì„ë² ë”© ì‹¤íŒ¨ ì‹œ ëŸ°íƒ€ì„ ì˜ˆì™¸ë¥¼ ë°œìƒì‹œí‚µë‹ˆë‹¤.
                        throw new RuntimeException("Failed to embed text: " + text, e);
                    }
                })
                .collect(Collectors.toList());

        return Response.from(embeddings);
    }

    /**
     * `com.google.genai`ì˜ `EmbedContentResponse`ë¥¼ LangChain4jì˜ `Embedding` ê°ì²´ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
     *
     * @param response `com.google.genai` í´ë¼ì´ì–¸íŠ¸ë¡œë¶€í„° ë°›ì€ ì„ë² ë”© ì‘ë‹µ
     * @return LangChain4jì˜ `Embedding` ê°ì²´
     * @throws RuntimeException ì‘ë‹µì— ì„ë² ë”©ì´ ì—†ê±°ë‚˜ ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš° ë°œìƒ
     */
    private Embedding toLangChainEmbedding(EmbedContentResponse response) {
        // ì‘ë‹µì—ì„œ ì„ë² ë”© ë²¡í„° ê°’ì„ ì¶”ì¶œí•©ë‹ˆë‹¤.
        List<Float> embeddingValues = response.embeddings().orElse(Collections.emptyList()).stream()
                .findFirst() // ì²« ë²ˆì§¸ ì„ë² ë”©ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.
                .orElseThrow(() -> new RuntimeException("No embedding found in response")) // ì„ë² ë”©ì´ ì—†ìœ¼ë©´ ì˜ˆì™¸ ë°œìƒ
                .values().orElse(Collections.emptyList()); // ë²¡í„° ê°’ ë¦¬ìŠ¤íŠ¸ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
        
        // List<Float>ë¥¼ float[] ë°°ì—´ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
        float[] floatArray = new float[embeddingValues.size()];
        for (int i = 0; i < embeddingValues.size(); i++) {
            floatArray[i] = embeddingValues.get(i);
        }
        // float[] ë°°ì—´ë¡œ LangChain4jì˜ `Embedding` ê°ì²´ë¥¼ ìƒì„±í•˜ì—¬ ë°˜í™˜í•©ë‹ˆë‹¤.
        return Embedding.from(floatArray);
    }
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\langchain\models\GeminiParallelEmbeddingModel.java`

```java
package com.codehows.taelimbe.langchain.models;

import com.google.genai.Client;
import com.google.genai.types.EmbedContentConfig;
import com.google.genai.types.EmbedContentResponse;
import dev.langchain4j.data.embedding.Embedding;
import dev.langchain4j.data.segment.TextSegment;
import dev.langchain4j.model.embedding.EmbeddingModel;
import dev.langchain4j.model.output.Response;
import lombok.RequiredArgsConstructor;

import java.util.Collections;
import java.util.List;
import java.util.concurrent.*;
import java.util.stream.IntStream;

@RequiredArgsConstructor
public class GeminiParallelEmbeddingModel implements EmbeddingModel {

    private final Client geminiClient;
    private final String modelName;
    private final ExecutorService embeddingExecutor;

    @Override
    public Response<Embedding> embed(TextSegment textSegment) {
        return Response.from(embedAll(List.of(textSegment)).content().getFirst());
    }

    @Override
    public Response<List<Embedding>> embedAll(List<TextSegment> textSegments) {

        try {
            List<CompletableFuture<Embedding>> futures =
                    textSegments.stream()
                            .map(segment ->
                                    CompletableFuture.supplyAsync(
                                            () -> embedOne(segment.text()),
                                            embeddingExecutor // Spring Beanìœ¼ë¡œ ì£¼ì…ëœ executor
                                    )
                            )
                            .toList();

            List<Embedding> embeddings =
                    futures.stream()
                            .map(CompletableFuture::join)
                            .toList();

            return Response.from(embeddings);

        } catch (Exception e) {
            throw new RuntimeException("Parallel embedding failed", e);
        }
    }

    private Embedding embedOne(String text) {
        try {
            EmbedContentResponse response =
                    geminiClient.models.embedContent(
                            modelName,
                            text,
                            EmbedContentConfig.builder().build()
                    );

            List<Float> values = response.embeddings()
                    .orElseThrow()
                    .getFirst()
                    .values()
                    .orElse(Collections.emptyList());

            float[] vector = new float[values.size()];
            IntStream.range(0, values.size()).forEach(i -> vector[i] = values.get(i));

            return Embedding.from(vector);

        } catch (Exception e) {
            throw new RuntimeException("Failed to embed text", e);
        }
    }
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\langchain\models\GeminiStreamingChatModel.java`

```java
package com.codehows.taelimbe.langchain.models;

import com.codehows.taelimbe.langchain.converters.MessageConverter;
import com.codehows.taelimbe.langchain.converters.ToolConverter;
import com.google.genai.Client;
import com.google.genai.types.*;
import com.google.gson.Gson;
import dev.langchain4j.agent.tool.ToolExecutionRequest;
import dev.langchain4j.agent.tool.ToolSpecification;
import dev.langchain4j.data.message.AiMessage;
import dev.langchain4j.data.message.ChatMessage;
import dev.langchain4j.model.StreamingResponseHandler;
import dev.langchain4j.model.chat.StreamingChatLanguageModel;
import dev.langchain4j.model.output.Response;
import lombok.Builder;
import lombok.RequiredArgsConstructor;

import java.util.Collections;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;

/**
 * LangChain4jì˜ `StreamingChatLanguageModel` ì¸í„°í˜ì´ìŠ¤ë¥¼ `com.google.genai` í´ë¼ì´ì–¸íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ êµ¬í˜„í•œ ì»¤ìŠ¤í…€ í´ë˜ìŠ¤ì…ë‹ˆë‹¤.
 * ì´ í´ë˜ìŠ¤ëŠ” LangChain4j í”„ë ˆì„ì›Œí¬ê°€ Googleì˜ ì œë„¤ë¦­ Gemini í´ë¼ì´ì–¸íŠ¸ë¥¼ í†µí•´ ìŠ¤íŠ¸ë¦¬ë° ì±„íŒ… ë° í•¨ìˆ˜ í˜¸ì¶œì„ ìˆ˜í–‰í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ì–´ëŒ‘í„° ì—­í• ì„ í•©ë‹ˆë‹¤.
 * `@RequiredArgsConstructor`ëŠ” Lombok ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ, final í•„ë“œì— ëŒ€í•œ ìƒì„±ìë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•˜ì—¬ ì˜ì¡´ì„± ì£¼ì…ì„ ìš©ì´í•˜ê²Œ í•©ë‹ˆë‹¤.
 * `@Builder`ëŠ” Lombok ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ, ë¹Œë” íŒ¨í„´ì„ ì‚¬ìš©í•˜ì—¬ ê°ì²´ë¥¼ ìƒì„±í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.
 */
@RequiredArgsConstructor
@Builder
public class GeminiStreamingChatModel implements StreamingChatLanguageModel {

    // Google Gemini API í´ë¼ì´ì–¸íŠ¸ ì£¼ì…
    private final Client geminiClient;
    // ì‚¬ìš©í•  Gemini ì±„íŒ… ëª¨ë¸ì˜ ì´ë¦„
    private final String modelName;
    // JSON ì§ë ¬í™”/ì—­ì§ë ¬í™”ë¥¼ ìœ„í•œ GSON ì¸ìŠ¤í„´ìŠ¤
    private final Gson gson = new Gson();

    /**
     * LangChain4j ë©”ì‹œì§€ ë¦¬ìŠ¤íŠ¸ì™€ ë„êµ¬ ìŠ¤í™ì„ ë°›ì•„ ìŠ¤íŠ¸ë¦¬ë° ë°©ì‹ìœ¼ë¡œ ì‘ë‹µì„ ìƒì„±í•©ë‹ˆë‹¤.
     * ì´ ë©”ì„œë“œëŠ” Gemini APIì˜ `generateContentStream`ì„ í˜¸ì¶œí•˜ì—¬ ì‹¤ì‹œê°„ìœ¼ë¡œ ì‘ë‹µì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
     *
     * @param messages LangChain4jì˜ `ChatMessage` ë¦¬ìŠ¤íŠ¸ (ëŒ€í™” ê¸°ë¡)
     * @param toolSpecifications LangChain4jì˜ `ToolSpecification` ë¦¬ìŠ¤íŠ¸ (AIê°€ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë„êµ¬ ëª…ì„¸)
     * @param handler ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µì„ ì²˜ë¦¬í•  `StreamingResponseHandler<AiMessage>`
     */
    @Override
    public void generate(List<ChatMessage> messages, List<ToolSpecification> toolSpecifications, StreamingResponseHandler<AiMessage> handler) {
        List<Content> googleAiMessages = MessageConverter.toGoogleAiMessages(messages);
        List<Tool> googleAiTools = ToolConverter.toGoogleAiTools(toolSpecifications);

        GenerateContentConfig config = GenerateContentConfig.builder()
                .tools(googleAiTools)
                .build();

        AtomicReference<StringBuilder> contentBuilder = new AtomicReference<>(new StringBuilder());
        AtomicReference<ToolExecutionRequest> toolExecutionRequestRef = new AtomicReference<>(null);

        System.out.println("=====[Agent Calling]=====");
        geminiClient.models.generateContentStream(modelName, googleAiMessages, config)
        .forEach(response -> {
            if (response.candidates().isPresent()) {
                Candidate candidate = response.candidates().orElse(Collections.emptyList()).getFirst();
                candidate.content().flatMap(Content::parts).orElse(Collections.emptyList()).forEach(part -> {
                try {
                    if (part.text().isPresent()) {
                        String token = part.text().get();
                        System.out.println(token);
                        contentBuilder.get().append(token);
                        handler.onNext(token);
                    } else if (part.functionCall().isPresent()) {
                        FunctionCall functionCall = part.functionCall().get();
                        if (functionCall.name().isPresent() && functionCall.args().isPresent()) {
                            System.out.println("=====[Tool Calling]=====");
                            System.out.println("=====[Tool Name: " + functionCall.name().get() + "]=====");
                            System.out.println("=====[Tool Args: " + functionCall.args().get() + "]=====");
                            String rawArgs = gson.toJson(functionCall.args().orElse(Collections.emptyMap()));
                            ToolExecutionRequest toolExecutionRequest = ToolExecutionRequest.builder()
                                    .name(functionCall.name().orElse(""))
                                    .arguments(rawArgs)
                                    .build();
                            toolExecutionRequestRef.set(toolExecutionRequest);
                        }
                    }
                } catch (Exception e) {
                    System.err.println("Exception while processing streaming content: " + e.getMessage());
                }
                });
            }
        });
        // ìŠ¤íŠ¸ë¦¬ë° ì™„ë£Œ í›„ ì‘ë‹µ ì²˜ë¦¬
        if (toolExecutionRequestRef.get() != null) {
            handler.onComplete(Response.from(AiMessage.from(toolExecutionRequestRef.get())));
        } else {
            handler.onComplete(Response.from(AiMessage.from(contentBuilder.get().toString())));
        }
    }

    /**
     * LangChain4j ë©”ì‹œì§€ ë¦¬ìŠ¤íŠ¸ë¥¼ ë°›ì•„ ìŠ¤íŠ¸ë¦¬ë° ë°©ì‹ìœ¼ë¡œ ì‘ë‹µì„ ìƒì„±í•©ë‹ˆë‹¤.
     * ì´ ë©”ì„œë“œëŠ” ë„êµ¬ ì‚¬ìš©ì´ ì—†ëŠ” ê²½ìš°ì— í˜¸ì¶œë©ë‹ˆë‹¤.
     * ë‚´ë¶€ì ìœ¼ë¡œ `toolSpecifications`ê°€ ë¹ˆ ë¦¬ìŠ¤íŠ¸ì¸ `generate` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.
     *
     * @param messages LangChain4jì˜ `ChatMessage` ë¦¬ìŠ¤íŠ¸
     * @param handler ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µì„ ì²˜ë¦¬í•  í•¸ë“¤ëŸ¬
     */
    @Override
    public void generate(List<ChatMessage> messages, StreamingResponseHandler<AiMessage> handler) {
        // ë„êµ¬ ëª…ì„¸ê°€ ì—†ëŠ” ê²½ìš°, ë¹ˆ ë¦¬ìŠ¤íŠ¸ë¥¼ ì „ë‹¬í•˜ì—¬ ê¸°ì¡´ `generate` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.
        generate(messages, Collections.emptyList(), handler);
    }
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\langchain\tools\ChatTools.java`

```java
package com.codehows.taelimbe.langchain.tools;

import com.google.gson.Gson;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
public class ChatTools {
    private final Gson gson;
}
```

## `C:\tealim-be\src\main\java\com\codehows\taelimbe\langchain\tools\ReportTools.java`

```java
package com.codehows.taelimbe.langchain.tools;

import com.codehows.taelimbe.ai.config.ToolArgsContextHolder;
import com.codehows.taelimbe.ai.dto.ReportResult;
import com.codehows.taelimbe.pudureport.dto.PuduReportDTO;
import com.codehows.taelimbe.pudureport.service.PuduReportService;
import com.google.gson.*;
import dev.langchain4j.agent.tool.Tool;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.time.format.DateTimeFormatter;
import java.util.List;

/**
 * AI ì—ì´ì „íŠ¸ê°€ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì»¤ìŠ¤í…€ ë„êµ¬ë“¤ì„ ì •ì˜í•˜ëŠ” í´ë˜ìŠ¤ì…ë‹ˆë‹¤.
 * `@Component` ì–´ë…¸í…Œì´ì…˜ì„ í†µí•´ Spring ì»¨í…Œì´ë„ˆì— ì˜í•´ ê´€ë¦¬ë˜ëŠ” ë¹ˆìœ¼ë¡œ ë“±ë¡ë©ë‹ˆë‹¤.
 * `@RequiredArgsConstructor`ëŠ” Lombok ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ, final í•„ë“œì— ëŒ€í•œ ìƒì„±ìë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•˜ì—¬ ì˜ì¡´ì„± ì£¼ì…ì„ ìš©ì´í•˜ê²Œ í•©ë‹ˆë‹¤.
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class ReportTools {

    // CleaningDataServiceë¥¼ ì£¼ì…ë°›ì•„ ì²­ì†Œ ë³´ê³ ì„œ ê´€ë ¨ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
    private final PuduReportService puduReportService;
    // LangChainConfigì—ì„œ ë¹ˆìœ¼ë¡œ ë“±ë¡ëœ Gson ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì£¼ì…ë°›ìŠµë‹ˆë‹¤.
    private final Gson gson;

    @Tool("""
    ì‚¬ìš©ìê°€ ìš”ì²­í•œ ê¸°ê°„ì— í•´ë‹¹í•˜ëŠ” ì²­ì†Œ ë¡œë´‡ ìš´ì˜ ë°ì´í„°ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
    
    âš ï¸ ë‚ ì§œ ê·œì¹™:
    - "ì–´ì œ" â†’ ì–´ì œ ë‚ ì§œ.
    - "ì˜¤ëŠ˜" â†’ ì˜¤ëŠ˜ ë‚ ì§œ.
    - "ì§€ë‚œì£¼" â†’ ì§€ë‚œì£¼ ì›”~ì¼.
    - "ì €ë²ˆì£¼" â†’ ì§€ë‚œì£¼ ì›”~ì¼.
    - "ì´ë²ˆì£¼" â†’ ì´ë²ˆì£¼ ì›”~ì¼.
    - "ì´ë²ˆë‹¬" â†’ ì´ë²ˆ ë‹¬ 1ì¼~ë§ì¼.
    - ì—°ë„ê°€ ì—†ëŠ” ê²½ìš°:
        - "nì›”" â†’ **ì˜¬í•´ nì›”** ë°ì´í„° ì¡°íšŒ (ì˜ˆ: "12ì›”" â†’ 2025-12-01 ~ 2025-12-31)
    - ì—°ë„ + ì›”ì´ ìˆëŠ” ê²½ìš°:
        - "YYYYë…„ nì›”" â†’ í•´ë‹¹ ì—°ë„ nì›” ë°ì´í„° ì¡°íšŒ (ì˜ˆ: "2024ë…„ 10ì›”" â†’ 2024-10-01 ~ 2024-10-31)
    - "ìµœê·¼ 7ì¼" â†’ ì˜¤ëŠ˜ ê¸°ì¤€ 7ì¼ ì „ ~ ì˜¤ëŠ˜.
    
    ë‚ ì§œëŠ” ë°˜ë“œì‹œ YYYY-MM-DD í˜•ì‹ìœ¼ë¡œ ì „ë‹¬í•´ì•¼ í•©ë‹ˆë‹¤.
    """)
    public ReportResult getReport(String startDate, String endDate) {

        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");

        if (startDate == null || endDate == null) {
            log.warn("[AI TOOL CALL] ê¸°ê°„ ë¯¸ì…ë ¥: startDate={}, endDate={}", startDate, endDate);
            throw new IllegalArgumentException("âš ï¸ ê¸°ê°„ì„ ëª…í™•íˆ ì…ë ¥í•´ì£¼ì„¸ìš”.");
        }
        ToolArgsContextHolder.setToolArgs("startDate", startDate);
        ToolArgsContextHolder.setToolArgs("endDate", endDate);

        log.info("[AI TOOL CALL] getReport({}, {})", startDate, endDate);

        List<PuduReportDTO> reportData = puduReportService.getReport(startDate, endDate);

        if (reportData == null || reportData.isEmpty()) {
            log.warn("[AI TOOL CALL] ê²°ê³¼ ì—†ìŒ: {} ~ {}", startDate, endDate);
        }

        String json = gson.toJson(reportData);

        return new ReportResult(json, startDate, endDate);
    }
}
```