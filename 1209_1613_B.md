# `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\service\AiChatService.java`

```java
package com.codehows.taelimbe.ai.service;

import com.codehows.taelimbe.ai.constant.SenderType;
import com.codehows.taelimbe.ai.dto.AiChatDTO;
import com.codehows.taelimbe.ai.entity.AiChat;
import com.codehows.taelimbe.ai.repository.AiChatRepository;
import com.codehows.taelimbe.user.entity.User;
import com.codehows.taelimbe.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Transactional
@Slf4j
public class AiChatService {

    private final AiChatRepository aiChatRepository;
    private final UserRepository userRepository;

    // í˜„ì¬ ë¡œê·¸ì¸í•œ ì‚¬ìš©ì ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    private User getCurrentUser() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String username = authentication.getName();
        return userRepository.findById(username)
                .orElseThrow(() -> new RuntimeException("ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: " + username));
    }


    /**
     * AI ì‘ë‹µ ë©”ì‹œì§€ ì €ì¥
     */
    public AiChat saveAgentMessage(String conversationId, String response) {
        User user = getCurrentUser();
        Long nextMessageIndex = aiChatRepository.findMaxMessageIndexByConversationId(conversationId) + 1;

        AiChat agentChat = AiChat.builder()
                .conversationId(conversationId)
                .senderType(SenderType.AI)
                .rawMessage(response)
                .messageIndex(nextMessageIndex)
                .user(user)
                .createdAt(LocalDateTime.now())
                .build();

        return aiChatRepository.save(agentChat);
    }

    /**
     * íŠ¹ì • ëŒ€í™”ì˜ ëª¨ë“  ë©”ì‹œì§€ ì¡°íšŒ
     */
    @Transactional(readOnly = true)
    public List<AiChatDTO> getChatHistory(String conversationId) {
        return aiChatRepository.findByConversationIdOrderByMessageIndex(conversationId)
                .stream()
                .map(AiChatDTO::from)
                .collect(Collectors.toList());
    }

    /**
     * ì‚¬ìš©ìì˜ ëŒ€í™” ëª©ë¡ ì¡°íšŒ (ìµœì‹ ìˆœ)
     * ê° ëŒ€í™”ì˜ ì²« ë²ˆì§¸ ë©”ì‹œì§€ë¥¼ ëŒ€í™” ì œëª©ìœ¼ë¡œ ì‚¬ìš©
     */
    @Transactional(readOnly = true)
    public List<AiChatDTO> getUserChatList() {
        User user = getCurrentUser();
        List<String> conversationIds = aiChatRepository.findConversationIdsByUserId(user.getUserId());

        // ëŒ€í™” ìì²´ê°€ í•˜ë‚˜ë„ ì—†ìœ¼ë©´ ë¹ˆ ë°°ì—´ ë°˜í™˜
        if (conversationIds == null || conversationIds.isEmpty()) {
            return Collections.emptyList();
        }

        return conversationIds.stream()
                .map(convId -> {
                    List<AiChat> messages = aiChatRepository.findByConversationIdOrderByMessageIndex(convId);

                    // ë©”ì‹œì§€ê°€ í•˜ë‚˜ë„ ì—†ìœ¼ë©´ null ê²°ê³¼ ëŒ€ì‹  skip
                    if (messages == null || messages.isEmpty()) {
                        return null; // ì´ ë’¤ì— filterë¡œ ê±¸ëŸ¬ì§
                    }

                    AiChat firstMessage = messages.stream()
                            .filter(msg -> msg.getSenderType() == SenderType.USER)
                            .findFirst()
                            .orElse(messages.get(0)); // ì´ì œ ì•ˆì „í•¨ (messagesê°€ empty ì•„ë‹Œ ìƒíƒœë¡œ ë“¤ì–´ì˜¤ê¸° ë•Œë¬¸)

                    return AiChatDTO.from(firstMessage);
                })
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }


    /**
     * íŠ¹ì • ë§¤ì¥ì˜ ëª¨ë“  ëŒ€í™” ì¡°íšŒ (ê´€ë¦¬ììš©)
     */
    @Transactional(readOnly = true)
    public List<AiChatDTO> getStoreChatHistory(Long storeId) {
        return aiChatRepository.findByStoreIdOrderByCreatedAtDesc(storeId)
                .stream()
                .map(AiChatDTO::from)
                .collect(Collectors.toList());
    }

    /**
     * ëŒ€í™” ë©”ì‹œì§€ ì‚­ì œ (ëŒ€í™” ì „ì²´ ì‚­ì œ)
     */
    public void deleteConversation(String conversationId) {
        List<AiChat> chats = aiChatRepository.findByConversationIdOrderByMessageIndex(conversationId);
        aiChatRepository.deleteAll(chats);
        log.info("ëŒ€í™” '{}' ì‚­ì œ ì™„ë£Œ", conversationId);
    }

    /**
     * íŠ¹ì • ë©”ì‹œì§€ ì‚­ì œ
     */
    public void deleteChatMessage(Long aiChatId) {
        aiChatRepository.deleteById(aiChatId);
        log.info("ë©”ì‹œì§€ '{}' ì‚­ì œ ì™„ë£Œ", aiChatId);
    }

    /** USER ë©”ì‹œì§€ ì €ì¥ */
    public void saveUserMessage(String convId, Long userId, String msg) {

        User user = userRepository.findById(userId)
                .orElseThrow(() -> new IllegalArgumentException("User not found"));

        long idx = aiChatRepository.countByConversationId(convId);

        AiChat chat = AiChat.builder()
                .conversationId(convId)
                .senderType(SenderType.USER)
                .rawMessage(msg)
                .messageIndex(idx)
                .user(user)
                .build();

        aiChatRepository.save(chat);
    }

    /** AI ë©”ì‹œì§€ ì €ì¥ */
    public void saveAiMessage(String convId, Long userId, String msg) {

        User user = userRepository.findById(userId)
                .orElseThrow(() -> new IllegalArgumentException("User not found"));

        long idx = aiChatRepository.countByConversationId(convId);

        AiChat chat = AiChat.builder()
                .conversationId(convId)
                .senderType(SenderType.AI)
                .rawMessage(msg)
                .messageIndex(idx)
                .user(user)
                .build();

        aiChatRepository.save(chat);
    }

    public List<AiChat> loadConversation(String convId) {
        return aiChatRepository.findByConversationIdOrderByMessageIndexAsc(convId);
    }

    public List<String> loadChatHistory(Long userId) {
        return aiChatRepository.findConversationIdsByUser(userId);
    }
}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\repository\AiChatRepository.java`

```java
package com.codehows.taelimbe.ai.repository;

import com.codehows.taelimbe.ai.entity.AiChat;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface AiChatRepository extends JpaRepository<AiChat, Long> {

    // íŠ¹ì • ëŒ€í™”ì˜ ëª¨ë“  ë©”ì‹œì§€ ì¡°íšŒ (ë©”ì‹œì§€ ìˆœì„œëŒ€ë¡œ)
    List<AiChat> findByConversationIdOrderByMessageIndex(String conversationId);

    // íŠ¹ì • ì‚¬ìš©ìì˜ ëª¨ë“  ëŒ€í™” ì¡°íšŒ
    List<AiChat> findByUser_UserIdOrderByCreatedAtDesc(Long userId);

    // íŠ¹ì • ë§¤ì¥ì˜ ëª¨ë“  ëŒ€í™” ì¡°íšŒ
    @Query("SELECT c FROM AiChat c WHERE c.user.store.storeId = :storeId ORDER BY c.createdAt DESC")
    List<AiChat> findByStoreIdOrderByCreatedAtDesc(@Param("storeId") Long storeId);

    // íŠ¹ì • ëŒ€í™”ì˜ ë§ˆì§€ë§‰ ë©”ì‹œì§€ ì¸ë±ìŠ¤ ì¡°íšŒ
    @Query("SELECT COALESCE(MAX(c.messageIndex), 0) FROM AiChat c WHERE c.conversationId = :conversationId")
    Long findMaxMessageIndexByConversationId(@Param("conversationId") String conversationId);

    @Query("""
    SELECT c.conversationId
    FROM AiChat c
    WHERE c.user.userId = :userId
    GROUP BY c.conversationId
    ORDER BY MAX(c.createdAt) DESC
""")
    List<String> findConversationIdsByUserId(@Param("userId") Long userId);


    List<AiChat> findByConversationIdOrderByMessageIndexAsc(String conversationId);

    @Query("SELECT DISTINCT a.conversationId FROM AiChat a WHERE a.user.userId = :userId")
    List<String> findConversationIdsByUser(@Param("userId") Long userId);

    long countByConversationId(String conversationId);
}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\service\EmbeddingService.java`

```java
package com.codehows.taelimbe.ai.service;

import com.codehows.taelimbe.langchain.embaddings.EmbeddingStoreManager;
import com.codehows.taelimbe.langchain.embaddings.TextSplitterStrategy;
import dev.langchain4j.data.embedding.Embedding;
import dev.langchain4j.data.segment.TextSegment;
import dev.langchain4j.model.embedding.EmbeddingModel;
import dev.langchain4j.model.output.Response;
import dev.langchain4j.store.embedding.EmbeddingStore;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.core.task.TaskExecutor;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.concurrent.CompletableFuture;

/**
 * í…ìŠ¤íŠ¸ ì„ë² ë”© ë° ë²¡í„° ì €ì¥ì†Œ ê´€ë¦¬ë¥¼ ë‹´ë‹¹í•˜ëŠ” ì„œë¹„ìŠ¤ì…ë‹ˆë‹¤.
 * `@Service` ì–´ë…¸í…Œì´ì…˜ì€ ì´ í´ë˜ìŠ¤ê°€ ë¹„ì¦ˆë‹ˆìŠ¤ ê³„ì¸µì˜ ì»´í¬ë„ŒíŠ¸ì„ì„ ë‚˜íƒ€ë‚´ë©°,
 * Spring ì»¨í…Œì´ë„ˆì— ì˜í•´ ê´€ë¦¬ë˜ëŠ” ë¹ˆìœ¼ë¡œ ë“±ë¡ë©ë‹ˆë‹¤.
 * `@RequiredArgsConstructor`ëŠ” Lombok ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ, final í•„ë“œì— ëŒ€í•œ ìƒì„±ìë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•˜ì—¬ ì˜ì¡´ì„± ì£¼ì…ì„ ìš©ì´í•˜ê²Œ í•©ë‹ˆë‹¤.
 * `@Slf4j`ëŠ” Lombok ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ, ë¡œê¹…ì„ ìœ„í•œ `log` ê°ì²´ë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class EmbeddingService {

    // í…ìŠ¤íŠ¸ë¥¼ ì„ë² ë”© ë²¡í„°ë¡œ ë³€í™˜í•˜ëŠ” ëª¨ë¸ì„ ì£¼ì…ë°›ìŠµë‹ˆë‹¤.
    private final EmbeddingModel embeddingModel;
    // ìƒì„±ëœ ì„ë² ë”© ë²¡í„°ë¥¼ ì €ì¥í•˜ê³  ê²€ìƒ‰í•˜ëŠ” ìŠ¤í† ì–´ë¥¼ ì£¼ì…ë°›ìŠµë‹ˆë‹¤.
    private final EmbeddingStore<TextSegment> embeddingStore;
    // ì„ë² ë”© ìŠ¤í† ì–´ì˜ ì´ˆê¸°í™” ë° ê´€ë¦¬ ê¸°ëŠ¥ì„ ì œê³µí•˜ëŠ” ë§¤ë‹ˆì €ë¥¼ ì£¼ì…ë°›ìŠµë‹ˆë‹¤.
    private final EmbeddingStoreManager embeddingStoreManager;
    // í…ìŠ¤íŠ¸ ë¶„í•  ì „ëµì„ ì£¼ì…ë°›ìŠµë‹ˆë‹¤.
    private final TextSplitterStrategy textSplitterStrategy;

    // ë¹„ë™ê¸° ì‘ì—…ì„ ìœ„í•œ ìŠ¤ë ˆë“œ í’€ì„ ì£¼ì…ë°›ìŠµë‹ˆë‹¤.
    @Qualifier("taskExecutor")
    private final TaskExecutor taskExecutor;

    /**
     * ì£¼ì–´ì§„ í…ìŠ¤íŠ¸ë¥¼ ì„ë² ë”©í•˜ì—¬ ë²¡í„° ì €ì¥ì†Œì— ì¶”ê°€í•©ë‹ˆë‹¤.
     * ì´ ë©”ì„œë“œëŠ” RAG(Retrieval-Augmented Generation)ë¥¼ ìœ„í•œ ì§€ì‹ ê¸°ë°˜ì„ êµ¬ì¶•í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.
     * ì‘ì—…ì€ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì‹¤í–‰ë˜ì–´ í˜¸ì¶œ ìŠ¤ë ˆë“œë¥¼ ë¸”ë¡œí‚¹í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
     *
     * @param text ì„ë² ë”©í•˜ê³  ì €ì¥í•  í…ìŠ¤íŠ¸
     * @return ë¹„ë™ê¸° ì‘ì—…ì˜ ì™„ë£Œë¥¼ ë‚˜íƒ€ë‚´ëŠ” `CompletableFuture<Void>`
     */
//    public CompletableFuture<Void> embedAndStore(String text) {
//        return CompletableFuture.runAsync(() -> {
//            log.info("í…ìŠ¤íŠ¸ ì„ë² ë”© ë° ì €ì¥ ì‹œì‘: '{}'", text);
//
//            // 1. í…ìŠ¤íŠ¸ ë¶„í•  ì „ëµì„ ì‚¬ìš©í•˜ì—¬ í…ìŠ¤íŠ¸ë¥¼ ì‘ì€ `TextSegment`ë“¤ë¡œ ë¶„í• í•©ë‹ˆë‹¤.
//            List<TextSegment> segments = textSplitterStrategy.split(text).stream().map(TextSegment::from).toList();
//
//            // 2. `EmbeddingModel`ì„ ì‚¬ìš©í•˜ì—¬ ê° `TextSegment`ë¥¼ ì„ë² ë”© ë²¡í„°ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
//            Response<List<Embedding>> embedding = embeddingModel.embedAll(segments);
//
//            // 3. ì„ë² ë”©ëœ `TextSegment`ì™€ í•´ë‹¹ ì„ë² ë”© ë²¡í„°ë¥¼ `EmbeddingStore`ì— ì¶”ê°€í•©ë‹ˆë‹¤.
//            embeddingStore.addAll(embedding.content(), segments);
//
//            log.info("í…ìŠ¤íŠ¸ ì„ë² ë”© ë° ì €ì¥ ì™„ë£Œ.");
//        }, taskExecutor); // ì§€ì •ëœ `taskExecutor` ìŠ¤ë ˆë“œ í’€ì—ì„œ ì‹¤í–‰
//    }

    public CompletableFuture<Void> embedAndStore(String text) {
        return CompletableFuture.runAsync(() -> {
            log.info("í…ìŠ¤íŠ¸ ì„ë² ë”© ë° ì €ì¥ ì‹œì‘: '{}'", text);

            try {
                // 1. í…ìŠ¤íŠ¸ ë¶„í• 
                List<TextSegment> segments = textSplitterStrategy
                        .split(text)
                        .stream()
                        .map(TextSegment::from)
                        .toList();

                log.info("Segments size = {}", segments.size());
                if (segments.isEmpty()) {
                    log.warn("âš  ë¶„í• ëœ ì„¸ê·¸ë¨¼íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤. ì²˜ë¦¬ ì¤‘ë‹¨.");
                    return;
                }

                // 2. ì„ë² ë”© ìˆ˜í–‰
                Response<List<Embedding>> embedding = embeddingModel.embedAll(segments);
                log.info("Embedding size = {}", embedding.content().size());

                // 3. ì„ë² ë”© ìŠ¤í† ì–´ì— ì €ì¥
                embeddingStore.addAll(embedding.content(), segments);

            } catch (Exception e) {
                log.error("âŒ ì„ë² ë”© ì¤‘ ì˜¤ë¥˜ ë°œìƒ!", e);
                throw new RuntimeException(e);
            }

            log.info("í…ìŠ¤íŠ¸ ì„ë² ë”© ë° ì €ì¥ ì™„ë£Œ.");
        }, taskExecutor);
    }


    /**
     * ê¸°ì¡´ ë²¡í„° ì €ì¥ì†Œì˜ ëª¨ë“  ë°ì´í„°ë¥¼ ì‚­ì œí•˜ê³ , ì£¼ì–´ì§„ í…ìŠ¤íŠ¸ë¡œ ìƒˆë¡œ ì„ë² ë”©í•˜ì—¬ ì €ì¥í•©ë‹ˆë‹¤.
     * ì§€ì‹ ê¸°ë°˜ì„ ì™„ì „íˆ ì´ˆê¸°í™”í•˜ê³  ìƒˆë¡œìš´ ë°ì´í„°ë¡œ êµì²´í•  ë•Œ ì‚¬ìš©ë©ë‹ˆë‹¤.
     * ì‘ì—…ì€ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì‹¤í–‰ë˜ì–´ í˜¸ì¶œ ìŠ¤ë ˆë“œë¥¼ ë¸”ë¡œí‚¹í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
     *
     * @param text ìƒˆë¡œ ì„ë² ë”©í•˜ê³  ì €ì¥í•  í…ìŠ¤íŠ¸
     * @return ë¹„ë™ê¸° ì‘ì—…ì˜ ì™„ë£Œë¥¼ ë‚˜íƒ€ë‚´ëŠ” `CompletableFuture<Void>`
     */
    public CompletableFuture<Void> resetAndEmbed(String text) {
        return CompletableFuture.runAsync(() -> {
            log.info("ì„ë² ë”© ìŠ¤í† ì–´ ì¬ì„¤ì • ë° ìƒˆ í…ìŠ¤íŠ¸ ì„ë² ë”© ì‹œì‘.");

            // 1. `EmbeddingStoreManager`ë¥¼ ì‚¬ìš©í•˜ì—¬ Milvus ì»¬ë ‰ì…˜ì„ ì¬ì„¤ì •(ì‚­ì œ í›„ ì¬ìƒì„±)í•©ë‹ˆë‹¤.
            embeddingStoreManager.reset();

            // 2. ìƒˆë¡œìš´ í…ìŠ¤íŠ¸ë¡œ ì„ë² ë”© ë° ì €ì¥ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
            embedAndStore(text);

            log.info("ì„ë² ë”© ìŠ¤í† ì–´ ì¬ì„¤ì • ë° ìƒˆ í…ìŠ¤íŠ¸ ì„ë² ë”© ì™„ë£Œ.");
        }, taskExecutor); // ì§€ì •ëœ `taskExecutor` ìŠ¤ë ˆë“œ í’€ì—ì„œ ì‹¤í–‰
    }
}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\controller\AiChatController.java`

```java
package com.codehows.taelimbe.ai.controller;

import com.codehows.taelimbe.ai.dto.AiChatDTO;
import com.codehows.taelimbe.ai.service.AiChatService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Slf4j
@RestController
@RequestMapping("/api")
@RequiredArgsConstructor
public class AiChatController {

    private final AiChatService aiChatService;
    /**
     * ì‚¬ìš©ìì˜ ëŒ€í™” ëª©ë¡ ì¡°íšŒ (ì‚¬ì´ë“œë°”ì—ì„œ ì‚¬ìš©)
     * ê° ëŒ€í™”ì˜ ì²« ë²ˆì§¸ ë©”ì‹œì§€ (ì‚¬ìš©ì ì§ˆë¬¸)ë¥¼ ì œëª©ìœ¼ë¡œ ë°˜í™˜
     */
    @GetMapping("/chat/history")
    public ResponseEntity<List<AiChatDTO>> getChatHistory() {
        List<AiChatDTO> chatList = aiChatService.getUserChatList();
        return ResponseEntity.ok(chatList);
    }

    /**
     * íŠ¹ì • ëŒ€í™”ì˜ ë©”ì‹œì§€ ëª©ë¡ ì¡°íšŒ
     */
    @GetMapping("/conversation/{conversationId}")
    public ResponseEntity<List<AiChatDTO>> getConversationMessages(
            @PathVariable String conversationId) {
        List<AiChatDTO> messages = aiChatService.getChatHistory(conversationId);
        return ResponseEntity.ok(messages);
    }

    /**
     * ëŒ€í™” ì‚­ì œ
     */
    @DeleteMapping("/conversation/{conversationId}")
    public ResponseEntity<String> deleteConversation(
            @PathVariable String conversationId) {
        try {
            aiChatService.deleteConversation(conversationId);
            return ResponseEntity.ok("ëŒ€í™”ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.");
        } catch (Exception e) {
            log.error("ëŒ€í™” ì‚­ì œ ì‹¤íŒ¨: {}", e.getMessage());
            return ResponseEntity.internalServerError()
                    .body("ëŒ€í™” ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
        }
    }
}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\service\AgentService.java`

```java
package com.codehows.taelimbe.ai.service;

import com.codehows.taelimbe.ai.dto.ChatPromptRequest;
import com.codehows.taelimbe.langchain.Agent;
import dev.langchain4j.model.input.Prompt;
import dev.langchain4j.model.input.PromptTemplate;
import dev.langchain4j.service.TokenStream;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.io.IOException;
import java.util.Map;
import java.util.UUID;

/**
 * AI ì—ì´ì „íŠ¸ì™€ì˜ ëŒ€í™” ë¡œì§ì„ ìº¡ìŠí™”í•˜ëŠ” ì„œë¹„ìŠ¤ í´ë˜ìŠ¤ì…ë‹ˆë‹¤.
 * `AgentController`ì˜ ë³µì¡ì„±ì„ ì¤„ì´ê³ , ëŒ€í™” ì²˜ë¦¬ì™€ ê´€ë ¨ëœ ëª¨ë“  ë¡œì§ì„ ì´ê³³ì—ì„œ ê´€ë¦¬í•©ë‹ˆë‹¤.
 * `@Service` ì–´ë…¸í…Œì´ì…˜ì€ ì´ í´ë˜ìŠ¤ê°€ ë¹„ì¦ˆë‹ˆìŠ¤ ê³„ì¸µì˜ ì»´í¬ë„ŒíŠ¸ì„ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
 * `@RequiredArgsConstructor`ëŠ” Lombok ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ, final í•„ë“œì— ëŒ€í•œ ìƒì„±ìë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•˜ì—¬ ì˜ì¡´ì„± ì£¼ì…ì„ ìš©ì´í•˜ê²Œ í•©ë‹ˆë‹¤.
 * `@Slf4j`ëŠ” Lombok ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ, ë¡œê¹…ì„ ìœ„í•œ `log` ê°ì²´ë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class AgentService {

    private final AiChatService aiChatService;

    // LangChain4j Agent ì¸í„°í˜ì´ìŠ¤ì˜ êµ¬í˜„ì²´ë¥¼ ì£¼ì…ë°›ìŠµë‹ˆë‹¤.
    @Qualifier("reportAgent")
    private final Agent reportAgent;

    @Qualifier("chatAgent")
    private final Agent chatAgent;

    /**
     * ì‚¬ìš©ìì˜ ë©”ì‹œì§€ë¥¼ ë°›ì•„ AIì™€ ëŒ€í™”í•˜ê³ , ì‘ë‹µì„ ìŠ¤íŠ¸ë¦¬ë°ìœ¼ë¡œ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì „ì†¡í•©ë‹ˆë‹¤.
     * ì´ ë©”ì„œë“œëŠ” `SseEmitter`ë¥¼ ì‚¬ìš©í•˜ì—¬ Server-Sent Events (SSE) ë°©ì‹ìœ¼ë¡œ ì‹¤ì‹œê°„ ì‘ë‹µì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
     *
     * @param req ì‚¬ìš©ì ë©”ì‹œì§€ì™€ ëŒ€í™” IDë¥¼ í¬í•¨í•˜ëŠ” ìš”ì²­ DTO
     * @return `SseEmitter` ê°ì²´. í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì´ë²¤íŠ¸ë¥¼ ìŠ¤íŠ¸ë¦¬ë°í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.
     */
    public SseEmitter chat(ChatPromptRequest req, Long userId) {

        SseEmitter emitter = new SseEmitter(Long.MAX_VALUE);

        // ëŒ€í™” IDê°€ ìš”ì²­ì— í¬í•¨ë˜ì–´ ìˆì§€ ì•Šë‹¤ë©´ ìƒˆë¡œìš´ IDë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
        String convId = (req.getConversationId() == null || req.getConversationId().isBlank())
                ? UUID.randomUUID().toString()
                : req.getConversationId();

        String userMessage = req.getMessage();

        // ìœ ì € ë©”ì‹œì§€ ì €ì¥
        aiChatService.saveUserMessage(convId, userId, userMessage);

        // aií˜¸ì¶œ, sse ì²˜ë¦¬
        createEmitter(emitter, convId, chatAgent, userMessage, userId);

        return emitter;
    }

    public SseEmitter report(ChatPromptRequest req, Long userId) {

        SseEmitter emitter = new SseEmitter(Long.MAX_VALUE);

        // í˜„ì¬ ìŠ¤ë ˆë“œì— ì‚¬ìš©ì ì´ë¦„ì„ ì„¤ì •í•˜ì—¬, ë„êµ¬ í˜¸ì¶œ ë“±ì—ì„œ ì‚¬ìš©ì ì»¨í…ìŠ¤íŠ¸ë¥¼ í™œìš©í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.
        // ëŒ€í™” IDê°€ ìš”ì²­ì— í¬í•¨ë˜ì–´ ìˆì§€ ì•Šë‹¤ë©´ ìƒˆë¡œìš´ IDë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
        String convId = (req.getConversationId() == null || req.getConversationId().isBlank())
                ? UUID.randomUUID().toString()
                : req.getConversationId();

        PromptTemplate template = PromptTemplate.from("""
                  ì œê³µë°›ì€ ë°ì´í„°ì…‹ì„ ë¶„ì„í•˜ì—¬, ì „ì²´ ìš”ì•½ê³¼ ìƒì„¸ ë³´ê³ ì„œë¥¼ ëª¨ë‘ í¬í•¨í•˜ëŠ” ë§ˆí¬ë‹¤ìš´ í˜•ì‹ì˜ ë¦¬í¬íŠ¸ë¥¼ ìƒì„±í•˜ì„¸ìš”.\n\
                  ë¦¬í¬íŠ¸ëŠ” ë‹¤ìŒ í•­ëª©ì„ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤:\n\
                  \n\
                  # ì´ê´„ ìš”ì•½\n\
                  - ë°ì´í„°ì˜ í•µì‹¬ ì¸ì‚¬ì´íŠ¸ì™€ ê²°ë¡  ìš”ì•½\n\
                  \n\
                  # ìƒì„¸ ë¶„ì„\n\
                  - ì„¹ì…˜ë³„ ìƒì„¸ ë¶„ì„\n\
                  - í‘œì™€ ë¦¬ìŠ¤íŠ¸, í•„ìš”ì‹œ ê·¸ë˜í”„ ë§í¬ í¬í•¨ ê°€ëŠ¥\n\
                  \n\
                  # ê²°ë¡  ë° ì œì–¸\n\
                  - ë°ì´í„° ê¸°ë°˜ì˜ ê²°ë¡ ê³¼ í–¥í›„ ì¡°ì¹˜/ì¶”ì²œ ì‚¬í•­\n\
                  \n\
                  **ì°¸ê³ **:\n\
                  - í•­ìƒ Markdown í˜•ì‹ ì‚¬ìš© (í—¤ë”, ë¦¬ìŠ¤íŠ¸, í‘œ, ì½”ë“œë¸”ë¡ ë“±)\n\
                  - ìš”ì•½ì€ ì£¼ìš” í¬ì¸íŠ¸ë¥¼ ê°„ê²°í•˜ê²Œ\n\
                  - ìƒì„¸ ë¶„ì„ì€ í•­ëª©ë³„ë¡œ êµ¬ì²´ì  ë‚´ìš©ì„ í¬í•¨\n\
                  \n\
                  ì´ì œ ë‹¤ìŒì˜ ì§ˆë¬¸ì— ë‹µë³€í•´ì£¼ì„¸ìš”.\n\
                  {{question}}
                """); // ì„¤ì • ê°’ ì‚¬ìš©

        Prompt prompt = template.apply(Map.of("question", req.getMessage()));

        createEmitter(emitter, convId, reportAgent, prompt.text(), userId);

        return emitter;
    }

    @Async("taskExecutor")
    protected void createEmitter(
            SseEmitter emitter, 
            String convId, 
            Agent agent, 
            String prompt, 
            Long userId) {

        try {
            // Agentì˜ chat ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ì—¬ Gemini ëª¨ë¸ê³¼ ìƒí˜¸ì‘ìš©í•©ë‹ˆë‹¤.
            // ìŠ¤íŠ¸ë¦¬ë° ë°©ì‹ìœ¼ë¡œ ì‘ë‹µì„ ë°›ìœ¼ë©°, ê° í† í°ì„ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì „ì†¡í•©ë‹ˆë‹¤.
            TokenStream tokenStream = agent.chat(prompt, convId);

            // AI ë©”ì‹œì§€ ëˆ„ì  ë²„í¼
            StringBuilder aiBuilder = new StringBuilder();

            // ì²« ì‘ë‹µìœ¼ë¡œ ëŒ€í™” IDë¥¼ ì „ì†¡í•©ë‹ˆë‹¤.
            emitter.send(SseEmitter.event().name("conversationId").data(convId));

            // ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µì˜ ê° í† í°ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
            tokenStream.onNext(token -> {
                        try {
                            aiBuilder.append(token);
                            // ê° í† í°ì„ SSE ì´ë²¤íŠ¸ë¡œ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì „ì†¡í•©ë‹ˆë‹¤.
                            emitter.send(SseEmitter.event().data(token));
                        } catch (IOException e) {
                            // í† í° ì „ì†¡ ì¤‘ ì˜¤ë¥˜ ë°œìƒ ì‹œ emitterë¥¼ ì˜¤ë¥˜ì™€ í•¨ê»˜ ì™„ë£Œí•©ë‹ˆë‹¤.
                            log.error("SSE í† í° ì „ì†¡ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {}", e.getMessage());
                            emitter.completeWithError(e);
                        }
                    })
                    // ìŠ¤íŠ¸ë¦¬ë° ì™„ë£Œ ì‹œ AI ë©”ì‹œì§€ ì €ì¥ë§Œ ìˆ˜í–‰í•©ë‹ˆë‹¤.
                    .onComplete(response -> {
                        aiChatService.saveAiMessage(convId, userId, aiBuilder.toString());

                        // ìŠ¤íŠ¸ë¦¼ ì •ìƒ ì¢…ë£Œ
                        emitter.complete();

                    })
                    // ìŠ¤íŠ¸ë¦¬ë° ì¤‘ ì˜¤ë¥˜ ë°œìƒ ì‹œ emitterë¥¼ ì˜¤ë¥˜ì™€ í•¨ê»˜ ì™„ë£Œí•©ë‹ˆë‹¤.
                    .onError(emitter::completeWithError)
                    // ìŠ¤íŠ¸ë¦¬ë°ì„ ì‹œì‘í•©ë‹ˆë‹¤.
                    .start();

        } catch (Exception e) {
            // ì˜ˆì™¸ ë°œìƒ ì‹œ emitterë¥¼ ì˜¤ë¥˜ì™€ í•¨ê»˜ ì™„ë£Œí•©ë‹ˆë‹¤.
            log.error("ì±„íŒ… ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {}", e.getMessage(), e);
            emitter.completeWithError(e);
//        } finally {
//            // ìš”ì²­ ì²˜ë¦¬ ì™„ë£Œ í›„ ìŠ¤ë ˆë“œ ë¡œì»¬ì— ì €ì¥ëœ ì‚¬ìš©ì ì •ë³´ë¥¼ ì œê±°í•©ë‹ˆë‹¤.
//            emitter.complete();   // â† ë„¤ê°€ ì›í•œ ê·¸ëŒ€ë¡œ ìœ ì§€
        }
    }

}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\controller\AgentController.java`

```java
package com.codehows.taelimbe.ai.controller;

import com.codehows.taelimbe.ai.dto.ChatPromptRequest;
import com.codehows.taelimbe.ai.dto.EmbeddingRequest;
import com.codehows.taelimbe.ai.service.AgentService;
import com.codehows.taelimbe.ai.service.EmbeddingService;
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.util.concurrent.CompletableFuture;

/**
 * AI ì—ì´ì „íŠ¸ì™€ì˜ ëŒ€í™” ë° ì„ë² ë”© ê´€ë¦¬ë¥¼ ì²˜ë¦¬í•˜ëŠ” API ì»¨íŠ¸ë¡¤ëŸ¬ì…ë‹ˆë‹¤.
 * `@RestController`ëŠ” ì´ í´ë˜ìŠ¤ê°€ RESTful ì›¹ ì„œë¹„ìŠ¤ì˜ ì»¨íŠ¸ë¡¤ëŸ¬ì„ì„ ë‚˜íƒ€ë‚´ë©°,
 * ëª¨ë“  ë©”ì„œë“œì˜ ë°˜í™˜ ê°’ì´ HTTP ì‘ë‹µ ë³¸ë¬¸ìœ¼ë¡œ ì§ì ‘ ì§ë ¬í™”ë¨ì„ ì˜ë¯¸í•©ë‹ˆë‹¤.
 * `@RequestMapping("/api")`ëŠ” ì´ ì»¨íŠ¸ë¡¤ëŸ¬ì˜ ëª¨ë“  í•¸ë“¤ëŸ¬ ë©”ì„œë“œê°€ "/api" ê²½ë¡œ ì•„ë˜ì— ë§¤í•‘ë¨ì„ ì§€ì •í•©ë‹ˆë‹¤.
 * `@RequiredArgsConstructor`ëŠ” Lombok ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ, final í•„ë“œì— ëŒ€í•œ ìƒì„±ìë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•˜ì—¬ ì˜ì¡´ì„± ì£¼ì…ì„ ìš©ì´í•˜ê²Œ í•©ë‹ˆë‹¤.
 * `@Slf4j`ëŠ” Lombok ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ, ë¡œê¹…ì„ ìœ„í•œ `log` ê°ì²´ë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.
 */
@RestController
@RequestMapping("/api")
@RequiredArgsConstructor
@Slf4j
public class AgentController {

    // ConversationServiceë¥¼ ì£¼ì…ë°›ì•„ ì±„íŒ… ê´€ë ¨ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ìœ„ì„í•©ë‹ˆë‹¤.
    private final AgentService agentService;
    // ì„ë² ë”© ê´€ë ¨ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ì²˜ë¦¬í•˜ëŠ” ì„œë¹„ìŠ¤ë¥¼ ì£¼ì…ë°›ìŠµë‹ˆë‹¤.
    private final EmbeddingService embeddingService;

    /**
     /**
     * ì‚¬ìš©ìì˜ ë©”ì‹œì§€ë¥¼ ë°›ì•„ AIì™€ ëŒ€í™”í•˜ê³ , ì‘ë‹µì„ ìŠ¤íŠ¸ë¦¬ë°ìœ¼ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.
     * `/agent/chat`ì€ ì¼ë°˜ì ì¸ ëŒ€í™”ë¥¼, `/agent/report`ëŠ” ë³´ê³ ì„œ ìƒì„±ì„ ìœ„í•œ íŠ¹ì • í”„ë¡¬í”„íŠ¸ ì²˜ë¦¬ë¥¼ ë‹´ë‹¹í•©ë‹ˆë‹¤.
     * ì´ ë©”ì„œë“œëŠ” ì‹¤ì œ ì±„íŒ… ë¡œì§ì„ `conversationService`ë¡œ ìœ„ì„í•©ë‹ˆë‹¤.
     *
     * @param chatPromptRequest ì‚¬ìš©ì ë©”ì‹œì§€ì™€ ëŒ€í™” IDë¥¼ í¬í•¨í•˜ëŠ” ìš”ì²­ DTO
     * @return Server-Sent Events (SSE)ë¥¼ í†µí•´ AIì˜ ì‘ë‹µì„ ìŠ¤íŠ¸ë¦¬ë°í•˜ëŠ” SseEmitter
     */
    @PostMapping(value = "/agent/chat", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter chat(
            @RequestBody ChatPromptRequest chatPromptRequest,
            HttpServletRequest request
    ) {
        // JWT Filterì—ì„œ ì €ì¥ëœ userId ê°€ì ¸ì˜¤ê¸°
        Long userId = Long.valueOf(request.getAttribute("userId").toString());

        // AgentServiceë¡œ ìœ„ì„
        return agentService.chat(chatPromptRequest, userId);
    }

    @PostMapping(value = "/agent/report", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter report(
            @RequestBody ChatPromptRequest chatPromptRequest,
            HttpServletRequest request
    ) {
        // JWT Filterì—ì„œ ì €ì¥ëœ userId ê°€ì ¸ì˜¤ê¸°
        Long userId = Long.valueOf(request.getAttribute("userId").toString());

        // ì±„íŒ… ìš”ì²­ ì²˜ë¦¬ë¥¼ ConversationServiceë¡œ ìœ„ì„í•©ë‹ˆë‹¤.
        return agentService.report(chatPromptRequest, userId);
    }
    /**
     * ì£¼ì–´ì§„ í…ìŠ¤íŠ¸ë¥¼ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì„ë² ë”©í•˜ì—¬ ë²¡í„° ì €ì¥ì†Œì— ì €ì¥í•©ë‹ˆë‹¤.
     * ì´ ë©”ì„œë“œëŠ” ìš”ì²­ì„ ì¦‰ì‹œ ìˆ˜ë½í•˜ê³  ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì‘ì—…ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
     *
     * @param request ì„ë² ë”©í•  í…ìŠ¤íŠ¸ë¥¼ í¬í•¨í•˜ëŠ” ìš”ì²­ DTO
     * @return ì‘ì—…ì˜ ë¹„ë™ê¸° ì‹¤í–‰ ê²°ê³¼ë¥¼ ë‹´ì€ CompletableFuture<ResponseEntity>
     */
    @PostMapping("/embeddings")
    public CompletableFuture<ResponseEntity<String>> embed(@RequestBody EmbeddingRequest request) { // @Valid ì¶”ê°€
        return embeddingService.embedAndStore(request.getText())
                // ì„ë² ë”© ë° ì €ì¥ ì‘ì—…ì´ ì„±ê³µì ìœ¼ë¡œ ì‹œì‘ë˜ë©´ 200 OK ì‘ë‹µì„ ë°˜í™˜í•©ë‹ˆë‹¤.
                .thenApply(v -> ResponseEntity.ok("Text embedding and storing process started successfully."))
                // ì‘ì—… ì¤‘ ì˜ˆì™¸ ë°œìƒ ì‹œ 500 Internal Server Error ì‘ë‹µì„ ë°˜í™˜í•©ë‹ˆë‹¤.
                .exceptionally(ex -> {
                    log.error("embedAndStore ì‘ì—… ì‹¤í–‰ ì‹¤íŒ¨", ex);
                    Throwable cause = ex.getCause();
                    String errorMessage = (cause != null) ? cause.getMessage() : ex.getMessage();
                    return ResponseEntity.internalServerError().body("Failed to start embedding process: " + errorMessage);
                });
    }

    /**
     * ê¸°ì¡´ ì„ë² ë”©ì„ ëª¨ë‘ ì‚­ì œí•˜ê³ , ì£¼ì–´ì§„ í…ìŠ¤íŠ¸ë¡œ ë²¡í„° ì €ì¥ì†Œë¥¼ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì¬ì„¤ì •í•©ë‹ˆë‹¤.
     * ì´ ë©”ì„œë“œëŠ” ìš”ì²­ì„ ì¦‰ì‹œ ìˆ˜ë½í•˜ê³  ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì‘ì—…ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
     *
     * @param request ì¬ì„¤ì •ì— ì‚¬ìš©í•  ìƒˆë¡œìš´ í…ìŠ¤íŠ¸ë¥¼ í¬í•¨í•˜ëŠ” ìš”ì²­ DTO
     * @return ì‘ì—…ì˜ ë¹„ë™ê¸° ì‹¤í–‰ ê²°ê³¼ë¥¼ ë‹´ì€ CompletableFuture<ResponseEntity>
     */
    @PostMapping("/embeddings/reset")
    public CompletableFuture<ResponseEntity<String>> resetAndEmbed(@RequestBody EmbeddingRequest request) { // @Valid ì¶”ê°€
        return embeddingService.resetAndEmbed(request.getText())
                // ì €ì¥ì†Œ ì¬ì„¤ì • ë° ì„ë² ë”© ì‘ì—…ì´ ì„±ê³µì ìœ¼ë¡œ ì‹œì‘ë˜ë©´ 200 OK ì‘ë‹µì„ ë°˜í™˜í•©ë‹ˆë‹¤.
                .thenApply(v -> ResponseEntity.ok("Embedding store reset and new text embedding process started successfully."))
                // ì‘ì—… ì¤‘ ì˜ˆì™¸ ë°œìƒ ì‹œ 500 Internal Server Error ì‘ë‹µì„ ë°˜í™˜í•©ë‹ˆë‹¤.
                .exceptionally(ex -> {
                    log.error("resetAndEmbed ì‘ì—… ì‹¤í–‰ ì‹¤íŒ¨", ex);
                    Throwable cause = ex.getCause();
                    String errorMessage = (cause != null) ? cause.getMessage() : ex.getMessage();
                    return ResponseEntity.internalServerError().body("Failed to start reset and embedding process: " + errorMessage);
                });
    }
}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\entity\AiChat.java`

```java
package com.codehows.taelimbe.ai.entity;

import com.codehows.taelimbe.ai.constant.SenderType;
import com.codehows.taelimbe.user.entity.User;
import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "ai_chat")
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Builder
public class AiChat {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ai_chat_id")
    private Long aiChatId;

    @Column(name = "conversation_id", length = 50, nullable = false)
    private String conversationId;

    @Enumerated(EnumType.STRING)
    @Column(name = "sender_type", nullable = false)
    private SenderType senderType;

    @Column(name = "raw_message", columnDefinition = "LONGTEXT", nullable = false)
    private String rawMessage;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "message_index", nullable = false)
    private Long messageIndex;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    // ì—”í‹°í‹° ìƒì„± ì‹œ ìë™ìœ¼ë¡œ ìƒì„± ì‹œê°„ ì„¤ì •
    @PrePersist
    protected void onCreate() {
        if (this.createdAt == null) {
            this.createdAt = LocalDateTime.now();
        }
    }
}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\dto\AiChatDTO.java`

```java
package com.codehows.taelimbe.ai.dto;

import com.codehows.taelimbe.ai.constant.SenderType;
import com.codehows.taelimbe.ai.entity.AiChat;
import lombok.*;

import java.time.LocalDateTime;

@Builder
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class AiChatDTO {

    private Long aiChatId;
    private String conversationId;
    private SenderType senderType;
    private String rawMessage;
    private LocalDateTime createdAt;
    private Long messageIndex;
    private Long userId;
    private String userName;

    /**
     * Entityë¥¼ DTOë¡œ ë³€í™˜
     */
    public static AiChatDTO from(AiChat aiChat) {
        return AiChatDTO.builder()
                .aiChatId(aiChat.getAiChatId())
                .conversationId(aiChat.getConversationId())
                .senderType(aiChat.getSenderType())
                .rawMessage(aiChat.getRawMessage())
                .createdAt(aiChat.getCreatedAt())
                .messageIndex(aiChat.getMessageIndex())
                .userId(aiChat.getUser() != null ? aiChat.getUser().getUserId() : null)
                .userName(aiChat.getUser() != null ? aiChat.getUser().getName() : null)
                .build();
    }
}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\constant\SenderType.java`

```java
package com.codehows.taelimbe.ai.constant;

/**
 * AI ì±„íŒ…ì—ì„œ ë©”ì‹œì§€ë¥¼ ë³´ë‚¸ ì£¼ì²´ë¥¼ ë‚˜íƒ€ë‚´ëŠ” Enum
 * USER: ì‹¤ì œ ì‚¬ìš©ì(Role.USER, Role.MANAGER, Role.ADMIN ëª¨ë‘ í¬í•¨)ê°€ ë³´ë‚¸ ë©”ì‹œì§€
 * AI: AI ì—ì´ì „íŠ¸(Gemini)ê°€ ë³´ë‚¸ ì‘ë‹µ
 */
public enum SenderType {
    USER("ì‚¬ìš©ì"),
    AI("AI");

    private final String description;

    SenderType(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }
}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\config\AsyncConfig.java`

```java
package com.codehows.taelimbe.ai.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.task.TaskExecutor;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
import org.springframework.security.task.DelegatingSecurityContextAsyncTaskExecutor;

import java.util.concurrent.ThreadPoolExecutor;

/**
 * ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ë¹„ë™ê¸° ì‘ì—…ì„ ìœ„í•œ ì¤‘ì•™ ìŠ¤ë ˆë“œ í’€ì„ ì„¤ì •í•˜ëŠ” í´ë˜ìŠ¤ì…ë‹ˆë‹¤.
 * `@Configuration` ì–´ë…¸í…Œì´ì…˜ì€ ì´ í´ë˜ìŠ¤ê°€ Springì˜ ì„¤ì • í´ë˜ìŠ¤ì„ì„ ë‚˜íƒ€ë‚´ë©°,
 * Spring ì»¨í…Œì´ë„ˆê°€ ì´ í´ë˜ìŠ¤ì—ì„œ ì •ì˜ëœ `@Bean` ë©”ì„œë“œë¥¼ í†µí•´ ë¹ˆì„ ìƒì„±í•˜ë„ë¡ ì§€ì‹œí•©ë‹ˆë‹¤.
 */
@Configuration
@EnableAsync
public class AsyncConfig {

    /**
     * ë¹„ë™ê¸° ì‘ì—…ì„ ì²˜ë¦¬í•˜ê¸° ìœ„í•œ `TaskExecutor` Beanì„ ìƒì„±í•©ë‹ˆë‹¤.
     * ì´ `TaskExecutor`ëŠ” `@Async` ì–´ë…¸í…Œì´ì…˜ì´ ë¶™ì€ ë©”ì„œë“œë¥¼ ì‹¤í–‰í•˜ëŠ” ë° ì‚¬ìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
     * `TaskDecorator`ë¥¼ ì‚¬ìš©í•˜ì—¬ `UserContextHolder`ì˜ ì»¨í…ìŠ¤íŠ¸ë¥¼ ë¹„ë™ê¸° ìŠ¤ë ˆë“œë¡œ ì „íŒŒí•©ë‹ˆë‹¤.
     *
     * @return ì„¤ì •ì´ ì™„ë£Œëœ `ThreadPoolTaskExecutor` ì¸ìŠ¤í„´ìŠ¤
     */
    @Bean("taskExecutor")
    public TaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        // ì½”ì–´ ìŠ¤ë ˆë“œ í’€ì˜ í¬ê¸°ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤. ì´ ìˆ˜ë§Œí¼ì˜ ìŠ¤ë ˆë“œê°€ í•­ìƒ ìœ ì§€ë©ë‹ˆë‹¤.
        executor.setCorePoolSize(10);
        // ìµœëŒ€ ìŠ¤ë ˆë“œ í’€ì˜ í¬ê¸°ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤. ì½”ì–´ í’€ì´ ê°€ë“ ì°¨ê³  íë„ ê°€ë“ ì°¼ì„ ë•Œ ìƒì„±ë  ìˆ˜ ìˆëŠ” ìµœëŒ€ ìŠ¤ë ˆë“œ ìˆ˜ì…ë‹ˆë‹¤.
        executor.setMaxPoolSize(20);
        // ì‘ì—… íì˜ ìš©ëŸ‰ì„ ì„¤ì •í•©ë‹ˆë‹¤. ì½”ì–´ í’€ì˜ ìŠ¤ë ˆë“œê°€ ëª¨ë‘ ì‚¬ìš© ì¤‘ì¼ ë•Œ ì‘ì—…ì´ ëŒ€ê¸°í•˜ëŠ” ê³µê°„ì…ë‹ˆë‹¤.
        executor.setQueueCapacity(50);
        // ê±°ë¶€ ì •ì±…ì„ ì„¤ì •í•©ë‹ˆë‹¤. íê¹Œì§€ ê°€ë“ ì°¼ì„ ë•Œ ìƒˆë¡œìš´ ì‘ì—…ì´ ë“¤ì–´ì˜¤ë©´ í˜¸ì¶œì ìŠ¤ë ˆë“œê°€ ì§ì ‘ ì‘ì—…ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        // ìƒì„±ë˜ëŠ” ìŠ¤ë ˆë“œì˜ ì´ë¦„ ì ‘ë‘ì‚¬ë¥¼ ì„¤ì •í•˜ì—¬ ë¡œê·¸ì—ì„œ ìŠ¤ë ˆë“œë¥¼ ì‰½ê²Œ ì‹ë³„í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.
        executor.setThreadNamePrefix("async-task-");
        // Executorë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
        executor.initialize();

        return new DelegatingSecurityContextAsyncTaskExecutor(executor);
    }
}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\controller\AiReportController.java`

```java
package com.codehows.taelimbe.ai.controller;

import com.codehows.taelimbe.ai.dto.AiReportDTO;
import com.codehows.taelimbe.ai.service.AiReportService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping("")  // /api ì œê±°
@RequiredArgsConstructor
public class AiReportController {

    private final AiReportService aiReportService;

    @GetMapping("/aiReport")  // ì‹¤ì œ ê²½ë¡œ: /aiReport
    @ResponseBody
    public ResponseEntity<List<AiReportDTO>> getAllReports() {
        List<AiReportDTO> reports = aiReportService.getAllReports();
        return ResponseEntity.ok(reports);
    }
}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\dto\AiReportDTO.java`

```java
package com.codehows.taelimbe.ai.dto;

import com.codehows.taelimbe.ai.entity.AiReport;
import lombok.*;

import java.time.LocalDateTime;

@Builder
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class AiReportDTO {

    private Long aiReportId;
    private String conversationId;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private LocalDateTime createdAt;
    private String rawMessage;
    private String rawReport;
    private Long userId;
    private String name; // ìƒˆë¡œ ì¶”ê°€

    public static AiReportDTO from(AiReport aiReport) {
        return AiReportDTO.builder()
                .aiReportId(aiReport.getAiReportId())
                .conversationId(aiReport.getConversationId())
                .startTime(aiReport.getStartTime())
                .endTime(aiReport.getEndTime())
                .createdAt(aiReport.getCreatedAt())
                .rawMessage(aiReport.getRawMessage())
                .rawReport(aiReport.getRawReport())
                .userId(aiReport.getUser() != null ? aiReport.getUser().getUserId() : null)
                .name(aiReport.getUser() != null ? aiReport.getUser().getName() : null)
                .build();
    }
}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\dto\ChatPromptRequest.java`

```java
package com.codehows.taelimbe.ai.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * ì±„íŒ… í”„ë¡¬í”„íŠ¸ ìš”ì²­ì„ ìœ„í•œ ë°ì´í„° ì „ì†¡ ê°ì²´(DTO)ì…ë‹ˆë‹¤.
 * í´ë¼ì´ì–¸íŠ¸ë¡œë¶€í„° AI ì—ì´ì „íŠ¸ì—ê²Œ ì „ë‹¬ë  ë©”ì‹œì§€ì™€ ëŒ€í™” IDë¥¼ ìº¡ìŠí™”í•©ë‹ˆë‹¤.
 *
 * `@Data`ëŠ” Lombok ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ, `@Getter`, `@Setter`, `@EqualsAndHashCode`, `@ToString`ì„ ìë™ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.
 * `@NoArgsConstructor`ëŠ” ì¸ì ì—†ëŠ” ê¸°ë³¸ ìƒì„±ìë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.
 * `@AllArgsConstructor`ëŠ” ëª¨ë“  í•„ë“œë¥¼ ì¸ìë¡œ ë°›ëŠ” ìƒì„±ìë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ChatPromptRequest {
    /**
     * ì‚¬ìš©ìë¡œë¶€í„° AI ì—ì´ì „íŠ¸ì—ê²Œ ì „ë‹¬ë  ë©”ì‹œì§€ì…ë‹ˆë‹¤.
     */
    private String message;
    /**
     * í˜„ì¬ ëŒ€í™”ì˜ ê³ ìœ  IDì…ë‹ˆë‹¤.
     * ì´ IDë¥¼ í†µí•´ AI ì—ì´ì „íŠ¸ê°€ ì´ì „ ëŒ€í™”ì˜ ì»¨í…ìŠ¤íŠ¸ë¥¼ ìœ ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
     */
    private String conversationId;
}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\dto\EmbeddingRequest.java`

```java
package com.codehows.taelimbe.ai.dto;

import lombok.Data;

/**
 * ì„ë² ë”© ìƒì„±ì„ ìœ„í•œ ìš”ì²­ ë°ì´í„° ì „ì†¡ ê°ì²´(DTO)ì…ë‹ˆë‹¤.
 * ì„ë² ë”©ì„ ìƒì„±í•  í…ìŠ¤íŠ¸ ë°ì´í„°ë¥¼ ìº¡ìŠí™”í•©ë‹ˆë‹¤.
 *
 * `@Data`ëŠ” Lombok ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ, `@Getter`, `@Setter`, `@EqualsAndHashCode`, `@ToString`ì„ ìë™ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.
 */
@Data
public class EmbeddingRequest {
    /**
     * ì„ë² ë”©ì„ ìƒì„±í•  ì›ë³¸ í…ìŠ¤íŠ¸ì…ë‹ˆë‹¤.
     */
    private String text;
}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\entity\AiReport.java`

```java
package com.codehows.taelimbe.ai.entity;

import com.codehows.taelimbe.user.entity.User;
import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "ai_report")
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Builder
public class AiReport {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ai_report_id")
    private Long aiReportId;

    @Column(name = "conversation_id", length = 10)
    private String conversationId;

    @Column(name = "start_time")
    private LocalDateTime startTime;

    @Column(name = "end_time")
    private LocalDateTime endTime;

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "raw_message", columnDefinition = "TEXT")
    private String rawMessage;

    @Column(name = "raw_report", columnDefinition = "TEXT")
    private String rawReport;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;

}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\repository\AiReportRepository.java`

```java
package com.codehows.taelimbe.ai.repository;

import com.codehows.taelimbe.ai.entity.AiReport;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface AiReportRepository extends JpaRepository<AiReport, Long> {

    // íŠ¹ì • Userë¡œ ì¡°íšŒ
    List<AiReport> findByUser_UserId(Long userId);

    // íŠ¹ì • Storeì˜ ëª¨ë“  ë¦¬í¬íŠ¸ ì¡°íšŒ (ìµœì‹ ìˆœ)
    @Query("SELECT a FROM AiReport a WHERE a.user.store.storeId = :storeId ORDER BY a.createdAt DESC")
    List<AiReport> findByStoreIdOrderByCreatedAtDesc(@Param("storeId") Long storeId);

    // ëª¨ë“  ë¦¬í¬íŠ¸ ì¡°íšŒ (ADMINìš© - ìµœì‹ ìˆœ)
    List<AiReport> findAllByOrderByCreatedAtDesc();
}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\ai\service\AiReportService.java`

```java
package com.codehows.taelimbe.ai.service;

import com.codehows.taelimbe.ai.dto.AiReportDTO;
import com.codehows.taelimbe.ai.repository.AiReportRepository;
import com.codehows.taelimbe.user.constant.Role;
import com.codehows.taelimbe.user.entity.User;
import com.codehows.taelimbe.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class AiReportService {

    private final AiReportRepository aiReportRepository;
    private final UserRepository userRepository;

    // í˜„ì¬ ë¡œê·¸ì¸í•œ ìœ ì € ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    private User getCurrentUser() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String username = authentication.getName();
        return userRepository.findById(username)
                .orElseThrow(() -> new RuntimeException("ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"));
    }

    // ì „ì²´ ë¦¬í¬íŠ¸ ì¡°íšŒ (ê¶Œí•œì— ë”°ë¼ í•„í„°ë§)
    public List<AiReportDTO> getAllReports() {
        User currentUser = getCurrentUser();

        // ADMIN: ëª¨ë“  ë¦¬í¬íŠ¸ ì¡°íšŒ
        if (currentUser.getRole() == Role.ADMIN) {
            return aiReportRepository.findAllByOrderByCreatedAtDesc()
                    .stream()
                    .map(AiReportDTO::from)
                    .collect(Collectors.toList());
        }

        // MANAGER, EMPLOYEE: ìê¸° ë§¤ì¥ ë¦¬í¬íŠ¸ë§Œ ì¡°íšŒ
        Long storeId = currentUser.getStore().getStoreId();
        return aiReportRepository.findByStoreIdOrderByCreatedAtDesc(storeId)
                .stream()
                .map(AiReportDTO::from)
                .collect(Collectors.toList());
    }
}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\user\config\JwtFilter.java`

```java
package com.codehows.taelimbe.user.config;

import com.codehows.taelimbe.user.service.JwtService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.Servlet;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpHeaders;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Collections;

@Component
@RequiredArgsConstructor
public class JwtFilter extends OncePerRequestFilter
{
    private final JwtService jwtService;
    private final Servlet servlet;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {

        // OPTIONS ìš”ì²­(Preflight)ì€ JWT ê²€ì¦ ì—†ì´ ë°”ë¡œ í†µê³¼
        if ("OPTIONS".equalsIgnoreCase(request.getMethod())) {
            filterChain.doFilter(request, response);
            return;
        }

        // í•„í„° ==> ìš”ì²­, ì‘ë‹µì„ ì¤‘ê°„ì—ì„œ ê°€ë¡œì±ˆ ë‹¤ìŒ ==> í•„ìš”í•œ ë™ì‘ì„ ìˆ˜í–‰
        // 1. ìš”ì²­ í—¤ë” (Authorization)ì—ì„œ JWT í† í°ì„ êº¼ëƒ„
        String jwtToken = request.getHeader(HttpHeaders.AUTHORIZATION);
        System.out.println("ğŸ“Œ [JWT FILTER] URI = " + request.getRequestURI() + " | Authorization = " + jwtToken);
        if (jwtToken != null)
        {
            // 2. êº¼ë‚¸ í† í°ì—ì„œ ìœ ì € ì •ë³´ ì¶”ì¶œ
            String id = jwtService.parseToken(request);

            // 2) userId(claim) ì¶”ì¶œ
            Long userId = jwtService.extractUserId(jwtToken);

            // 3. ì¶”ì¶œëœ ìœ ì € ì •ë³´ë¡œ Authentication ì„ ë§Œë“¤ì–´ì„œ SecurityContextì— set
            if(id != null)
            {
                Authentication authentication =
                        new UsernamePasswordAuthenticationToken(id, null, Collections.emptyList());
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }

            // Controller ì—ì„œ userId ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ì €ì¥
            request.setAttribute("userId", userId);

        }
        // ë§ˆì§€ë§‰ì— ë‹¤ìŒ í•„í„°ë¥¼ í˜¸ì¶œ
        filterChain.doFilter(request, response);
    }
}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\user\config\SecurityConfig.java`

```java
package com.codehows.taelimbe.user.config;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.List;

@Configuration
@RequiredArgsConstructor
public class SecurityConfig {
    private final AuthEntryPoint authEntryPoint;
    private final JwtFilter jwtFilter;
    private final UserDetailsService userDetailsService;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
                .csrf(csrf -> csrf.disable())
                .sessionManagement
                        ((session) -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/login").permitAll()
                        .anyRequest().permitAll()) //ë‚˜ì¤‘ì— ê¼­ ì§€ìš°ê¸°
                        //.anyRequest().authenticated())
                .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling((ex) -> ex.authenticationEntryPoint(authEntryPoint));
        return http.build();
    }


    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();   //ë¹„ë°€ë²ˆí˜¸ ì•”í˜¸í™”
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception
    {
        return authConfig.getAuthenticationManager();
    }
}

```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\user\service\JwtService.java`

```java
package com.codehows.taelimbe.user.service;

import io.jsonwebtoken.JwtParser;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpHeaders;
import org.springframework.stereotype.Service;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;

@Service
public class JwtService {

    // ì„œë²„ì™€ í´ë¼ì´ì–¸íŠ¸ê°€ ì£¼ê³  ë°›ëŠ” í† í° ==> HTTP Header ë‚´ Authorization í—¤ë”ê°’ì— ì €ì¥
    // ì˜ˆ) Authorization Bearer <í† í°ê°’>
    private static final String PREFIX = "Bearer ";

    private final long expirationTime;
    private final SecretKey signingKey;

    // ìƒì„±ìë¥¼ í†µí•´ ê³ ì • í‚¤ ì£¼ì…
    public JwtService(
            @Value("${jwt.secret-key}") String secretKeyString,
            @Value("${jwt.expiration}") long expirationTime) {
        // ê³ ì •ëœ ì‹œí¬ë¦¿ í‚¤ë¥¼ SecretKey ê°ì²´ë¡œ ë³€í™˜
        this.signingKey = Keys.hmacShaKeyFor(secretKeyString.getBytes(StandardCharsets.UTF_8));
        this.expirationTime = expirationTime;
    }

    // loginId(ID)ë¥¼ ë°›ì•„ì„œ JWT ìƒì„±
    public String generateToken(String username, Long userId) {
        return Jwts.builder()
                .setSubject(username)
                .claim("userId", userId)   // userId í¬í•¨!
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + expirationTime)) // â† ìˆ˜ì •
                .signWith(signingKey, SignatureAlgorithm.HS256) // â† ìˆ˜ì •
                .compact();
    }

    public Long extractUserId(String token) {
        try {
            JwtParser parser = Jwts.parserBuilder()
                    .setSigningKey(signingKey)
                    .build();

            return parser.parseClaimsJws(token.replace("Bearer ", ""))
                    .getBody()
                    .get("userId", Long.class);
        } catch (Exception e) {
            return null;
        }
    }




    // JWTë¥¼ ë°›ì•„ì„œ id(ID)ë¥¼ ë°˜í™˜
    public String parseToken(HttpServletRequest request) {
        // ìš”ì²­ í—¤ë”ì—ì„œ Authorization í—¤ë”ê°’ì„ ê°€ì ¸ì˜´
        // ì˜ˆ) header = Bearer <í† í°ê°’>
        String header = request.getHeader(HttpHeaders.AUTHORIZATION);
        if (header != null && header.startsWith(PREFIX)) {
            try {
                JwtParser parser = Jwts.parserBuilder()
                        .setSigningKey(signingKey)
                        .build();

                String id = parser.parseClaimsJws(header.replace(PREFIX, ""))
                        .getBody()
                        .getSubject();

                return id;
            } catch (Exception e) {
                // í† í° íŒŒì‹± ì‹¤íŒ¨ ì‹œ null ë°˜í™˜
                return null;
            }
        }
        return null;
    }
}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\user\controller\LoginController.java`

```java
package com.codehows.taelimbe.user.controller;

import com.codehows.taelimbe.user.constant.Role;
import com.codehows.taelimbe.user.dto.LoginDTO;
import com.codehows.taelimbe.user.dto.LoginResponseDTO;
import com.codehows.taelimbe.user.entity.User;
import com.codehows.taelimbe.user.service.JwtService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.security.authentication.AuthenticationManager;

@Controller
@RequiredArgsConstructor
public class LoginController {

    private final JwtService jwtService;
    private final AuthenticationManager authenticationManager;

    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody LoginDTO loginDto) {
        UsernamePasswordAuthenticationToken token =
                new UsernamePasswordAuthenticationToken(loginDto.getId(), loginDto.getPw());

        Authentication authentication = authenticationManager.authenticate(token);

        // 1. ì¸ì¦ëœ ì‚¬ìš©ìì˜ ê¶Œí•œì„ í™•ì¸í•©ë‹ˆë‹¤. ADMIN: 3, MANAGER: 2, USER: 1
        String roleName = authentication.getAuthorities().stream()
                .map(a -> a.getAuthority().replace("ROLE_", "")) // ADMIN, MANAGER, USER
                .findFirst()
                .orElse("USER"); // ê¸°ë³¸ê°’ USER

        // enumìœ¼ë¡œ ë³€í™˜ ==> ìˆ«ì level êº¼ë‚´ê¸°
        int roleLevel = Role.valueOf(roleName).getLevel();

        // 2. ì¸ì¦ëœ ì‚¬ìš©ì ê°ì²´ì—ì„œ storeId, userIdë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤.
        Long storeId = null, userId = null;
        Object principal = authentication.getPrincipal();

        if (principal instanceof User) {
            User authenticatedUser = (User) principal;

            userId = authenticatedUser.getUserId();
            System.out.println("userId :  " + userId);

            // User ì—”í‹°í‹°ëŠ” Store ì—”í‹°í‹°ë¥¼ ê°€ì§€ê³  ìˆìœ¼ë¯€ë¡œ, Storeì—ì„œ storeIdë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
            if (authenticatedUser.getStore() != null) {
                storeId = authenticatedUser.getStore().getStoreId();
            }
        }
        // storeIdê°€ nullì´ë©´ 0L ë˜ëŠ” ì ì ˆí•œ ê¸°ë³¸ê°’ìœ¼ë¡œ ì„¤ì • (LoinReponseDTOì— ë§ê²Œ Integer íƒ€ì… ìš”êµ¬ì— ë§ì¶¤)
        Long finalStoreId = storeId != null ? storeId : 0L;

        // 3. JWT í† í°ì„ ë°œê¸‰í•©ë‹ˆë‹¤.
        String jwtToken = jwtService.generateToken(authentication.getName(), userId);


        // 4. ì‘ë‹µì— í¬í•¨í•  DTOë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
        LoginResponseDTO response = new LoginResponseDTO(jwtToken, roleLevel, finalStoreId, userId);

        return ResponseEntity.ok()
                .body(response);
//                  .header(HttpHeaders.AUTHORIZATION, "Bearer " + jwtToken)
//                   .build();
    }
}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\user\dto\LoginResponseDTO.java`

```java
package com.codehows.taelimbe.user.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;

@Getter
@Builder
@AllArgsConstructor
public class LoginResponseDTO
{
    private String jwtToken;

    private Integer roleLevel;

    private Long storeId;

    private Long userId;
}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\user\config\AuthEntryPoint.java`

```java
package com.codehows.taelimbe.user.config;

import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.io.PrintWriter;

@Component
public class AuthEntryPoint implements AuthenticationEntryPoint
{
    @Override
    public void commence(HttpServletRequest request,
                         HttpServletResponse response,
                         AuthenticationException authException) throws IOException, ServletException
    {
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);  // SC_UNAUTHORIZED ==> 401 ì—ëŸ¬(ì¸ì¦ë¶ˆê°€)
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding("UTF-8");
        PrintWriter out = response.getWriter();
        out.println("ì¸ì¦ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. : " + authException.getMessage());
    }
}

```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\user\constant\Role.java`

```java
package com.codehows.taelimbe.user.constant;

public enum Role {
    USER(1),
    MANAGER(2),
    ADMIN(3);

    private final int level;

    Role(int level) {
        this.level = level;
    }

    public int getLevel() {
        return level;
    }
}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\user\controller\UserController.java`

```java
package com.codehows.taelimbe.user.controller;

import com.codehows.taelimbe.user.dto.UserDTO;
import com.codehows.taelimbe.store.entity.Store;
import com.codehows.taelimbe.user.entity.User;
import com.codehows.taelimbe.store.repository.StoreRepository;
import com.codehows.taelimbe.user.repository.UserRepository;
import com.codehows.taelimbe.user.service.UserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/user")
@RequiredArgsConstructor
public class UserController {
    
    private final UserService userService;
    private final PasswordEncoder passwordEncoder;
    private final UserRepository userRepository;
    private final StoreRepository storeRepository;

    @PostMapping("/signup")
    public ResponseEntity<?> signup(@RequestBody @Valid UserDTO userDto) {
        try {
            Store store = storeRepository.findByStoreId(userDto.getStoreId())
                    .orElseThrow(() -> new IllegalArgumentException("ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ë§¤ì¥ì…ë‹ˆë‹¤."));

            User user = User.createUser(userDto, passwordEncoder, store);
            userService.saveUser(user);
            return ResponseEntity.ok("íšŒì›ê°€ì… ì„±ê³µ");
        } catch (IllegalStateException e) {
            return ResponseEntity.status(HttpStatus.CONFLICT).body(e.getMessage());
        }
    }

    // ì¤‘ë³µí™•ì¸ ëˆŒë €ì„ë•Œ
    @GetMapping("/check_loginid")
    public ResponseEntity<?> checkLoginId(@RequestParam String id) {
        boolean exists = userRepository.existsById(id);
        return ResponseEntity.ok().body(Map.of("exists", exists));
    }

    // ì§ì› ìˆ˜ì •
    @PutMapping("/{userId}")
    @ResponseBody // JSON ì‘ë‹µì„ ìœ„í•´ ì¶”ê°€
    public ResponseEntity<UserDTO> updateStore( // ë©”ì„œë“œ ì´ë¦„ ìˆ˜ì • ë° ResponseEntity<StoreDTO> ë°˜í™˜
                                                 @PathVariable Long userId,
                                                 @RequestBody UserDTO dto
    ) {
        UserDTO updatedDto = userService.updateUser(userId, dto);
        return ResponseEntity.ok(updatedDto);
    }

    // ì§ì› ì‚­ì œ
    @DeleteMapping("/{userId}")
    public ResponseEntity<String> deleteEmployee(@PathVariable Long userId) {
        try {
            // ì„œë¹„ìŠ¤ ê³„ì¸µì— ì‚­ì œ ë¡œì§ ìœ„ì„
            userService.deleteUser(userId);

            // ì„±ê³µì ìœ¼ë¡œ ì‚­ì œë˜ì—ˆìŒì„ ì•Œë¦¬ëŠ” ë©”ì‹œì§€ ë°˜í™˜ (í”„ë¡ íŠ¸ì—”ë“œì—ì„œ alertì— ì‚¬ìš© ê°€ëŠ¥)
            return ResponseEntity.ok("ì§ì›ì´ ì„±ê³µì ìœ¼ë¡œ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.");

            // ë˜ëŠ” ë°ì´í„° ë°˜í™˜ ì—†ì´ 204 No Content ë°˜í™˜
            // return ResponseEntity.noContent().build();

        } catch (IllegalArgumentException e) {
            // ì§ì›ì„ ì°¾ì„ ìˆ˜ ì—†ì„ ë•Œ (ì˜ˆ: userIdê°€ ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš°)
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        } catch (Exception e) {
            // ê·¸ ì™¸ ì„œë²„ ì˜¤ë¥˜
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("ì§ì› ì‚­ì œ ì¤‘ ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
        }
    }
}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\user\dto\LoginDTO.java`

```java
package com.codehows.taelimbe.user.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.Data;

@Data
public class LoginDTO
{
    @NotBlank(message = "ì•„ì´ë””ë¥¼ ì…ë ¥í•˜ì„¸ìš”.")
    private  String id;

    @NotBlank(message = "ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”.")
    private String pw ;
}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\user\dto\UserDTO.java`

```java
package com.codehows.taelimbe.user.dto;

import com.codehows.taelimbe.user.constant.Role;
import com.codehows.taelimbe.user.entity.User;
import jakarta.validation.constraints.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.validator.constraints.Length;

import java.util.Base64;

@Getter
@Setter
public class UserDTO {

    private Long userId;
    @NotBlank(message = "IDëŠ” í•„ìˆ˜ ì…ë ¥ ê°’ì…ë‹ˆë‹¤.")
    private String id;

    // ìˆ˜ì •ì‹œ ë¹„ë°€ë²ˆí˜¸ ì•ˆë³€ê²½í•˜ë©´ nullë¡œ ë³´ë‚´ì•¼í•´ì„œ NotNull ì‚¬ìš©X
    @Length(min=8, max=16, message = "ë¹„ë°€ë²ˆí˜¸ëŠ” 8ì ì´ìƒ,  16ì ì´í•˜ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.")
    private String pw;

    @NotBlank(message = "ì´ë¦„ì€ í•„ìˆ˜ ì…ë ¥ ê°’ì…ë‹ˆë‹¤.")
    private String name;

    @NotNull(message = "ì „í™” ë²ˆí˜¸ëŠ” í•„ìˆ˜ ì…ë ¥ ê°’ì…ë‹ˆë‹¤.")
    @Pattern(regexp = "^\\d{2,3}-\\d{3,4}-\\d{4}$", message = "ì „í™”ë²ˆí˜¸ëŠ” í•˜ì´í”ˆ(-)ì„ í¬í•¨í•œ ì˜¬ë°”ë¥¸ í˜•ì‹(ì˜ˆ: 010-1234-5678)ìœ¼ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.")
    private String phone;

    @NotEmpty(message = "ì´ë©”ì¼ì€ í•„ìˆ˜ ì…ë ¥ ê°’ì…ë‹ˆë‹¤.")
    @Email(message = "ì´ë©”ì¼ í˜•ì‹ìœ¼ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.")
    private String email;

    @NotNull(message = "ê¶Œí•œì€ í•„ìˆ˜ ì„ íƒ ê°’ì…ë‹ˆë‹¤.")
    private Role role;

    @NotNull(message = "ì—…ì²´ ì„ íƒì€ í•„ìˆ˜ ì„ íƒ ê°’ì…ë‹ˆë‹¤.")
    private Long storeId;

    public static UserDTO from(User user) {
        UserDTO dto = new UserDTO();
        dto.setUserId(user.getUserId());
        dto.setId(user.getId());
        dto.setPw(user.getPw());
        dto.setName(user.getName());
        dto.setPhone(user.getPhone());
        dto.setEmail(user.getEmail());
        dto.setRole(user.getRole());
        dto.setStoreId(user.getStore().getStoreId());
        return dto;
    }

    private static String decode(String encoded) {
        if (encoded == null) return null;
        return new String(Base64.getDecoder().decode(encoded));
    }

}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\user\dto\UserResponseDTO.java`

```java
package com.codehows.taelimbe.user.dto;

import com.codehows.taelimbe.user.constant.Role;
import com.codehows.taelimbe.user.entity.User;
import lombok.Builder;
import lombok.Getter;

@Getter
@Builder
public class UserResponseDTO {

    private Long userId;
    private String id;
    private String name;
    private String phone;
    private String email;
    private Role role;
    private Long storeId;

    public static UserResponseDTO fromEntity(User user) {
        return UserResponseDTO.builder()
                .userId(user.getUserId())
                .id(user.getId())
                .name(user.getName())
                .phone(user.getPhone())
                .email(user.getEmail())
                .role(user.getRole())
                // store ê°ì²´ì—ì„œ storeIdë¥¼ ì¶”ì¶œí•˜ì—¬ DTOì— ì§ì ‘ ë§¤í•‘
                .storeId(user.getStore() != null ? user.getStore().getStoreId() : null)
                .build();
    }

}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\user\entity\User.java`

```java
package com.codehows.taelimbe.user.entity;

import com.codehows.taelimbe.store.entity.Store;
import com.codehows.taelimbe.user.constant.Role;
import com.codehows.taelimbe.user.dto.UserDTO;
import jakarta.persistence.*;
import lombok.*;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.password.PasswordEncoder;
import java.util.Collection;
import java.util.List;

@Entity
@Table(name = "user")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User implements UserDetails {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "user_id")
    private Long userId;

    @Column(name = "id", length = 20, unique = true, nullable = false)
    private String id;

    @Column(name = "pw", length = 255, nullable = false)
    private String pw;

    @Column(name = "name", length = 20, nullable = false)
    private String name;

    @Column(name = "phone", length = 20, nullable = false)
    private String phone;

    @Column(name = "email", length = 50, nullable = false)
    private String email;

    @Enumerated(EnumType.STRING)
    @Column(name = "role", nullable = false)
    private Role role;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "store_id")
    private Store store;

    public static User createUser(UserDTO dto, PasswordEncoder encoder, Store store) {
        return User.builder()
                .id(dto.getId())
                .pw(encoder.encode(dto.getPw()))
                .name(dto.getName())
                .phone(dto.getPhone())
                .email(dto.getEmail())
                .role(dto.getRole())
                .store(store)
                .build();
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return List.of(new SimpleGrantedAuthority("ROLE_" + this.role.toString()));
    }

    @Override
    public String getPassword() {
        return this.pw;
    }

    @Override
    public String getUsername() {
        return this.id;
    }

    @Override
    public boolean isAccountNonExpired() { return true; }

    @Override
    public boolean isAccountNonLocked() { return true; }

    @Override
    public boolean isCredentialsNonExpired() { return true; }

    @Override
    public boolean isEnabled() { return true; }
}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\user\repository\UserRepository.java`

```java
package com.codehows.taelimbe.user.repository;

import com.codehows.taelimbe.user.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;

import java.util.List;
import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {

    boolean existsById(String id);
    Optional<User> findById(String id);

    // ğŸ’¡ Fetch Joinì„ ì‚¬ìš©í•˜ì—¬ Userë¥¼ ë¡œë“œí•  ë•Œ Store ì •ë³´ë„ ì¦‰ì‹œ ë¡œë“œí•©ë‹ˆë‹¤.
    @Query("SELECT u FROM User u JOIN FETCH u.store WHERE u.id = :id")
    Optional<User> findByIdWithStore(String id);

    List<User> findByStore_StoreId(Long storeId);

}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\user\service\CustomUserDetailsService.java`

```java
package com.codehows.taelimbe.user.service;

import com.codehows.taelimbe.user.entity.User;
import com.codehows.taelimbe.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;


@Service
@RequiredArgsConstructor
public class CustomUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    @Transactional(readOnly = true)
    public UserDetails loadUserByUsername(String id) throws UsernameNotFoundException {
        // username = ì‚¬ìš©ìê°€ ì…ë ¥í•œ loginId (ì˜ˆ: "user01")
        User user = userRepository.findByIdWithStore(id)
                .orElseThrow(() -> new UsernameNotFoundException("ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: " + id));

        return user;
    }

}
```

# `C:\tealim-be\src\main\java\com\codehows\taelimbe\user\service\UserService.java`

```java
package com.codehows.taelimbe.user.service;

import com.codehows.taelimbe.store.entity.Store;
import com.codehows.taelimbe.store.repository.StoreRepository;
import com.codehows.taelimbe.user.dto.UserDTO;
import com.codehows.taelimbe.user.entity.User;
import com.codehows.taelimbe.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
@Transactional
public class UserService {

    private final UserRepository userRepository;
    private final StoreRepository storeRepository;
    private final PasswordEncoder passwordEncoder;

    public void saveUser(User user){
        validateDuplicateUser(user);
        userRepository.save(user);
    }

    public void validateDuplicateUser(User user)
    {
        boolean loginIdExists = userRepository.existsById(user.getId());
        if (loginIdExists)
        {
            throw new IllegalStateException ("ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ì•„ì´ë””ì…ë‹ˆë‹¤.");
        }
    }

    @Transactional
    public UserDTO updateUser(Long userId, UserDTO dto) {
        // 1. ê¸°ì¡´ User ì—”í‹°í‹° ì¡°íšŒ
        User target = userRepository.findById(userId)
                .orElseThrow(() -> new IllegalArgumentException(
                        "ì—…ë°ì´íŠ¸ ëŒ€ìƒ ì§ì›(UserId: " + userId + ")ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
                ));

        // 2. ì•„ì´ë”” ë³€ê²½ (ì¤‘ë³µ í™•ì¸)
        if (dto.getId() != null && !dto.getId().equals(target.getId())) {
            // ì¤‘ë³µ í™•ì¸
            if (userRepository.existsById(dto.getId())) {
                throw new IllegalStateException("ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ì•„ì´ë””ì…ë‹ˆë‹¤.");
            }
            target.setId(dto.getId());
        }

        // 3. ë¹„ë°€ë²ˆí˜¸ ë³€ê²½ (ì…ë ¥ëœ ê²½ìš°ë§Œ)
        if (dto.getPw() != null && !dto.getPw().isEmpty()) {
            String encodedPassword = passwordEncoder.encode(dto.getPw());
            target.setPw(encodedPassword);
        }

        // 4. ì´ë¦„, ì „í™”ë²ˆí˜¸, ì´ë©”ì¼ ì—…ë°ì´íŠ¸
        if (dto.getName() != null && !dto.getName().isEmpty()) {
            target.setName(dto.getName());
        }

        if (dto.getPhone() != null && !dto.getPhone().isEmpty()) {
            target.setPhone(dto.getPhone());
        }

        if (dto.getEmail() != null && !dto.getEmail().isEmpty()) {
            target.setEmail(dto.getEmail());
        }

        // 5. Store (ë§¤ì¥) ì—…ë°ì´íŠ¸ ì²˜ë¦¬
        if (dto.getStoreId() != null) {
            Store store = storeRepository.findById(dto.getStoreId())
                    .orElseThrow(() -> new IllegalArgumentException(
                            "ë§¤ì¥(StoreId: " + dto.getStoreId() + ")ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
                    ));
            target.setStore(store);
        }

        // 6. Role (ê¶Œí•œ) ì—…ë°ì´íŠ¸ ì²˜ë¦¬
        if (dto.getRole() != null) {
            target.setRole(dto.getRole());
        }

        // 7. ì—…ë°ì´íŠ¸ëœ ì—”í‹°í‹° ì €ì¥
        User updated = userRepository.save(target);

        // 8. ì—…ë°ì´íŠ¸ëœ ì—”í‹°í‹°ë¥¼ DTOë¡œ ë³€í™˜í•˜ì—¬ ë°˜í™˜
        return UserDTO.from(updated);
    }

    @Transactional
    public void deleteUser(Long userId) {
        userRepository.findById(userId)
                .ifPresentOrElse(
                        user -> userRepository.delete(user),
                        () -> { throw new IllegalArgumentException("í•´ë‹¹ IDì˜ ì§ì›ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: " + userId); }
                );
    }
}
```