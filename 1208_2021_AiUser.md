## src/main/java/com/codehows/taelimbe/ai/service/AiChatService.java
```java
package com.codehows.taelimbe.ai.service;

import com.codehows.taelimbe.ai.constant.SenderType;
import com.codehows.taelimbe.ai.dto.AiChatDTO;
import com.codehows.taelimbe.ai.entity.AiChat;
import com.codehows.taelimbe.ai.repository.AiChatRepository;
import com.codehows.taelimbe.user.entity.User;
import com.codehows.taelimbe.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Transactional
@Slf4j
public class AiChatService {

    private final AiChatRepository aiChatRepository;
    private final UserRepository userRepository;

    // 현재 로그인한 사용자 정보 가져오기
    private User getCurrentUser() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String username = authentication.getName();
        return userRepository.findById(username)
                .orElseThrow(() -> new RuntimeException("사용자를 찾을 수 없습니다: " + username));
    }

    /**
     * 사용자 메시지 저장
     */
    public AiChat saveUserMessage(String conversationId, String message) {
        User user = getCurrentUser();
        Long nextMessageIndex = aiChatRepository.findMaxMessageIndexByConversationId(conversationId) + 1;

        AiChat userChat = AiChat.builder()
                .conversationId(conversationId)
                .senderType(SenderType.USER)
                .rawMessage(message)
                .messageIndex(nextMessageIndex)
                .user(user)
                .createdAt(LocalDateTime.now())
                .build();

        return aiChatRepository.save(userChat);
    }

    /**
     * AI 응답 메시지 저장
     */
    public AiChat saveAgentMessage(String conversationId, String response) {
        User user = getCurrentUser();
        Long nextMessageIndex = aiChatRepository.findMaxMessageIndexByConversationId(conversationId) + 1;

        AiChat agentChat = AiChat.builder()
                .conversationId(conversationId)
                .senderType(SenderType.AI)
                .rawMessage(response)
                .messageIndex(nextMessageIndex)
                .user(user)
                .createdAt(LocalDateTime.now())
                .build();

        return aiChatRepository.save(agentChat);
    }

    /**
     * 특정 대화의 모든 메시지 조회
     */
    @Transactional(readOnly = true)
    public List<AiChatDTO> getChatHistory(String conversationId) {
        return aiChatRepository.findByConversationIdOrderByMessageIndex(conversationId)
                .stream()
                .map(AiChatDTO::from)
                .collect(Collectors.toList());
    }

    /**
     * 사용자의 대화 목록 조회 (최신순)
     * 각 대화의 첫 번째 메시지를 대화 제목으로 사용
     */
    @Transactional(readOnly = true)
    public List<AiChatDTO> getUserChatList() {
        User user = getCurrentUser();
        List<String> conversationIds = aiChatRepository.findDistinctConversationIdsByUserId(user.getUserId());

        return conversationIds.stream()
                .map(convId -> {
                    List<AiChat> messages = aiChatRepository.findByConversationIdOrderByMessageIndex(convId);
                    if (!messages.isEmpty()) {
                        // 첫 번째 메시지 (사용자의 초기 질문)를 대화 제목으로
                        AiChat firstMessage = messages.stream()
                                .filter(msg -> msg.getSenderType() == SenderType.USER)
                                .findFirst()
                                .orElse(messages.get(0));
                        return AiChatDTO.from(firstMessage);
                    }
                    return null;
                })
                .filter(dto -> dto != null)
                .collect(Collectors.toList());
    }

    /**
     * 특정 매장의 모든 대화 조회 (관리자용)
     */
    @Transactional(readOnly = true)
    public List<AiChatDTO> getStoreChatHistory(Long storeId) {
        return aiChatRepository.findByStoreIdOrderByCreatedAtDesc(storeId)
                .stream()
                .map(AiChatDTO::from)
                .collect(Collectors.toList());
    }

    /**
     * 대화 메시지 삭제 (대화 전체 삭제)
     */
    public void deleteConversation(String conversationId) {
        List<AiChat> chats = aiChatRepository.findByConversationIdOrderByMessageIndex(conversationId);
        aiChatRepository.deleteAll(chats);
        log.info("대화 '{}' 삭제 완료", conversationId);
    }

    /**
     * 특정 메시지 삭제
     */
    public void deleteChatMessage(Long aiChatId) {
        aiChatRepository.deleteById(aiChatId);
        log.info("메시지 '{}' 삭제 완료", aiChatId);
    }
}
```

## src/main/java/com/codehows/taelimbe/ai/entity/AiChat.java
```java
package com.codehows.taelimbe.ai.entity;

import com.codehows.taelimbe.ai.constant.SenderType;
import com.codehows.taelimbe.user.entity.User;
import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "ai_chat")
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Builder
public class AiChat {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ai_chat_id")
    private Long aiChatId;

    @Column(name = "conversation_id", length = 50, nullable = false)
    private String conversationId;

    @Enumerated(EnumType.STRING)
    @Column(name = "sender_type", nullable = false)
    private SenderType senderType;

    @Column(name = "raw_message", columnDefinition = "LONGTEXT", nullable = false)
    private String rawMessage;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "message_index", nullable = false)
    private Long messageIndex;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    // 엔티티 생성 시 자동으로 생성 시간 설정
    @PrePersist
    protected void onCreate() {
        if (this.createdAt == null) {
            this.createdAt = LocalDateTime.now();
        }
    }
}
```

## src/main/java/com/codehows/taelimbe/ai/repository/AiChatRepository.java
```java
package com.codehows.taelimbe.ai.repository;

import com.codehows.taelimbe.ai.entity.AiChat;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface AiChatRepository extends JpaRepository<AiChat, Long> {

    // 특정 대화의 모든 메시지 조회 (메시지 순서대로)
    List<AiChat> findByConversationIdOrderByMessageIndex(String conversationId);

    // 특정 사용자의 모든 대화 조회
    List<AiChat> findByUser_UserIdOrderByCreatedAtDesc(Long userId);

    // 특정 매장의 모든 대화 조회
    @Query("SELECT c FROM AiChat c WHERE c.user.store.storeId = :storeId ORDER BY c.createdAt DESC")
    List<AiChat> findByStoreIdOrderByCreatedAtDesc(@Param("storeId") Long storeId);

    // 특정 대화의 마지막 메시지 인덱스 조회
    @Query("SELECT COALESCE(MAX(c.messageIndex), 0) FROM AiChat c WHERE c.conversationId = :conversationId")
    Long findMaxMessageIndexByConversationId(@Param("conversationId") String conversationId);

    // 특정 대화의 고유한 대화 ID 목록 조회 (최신순)
    @Query("SELECT DISTINCT c.conversationId FROM AiChat c WHERE c.user.userId = :userId ORDER BY c.createdAt DESC")
    List<String> findDistinctConversationIdsByUserId(@Param("userId") Long userId);
}
```

## src/main/java/com/codehows/taelimbe/ai/controller/AiChatController.java
```java
package com.codehows.taelimbe.ai.controller;

import com.codehows.taelimbe.ai.dto.AiChatDTO;
import com.codehows.taelimbe.ai.service.AiChatService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Slf4j
@RestController
@RequestMapping("/api")
@RequiredArgsConstructor
public class AiChatController {

    private final AiChatService aiChatService;
    /**
     * 사용자의 대화 목록 조회 (사이드바에서 사용)
     * 각 대화의 첫 번째 메시지 (사용자 질문)를 제목으로 반환
     */
    @GetMapping("/chat-history")
    public ResponseEntity<List<AiChatDTO>> getChatHistory() {
        List<AiChatDTO> chatList = aiChatService.getUserChatList();
        return ResponseEntity.ok(chatList);
    }

    /**
     * 특정 대화의 메시지 목록 조회
     */
    @GetMapping("/conversation/{conversationId}")
    public ResponseEntity<List<AiChatDTO>> getConversationMessages(
            @PathVariable String conversationId) {
        List<AiChatDTO> messages = aiChatService.getChatHistory(conversationId);
        return ResponseEntity.ok(messages);
    }

    /**
     * 대화 삭제
     */
    @DeleteMapping("/conversation/{conversationId}")
    public ResponseEntity<String> deleteConversation(
            @PathVariable String conversationId) {
        try {
            aiChatService.deleteConversation(conversationId);
            return ResponseEntity.ok("대화가 삭제되었습니다.");
        } catch (Exception e) {
            log.error("대화 삭제 실패: {}", e.getMessage());
            return ResponseEntity.internalServerError()
                    .body("대화 삭제 중 오류가 발생했습니다.");
        }
    }
}
```

## src/main/java/com/codehows/taelimbe/ai/dto/AiChatDTO.java
```java
package com.codehows.taelimbe.ai.dto;

import com.codehows.taelimbe.ai.constant.SenderType;
import com.codehows.taelimbe.ai.entity.AiChat;
import lombok.*;

import java.time.LocalDateTime;

@Builder
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class AiChatDTO {

    private Long aiChatId;
    private String conversationId;
    private SenderType senderType;
    private String rawMessage;
    private LocalDateTime createdAt;
    private Long messageIndex;
    private Long userId;
    private String userName;

    /**
     * Entity를 DTO로 변환
     */
    public static AiChatDTO from(AiChat aiChat) {
        return AiChatDTO.builder()
                .aiChatId(aiChat.getAiChatId())
                .conversationId(aiChat.getConversationId())
                .senderType(aiChat.getSenderType())
                .rawMessage(aiChat.getRawMessage())
                .createdAt(aiChat.getCreatedAt())
                .messageIndex(aiChat.getMessageIndex())
                .userId(aiChat.getUser() != null ? aiChat.getUser().getUserId() : null)
                .userName(aiChat.getUser() != null ? aiChat.getUser().getName() : null)
                .build();
    }
}
```

## src/main/java/com/codehows/taelimbe/ai/constant/SenderType.java
```java
package com.codehows.taelimbe.ai.constant;

/**
 * AI 채팅에서 메시지를 보낸 주체를 나타내는 Enum
 * USER: 실제 사용자(Role.USER, Role.MANAGER, Role.ADMIN 모두 포함)가 보낸 메시지
 * AI: AI 에이전트(Gemini)가 보낸 응답
 */
public enum SenderType {
    USER("사용자"),
    AI("AI");

    private final String description;

    SenderType(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }
}
```

## src/main/java/com/codehows/taelimbe/ai/config/AsyncConfig.java
```java
package com.codehows.taelimbe.ai.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.task.TaskExecutor;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
import org.springframework.security.task.DelegatingSecurityContextAsyncTaskExecutor;

import java.util.concurrent.ThreadPoolExecutor;

/**
 * 애플리케이션의 비동기 작업을 위한 중앙 스레드 풀을 설정하는 클래스입니다.
 * `@Configuration` 어노테이션은 이 클래스가 Spring의 설정 클래스임을 나타내며,
 * Spring 컨테이너가 이 클래스에서 정의된 `@Bean` 메서드를 통해 빈을 생성하도록 지시합니다.
 */
@Configuration
@EnableAsync
public class AsyncConfig {

    /**
     * 비동기 작업을 처리하기 위한 `TaskExecutor` Bean을 생성합니다.
     * 이 `TaskExecutor`는 `@Async` 어노테이션이 붙은 메서드를 실행하는 데 사용될 수 있습니다.
     * `TaskDecorator`를 사용하여 `UserContextHolder`의 컨텍스트를 비동기 스레드로 전파합니다.
     *
     * @return 설정이 완료된 `ThreadPoolTaskExecutor` 인스턴스
     */
    @Bean("taskExecutor")
    public TaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        // 코어 스레드 풀의 크기를 설정합니다. 이 수만큼의 스레드가 항상 유지됩니다.
        executor.setCorePoolSize(10);
        // 최대 스레드 풀의 크기를 설정합니다. 코어 풀이 가득 차고 큐도 가득 찼을 때 생성될 수 있는 최대 스레드 수입니다.
        executor.setMaxPoolSize(20);
        // 작업 큐의 용량을 설정합니다. 코어 풀의 스레드가 모두 사용 중일 때 작업이 대기하는 공간입니다.
        executor.setQueueCapacity(50);
        // 거부 정책을 설정합니다. 큐까지 가득 찼을 때 새로운 작업이 들어오면 호출자 스레드가 직접 작업을 실행합니다.
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        // 생성되는 스레드의 이름 접두사를 설정하여 로그에서 스레드를 쉽게 식별할 수 있도록 합니다.
        executor.setThreadNamePrefix("async-task-");
        // Executor를 초기화합니다.
        executor.initialize();

        return new DelegatingSecurityContextAsyncTaskExecutor(executor);
    }
}
```

## src/main/java/com/codehows/taelimbe/ai/controller/AgentController.java
```java
package com.codehows.taelimbe.ai.controller;

import com.codehows.taelimbe.ai.dto.ChatPromptRequest;
import com.codehows.taelimbe.ai.dto.EmbeddingRequest;
import com.codehows.taelimbe.ai.service.AgentService;
import com.codehows.taelimbe.ai.service.EmbeddingService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.util.concurrent.CompletableFuture;

/**
 * AI 에이전트와의 대화 및 임베딩 관리를 처리하는 API 컨트롤러입니다.
 * `@RestController`는 이 클래스가 RESTful 웹 서비스의 컨트롤러임을 나타내며,
 * 모든 메서드의 반환 값이 HTTP 응답 본문으로 직접 직렬화됨을 의미합니다.
 * `@RequestMapping("/api")`는 이 컨트롤러의 모든 핸들러 메서드가 "/api" 경로 아래에 매핑됨을 지정합니다.
 * `@RequiredArgsConstructor`는 Lombok 어노테이션으로, final 필드에 대한 생성자를 자동으로 생성하여 의존성 주입을 용이하게 합니다.
 * `@Slf4j`는 Lombok 어노테이션으로, 로깅을 위한 `log` 객체를 자동으로 생성합니다.
 */
@RestController
@RequestMapping("/api")
@RequiredArgsConstructor
@Slf4j
public class AgentController {

    // ConversationService를 주입받아 채팅 관련 비즈니스 로직을 위임합니다.
    private final AgentService agentService;
    // 임베딩 관련 비즈니스 로직을 처리하는 서비스를 주입받습니다.
    private final EmbeddingService embeddingService;

    /**
     * 사용자의 메시지를 받아 AI와 대화하고, 응답을 스트리밍으로 반환합니다.
     * `/agent/chat`은 일반적인 대화를, `/agent/report`는 보고서 생성을 위한 특정 프롬프트 처리를 담당합니다.
     * 이 메서드는 실제 채팅 로직을 `conversationService`로 위임합니다.
     *
     * @param chatPromptRequest 사용자 메시지와 대화 ID를 포함하는 요청 DTO
     * @return Server-Sent Events (SSE)를 통해 AI의 응답을 스트리밍하는 SseEmitter
     */
    @PostMapping(value = "/agent/chat", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter chat(
            @RequestBody ChatPromptRequest chatPromptRequest
    ) {
        return agentService.chat(chatPromptRequest);
    }

    @PostMapping(value = "/agent/report", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter report(
            @RequestBody ChatPromptRequest chatPromptRequest
    ) {
        // 채팅 요청 처리를 ConversationService로 위임합니다.
        return agentService.report(chatPromptRequest);
    }

    /**
     * 주어진 텍스트를 비동기적으로 임베딩하여 벡터 저장소에 저장합니다.
     * 이 메서드는 요청을 즉시 수락하고 백그라운드에서 작업을 처리합니다.
     *
     * @param request 임베딩할 텍스트를 포함하는 요청 DTO
     * @return 작업의 비동기 실행 결과를 담은 CompletableFuture<ResponseEntity>
     */
    @PostMapping("/embeddings")
    public CompletableFuture<ResponseEntity<String>> embed(@RequestBody EmbeddingRequest request) { // @Valid 추가
        return embeddingService.embedAndStore(request.getText())
                // 임베딩 및 저장 작업이 성공적으로 시작되면 200 OK 응답을 반환합니다.
                .thenApply(v -> ResponseEntity.ok("Text embedding and storing process started successfully."))
                // 작업 중 예외 발생 시 500 Internal Server Error 응답을 반환합니다.
                .exceptionally(ex -> {
                    log.error("embedAndStore 작업 실행 실패", ex);
                    Throwable cause = ex.getCause();
                    String errorMessage = (cause != null) ? cause.getMessage() : ex.getMessage();
                    return ResponseEntity.internalServerError().body("Failed to start embedding process: " + errorMessage);
                });
    }

    /**
     * 기존 임베딩을 모두 삭제하고, 주어진 텍스트로 벡터 저장소를 비동기적으로 재설정합니다.
     * 이 메서드는 요청을 즉시 수락하고 백그라운드에서 작업을 처리합니다.
     *
     * @param request 재설정에 사용할 새로운 텍스트를 포함하는 요청 DTO
     * @return 작업의 비동기 실행 결과를 담은 CompletableFuture<ResponseEntity>
     */
    @PostMapping("/embeddings/reset")
    public CompletableFuture<ResponseEntity<String>> resetAndEmbed(@RequestBody EmbeddingRequest request) { // @Valid 추가
        return embeddingService.resetAndEmbed(request.getText())
                // 저장소 재설정 및 임베딩 작업이 성공적으로 시작되면 200 OK 응답을 반환합니다.
                .thenApply(v -> ResponseEntity.ok("Embedding store reset and new text embedding process started successfully."))
                // 작업 중 예외 발생 시 500 Internal Server Error 응답을 반환합니다.
                .exceptionally(ex -> {
                    log.error("resetAndEmbed 작업 실행 실패", ex);
                    Throwable cause = ex.getCause();
                    String errorMessage = (cause != null) ? cause.getMessage() : ex.getMessage();
                    return ResponseEntity.internalServerError().body("Failed to start reset and embedding process: " + errorMessage);
                });
    }
}
```

## src/main/java/com/codehows/taelimbe/ai/controller/AiReportController.java
```java
package com.codehows.taelimbe.ai.controller;

import com.codehows.taelimbe.ai.dto.AiReportDTO;
import com.codehows.taelimbe.ai.service.AiReportService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping("")  // /api 제거
@RequiredArgsConstructor
public class AiReportController {

    private final AiReportService aiReportService;

    @GetMapping("/aiReport")  // 실제 경로: /aiReport
    @ResponseBody
    public ResponseEntity<List<AiReportDTO>> getAllReports() {
        List<AiReportDTO> reports = aiReportService.getAllReports();
        return ResponseEntity.ok(reports);
    }
}
```

## src/main/java/com/codehows/taelimbe/ai/dto/AiReportDTO.java
```java
package com.codehows.taelimbe.ai.dto;

import com.codehows.taelimbe.ai.entity.AiReport;
import lombok.*;

import java.time.LocalDateTime;

@Builder
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class AiReportDTO {

    private Long aiReportId;
    private String conversationId;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private LocalDateTime createdAt;
    private String rawMessage;
    private String rawReport;
    private Long userId;
    private String name; // 새로 추가

    public static AiReportDTO from(AiReport aiReport) {
        return AiReportDTO.builder()
                .aiReportId(aiReport.getAiReportId())
                .conversationId(aiReport.getConversationId())
                .startTime(aiReport.getStartTime())
                .endTime(aiReport.getEndTime())
                .createdAt(aiReport.getCreatedAt())
                .rawMessage(aiReport.getRawMessage())
                .rawReport(aiReport.getRawReport())
                .userId(aiReport.getUser() != null ? aiReport.getUser().getUserId() : null)
                .name(aiReport.getUser() != null ? aiReport.getUser().getName() : null)
                .build();
    }
}
```

## src/main/java/com/codehows/taelimbe/ai/dto/ChatPromptRequest.java
```java
package com.codehows.taelimbe.ai.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * 채팅 프롬프트 요청을 위한 데이터 전송 객체(DTO)입니다.
 * 클라이언트로부터 AI 에이전트에게 전달될 메시지와 대화 ID를 캡슐화합니다.
 *
 * `@Data`는 Lombok 어노테이션으로, `@Getter`, `@Setter`, `@EqualsAndHashCode`, `@ToString`을 자동으로 생성합니다.
 * `@NoArgsConstructor`는 인자 없는 기본 생성자를 자동으로 생성합니다.
 * `@AllArgsConstructor`는 모든 필드를 인자로 받는 생성자를 자동으로 생성합니다.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ChatPromptRequest {
    /**
     * 사용자로부터 AI 에이전트에게 전달될 메시지입니다.
     */
    private String message;
    /**
     * 현재 대화의 고유 ID입니다.
     * 이 ID를 통해 AI 에이전트가 이전 대화의 컨텍스트를 유지할 수 있습니다.
     */
    private String conversationId;
}
```

## src/main/java/com/codehows/taelimbe/ai/dto/EmbeddingRequest.java
```java
package com.codehows.taelimbe.ai.dto;

import lombok.Data;

/**
 * 임베딩 생성을 위한 요청 데이터 전송 객체(DTO)입니다.
 * 임베딩을 생성할 텍스트 데이터를 캡슐화합니다.
 *
 * `@Data`는 Lombok 어노테이션으로, `@Getter`, `@Setter`, `@EqualsAndHashCode`, `@ToString`을 자동으로 생성합니다.
 */
@Data
public class EmbeddingRequest {
    /**
     * 임베딩을 생성할 원본 텍스트입니다.
     */
    private String text;
}
```

## src/main/java/com/codehows/taelimbe/ai/entity/AiReport.java
```java
package com.codehows.taelimbe.ai.entity;

import com.codehows.taelimbe.user.entity.User;
import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "ai_report")
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Builder
public class AiReport {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ai_report_id")
    private Long aiReportId;

    @Column(name = "conversation_id", length = 10)
    private String conversationId;

    @Column(name = "start_time")
    private LocalDateTime startTime;

    @Column(name = "end_time")
    private LocalDateTime endTime;

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "raw_message", columnDefinition = "TEXT")
    private String rawMessage;

    @Column(name = "raw_report", columnDefinition = "TEXT")
    private String rawReport;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;

}
```

## src/main/java/com/codehows/taelimbe/ai/repository/AiReportRepository.java
```java
package com.codehows.taelimbe.ai.repository;

import com.codehows.taelimbe.ai.entity.AiReport;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface AiReportRepository extends JpaRepository<AiReport, Long> {

    // 특정 User로 조회
    List<AiReport> findByUser_UserId(Long userId);

    // 특정 Store의 모든 리포트 조회 (최신순)
    @Query("SELECT a FROM AiReport a WHERE a.user.store.storeId = :storeId ORDER BY a.createdAt DESC")
    List<AiReport> findByStoreIdOrderByCreatedAtDesc(@Param("storeId") Long storeId);

    // 모든 리포트 조회 (ADMIN용 - 최신순)
    List<AiReport> findAllByOrderByCreatedAtDesc();
}
```

## src/main/java/com/codehows/taelimbe/ai/service/AgentService.java
```java
package com.codehows.taelimbe.ai.service;

import com.codehows.taelimbe.ai.dto.ChatPromptRequest;
import com.codehows.taelimbe.langchain.Agent;
import dev.langchain4j.model.input.Prompt;
import dev.langchain4j.model.input.PromptTemplate;
import dev.langchain4j.service.TokenStream;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.io.IOException;
import java.util.Map;
import java.util.UUID;

/**
 * AI 에이전트와의 대화 로직을 캡슐화하는 서비스 클래스입니다.
 * `AgentController`의 복잡성을 줄이고, 대화 처리와 관련된 모든 로직을 이곳에서 관리합니다.
 * `@Service` 어노테이션은 이 클래스가 비즈니스 계층의 컴포넌트임을 나타냅니다.
 * `@RequiredArgsConstructor`는 Lombok 어노테이션으로, final 필드에 대한 생성자를 자동으로 생성하여 의존성 주입을 용이하게 합니다.
 * `@Slf4j`는 Lombok 어노테이션으로, 로깅을 위한 `log` 객체를 자동으로 생성합니다.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class AgentService {

    // LangChain4j Agent 인터페이스의 구현체를 주입받습니다.
    @Qualifier("reportAgent")
    private final Agent reportAgent;

    @Qualifier("chatAgent")
    private final Agent chatAgent;

    /**
     * 사용자의 메시지를 받아 AI와 대화하고, 응답을 스트리밍으로 클라이언트에게 전송합니다.
     * 이 메서드는 `SseEmitter`를 사용하여 Server-Sent Events (SSE) 방식으로 실시간 응답을 처리합니다.
     *
     * @param req 사용자 메시지와 대화 ID를 포함하는 요청 DTO
     * @return `SseEmitter` 객체. 클라이언트에게 이벤트를 스트리밍하는 데 사용됩니다.
     */
    public SseEmitter chat(ChatPromptRequest req) {
        SseEmitter emitter = new SseEmitter(Long.MAX_VALUE);
        // 대화 ID가 요청에 포함되어 있지 않다면 새로운 ID를 생성합니다.
        String convId = (req.getConversationId() == null || req.getConversationId().isBlank())
                ? UUID.randomUUID().toString()
                : req.getConversationId();
        createEmitter(emitter, convId, chatAgent, req.getMessage());
        return emitter;
    }

    public SseEmitter report(ChatPromptRequest req) {
        SseEmitter emitter = new SseEmitter(Long.MAX_VALUE);
        // 현재 스레드에 사용자 이름을 설정하여, 도구 호출 등에서 사용자 컨텍스트를 활용할 수 있도록 합니다.
        // 대화 ID가 요청에 포함되어 있지 않다면 새로운 ID를 생성합니다.
        String convId = (req.getConversationId() == null || req.getConversationId().isBlank())
                ? UUID.randomUUID().toString()
                : req.getConversationId();
        PromptTemplate template = PromptTemplate.from(
                  "제공받은 데이터셋을 분석하여, 전체 요약과 상세 보고서를 모두 포함하는 마크다운 형식의 리포트를 생성하세요.\n" +
                  "리포트는 다음 항목을 포함해야 합니다:\n" +
                  "\n" +
                  "# 총괄 요약\n" +
                  "- 데이터의 핵심 인사이트와 결론 요약\n" +
                  "\n" +
                  "# 상세 분석\n" +
                  "- 섹션별 상세 분석\n" +
                  "- 표와 리스트, 필요시 그래프 링크 포함 가능\n" +
                  "\n" +
                  "# 결론 및 제언\n" +
                  "- 데이터 기반의 결론과 향후 조치/추천 사항\n" +
                  "\n" +
                  "**참고**:\n" +
                  "- 항상 Markdown 형식 사용 (헤더, 리스트, 표, 코드블록 등)\n" +
                  "- 요약은 주요 포인트를 간결하게\n" +
                  "- 상세 분석은 항목별로 구체적 내용을 포함\n" +
                  "\n" +
                  "이제 다음의 질문에 답변해주세요.\n" +
                  "{{question}}"
                ); // 설정 값 사용
        Prompt prompt = template.apply(Map.of("question", req.getMessage()));
        createEmitter(emitter, convId, reportAgent, prompt.text());
        return emitter;
    }

    @Async("taskExecutor")
    protected void createEmitter(
            SseEmitter emitter, 
            String convId, 
            Agent agent, 
            String prompt) {
        try {
            // Agent의 chat 메서드를 호출하여 Gemini 모델과 상호작용합니다.
            // 스트리밍 방식으로 응답을 받으며, 각 토큰을 클라이언트에게 전송합니다.
            TokenStream tokenStream = agent.chat(prompt, convId);
            // 첫 응답으로 대화 ID를 전송합니다.
            emitter.send(SseEmitter.event().name("conversationId").data(convId));
            // 스트리밍 응답의 각 토큰을 처리합니다.
            tokenStream.onNext(token -> {
                try {
                    // 각 토큰을 SSE 이벤트로 클라이언트에게 전송합니다.
                    emitter.send(SseEmitter.event().data(token));
                } catch (IOException e) {
                    // 토큰 전송 중 오류 발생 시 emitter를 오류와 함께 완료합니다.
                    log.error("SSE 토큰 전송 중 오류 발생: {}", e.getMessage());
                    emitter.completeWithError(e);
                }
            })
            // 스트리밍 완료 시 emitter를 완료합니다.
            .onComplete(response -> emitter.complete())
            // 스트리밍 중 오류 발생 시 emitter를 오류와 함께 완료합니다.
            .onError(emitter::completeWithError)
            // 스트리밍을 시작합니다.
            .start();
        } catch (Exception e) {
            // 예외 발생 시 emitter를 오류와 함께 완료합니다.
            log.error("채팅 처리 중 오류 발생: {}", e.getMessage(), e);
        }finally {
            // 요청 처리 완료 후 스레드 로컬에 저장된 사용자 정보를 제거합니다.
            emitter.complete();
        }
    }
}
```

## src/main/java/com/codehows/taelimbe/ai/service/AiReportService.java
```java
package com.codehows.taelimbe.ai.service;

import com.codehows.taelimbe.ai.dto.AiReportDTO;
import com.codehows.taelimbe.ai.repository.AiReportRepository;
import com.codehows.taelimbe.user.entity.User;
import com.codehows.taelimbe.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class AiReportService {

    private final AiReportRepository aiReportRepository;
    private final UserRepository userRepository;

    // 현재 로그인한 사용자 정보 가져오기
    private User getCurrentUser() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String username = authentication.getName(); // JWT에서 추출된 ID
        return userRepository.findById(username)
                .orElseThrow(() -> new RuntimeException("사용자를 찾을 수 없습니다: " + username));
    }


    @Transactional(readOnly = true)
    public List<AiReportDTO> getAllReports() {
        User user = getCurrentUser();
        // ADMIN 역할인 경우 모든 리포트 조회
        if (user.getRole().getLevel() == 3) {
            return aiReportRepository.findAllByOrderByCreatedAtDesc()
                    .stream()
                    .map(AiReportDTO::from)
                    .collect(Collectors.toList());
        }
        // MANAGER 역할인 경우 해당 Store의 모든 리포트 조회
        else if (user.getRole().getLevel() == 2) {
            Long storeId = user.getStore().getStoreId();
            return aiReportRepository.findByStoreIdOrderByCreatedAtDesc(storeId)
                    .stream()
                    .map(AiReportDTO::from)
                    .collect(Collectors.toList());
        }
        // USER 역할인 경우 본인이 생성한 리포트만 조회
        else {
            return aiReportRepository.findByUser_UserId(user.getUserId())
                    .stream()
                    .map(AiReportDTO::from)
                    .collect(Collectors.toList());
        }
    }
}
```

## src/main/java/com/codehows/taelimbe/ai/service/EmbeddingService.java
```java
package com.codehows.taelimbe.ai.service;

import com.codehows.taelimbe.langchain.embaddings.EmbeddingStoreManager;
import com.codehows.taelimbe.langchain.embaddings.TextSplitterStrategy;
import dev.langchain4j.data.embedding.Embedding;
import dev.langchain4j.data.segment.TextSegment;
import dev.langchain4j.model.embedding.EmbeddingModel;
import dev.langchain4j.model.output.Response;
import dev.langchain4j.store.embedding.EmbeddingStore;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.core.task.TaskExecutor;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.concurrent.CompletableFuture;

/**
 * 텍스트 임베딩 및 벡터 저장소 관리를 담당하는 서비스입니다.
 * `@Service` 어노테이션은 이 클래스가 비즈니스 계층의 컴포넌트임을 나타내며,
 * Spring 컨테이너에 의해 관리되는 빈으로 등록됩니다.
 * `@RequiredArgsConstructor`는 Lombok 어노테이션으로, final 필드에 대한 생성자를 자동으로 생성하여 의존성 주입을 용이하게 합니다.
 * `@Slf4j`는 Lombok 어노테이션으로, 로깅을 위한 `log` 객체를 자동으로 생성합니다.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class EmbeddingService {

    // 텍스트를 임베딩 벡터로 변환하는 모델을 주입받습니다.
    private final EmbeddingModel embeddingModel;
    // 생성된 임베딩 벡터를 저장하고 검색하는 스토어를 주입받습니다.
    private final EmbeddingStore<TextSegment> embeddingStore;
    // 임베딩 스토어의 초기화 및 관리 기능을 제공하는 매니저를 주입받습니다.
    private final EmbeddingStoreManager embeddingStoreManager;
    // 텍스트 분할 전략을 주입받습니다.
    private final TextSplitterStrategy textSplitterStrategy;

    // 비동기 작업을 위한 스레드 풀을 주입받습니다.
    @Qualifier("taskExecutor")
    private final TaskExecutor taskExecutor;

    /**
     * 주어진 텍스트를 임베딩하여 벡터 저장소에 추가합니다.
     * 이 메서드는 RAG(Retrieval-Augmented Generation)를 위한 지식 기반을 구축하는 데 사용됩니다.
     * 작업은 비동기적으로 실행되어 호출 스레드를 블로킹하지 않습니다.
     *
     * @param text 임베딩하고 저장할 텍스트
     * @return 비동기 작업의 완료를 나타내는 `CompletableFuture<Void>`
     */
    public CompletableFuture<Void> embedAndStore(String text) {
        return CompletableFuture.runAsync(() -> {
            log.info("텍스트 임베딩 및 저장 시작: '{}'", text);

            // 1. 텍스트 분할 전략을 사용하여 텍스트를 작은 `TextSegment`들로 분할합니다.
            List<TextSegment> segments = textSplitterStrategy.split(text).stream().map(TextSegment::from).toList();

            // 2. `EmbeddingModel`을 사용하여 각 `TextSegment`를 임베딩 벡터로 변환합니다.
            Response<List<Embedding>> embedding = embeddingModel.embedAll(segments);

            // 3. 임베딩된 `TextSegment`와 해당 임베딩 벡터를 `EmbeddingStore`에 추가합니다.
            embeddingStore.addAll(embedding.content(), segments);

            log.info("텍스트 임베딩 및 저장 완료.");
        }, taskExecutor); // 지정된 `taskExecutor` 스레드 풀에서 실행
    }

    /**
     * 기존 벡터 저장소의 모든 데이터를 삭제하고, 주어진 텍스트로 새로 임베딩하여 저장합니다.
     * 지식 기반을 완전히 초기화하고 새로운 데이터로 교체할 때 사용됩니다.
     * 작업은 비동기적으로 실행되어 호출 스레드를 블로킹하지 않습니다.
     *
     * @param text 새로 임베딩하고 저장할 텍스트
     * @return 비동기 작업의 완료를 나타내는 `CompletableFuture<Void>`
     */
    public CompletableFuture<Void> resetAndEmbed(String text) {
        return CompletableFuture.runAsync(() -> {
            log.info("임베딩 스토어 재설정 및 새 텍스트 임베딩 시작.");

            // 1. `EmbeddingStoreManager`를 사용하여 Milvus 컬렉션을 재설정(삭제 후 재생성)합니다.
            embeddingStoreManager.reset();

            // 2. 새로운 텍스트로 임베딩 및 저장을 수행합니다.
            embedAndStore(text);

            log.info("임베딩 스토어 재설정 및 새 텍스트 임베딩 완료.");
        }, taskExecutor); // 지정된 `taskExecutor` 스레드 풀에서 실행
    }
}
```

## src/main/java/com/codehows/taelimbe/user/dto/LoginResponseDTO.java
```java
package com.codehows.taelimbe.user.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;

@Getter
@Builder
@AllArgsConstructor
public class LoginResponseDTO
{
    private String jwtToken;

    private Integer roleLevel;

    private Long storeId;

    private Long userId;
}
```

## src/main/java/com/codehows/taelimbe/user/service/JwtService.java
```java
package com.codehows.taelimbe.user.service;

import io.jsonwebtoken.JwtParser;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpHeaders;
import org.springframework.stereotype.Service;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;

@Service
public class JwtService {

    // 서버와 클라이언트가 주고 받는 토큰 ==> HTTP Header 내 Authorization 헤더값에 저장
    // 예) Authorization Bearer <토큰값>
    private static final String PREFIX = "Bearer ";

    private final long expirationTime;
    private final SecretKey signingKey;

    // 생성자를 통해 고정 키 주입
    public JwtService(
            @Value("${jwt.secret-key}") String secretKeyString,
            @Value("${jwt.expiration}") long expirationTime) {
        // 고정된 시크릿 키를 SecretKey 객체로 변환
        this.signingKey = Keys.hmacShaKeyFor(secretKeyString.getBytes(StandardCharsets.UTF_8));
        this.expirationTime = expirationTime;
    }

    // loginId(ID)를 받아서 JWT 생성
    public String generateToken(String loginId) {
        return Jwts.builder()
                .setSubject(loginId)
                .setExpiration(new Date(System.currentTimeMillis() + expirationTime))
                .signWith(signingKey, SignatureAlgorithm.HS256)
                .compact();
    }

    // JWT를 받아서 id(ID)를 반환
    public String parseToken(HttpServletRequest request) {
        // 요청 헤더에서 Authorization 헤더값을 가져옴
        // 예) header = Bearer <토큰값>
        String header = request.getHeader(HttpHeaders.AUTHORIZATION);
        if (header != null && header.startsWith(PREFIX)) {
            try {
                JwtParser parser = Jwts.parserBuilder()
                        .setSigningKey(signingKey)
                        .build();

                String id = parser.parseClaimsJws(header.replace(PREFIX, ""))
                        .getBody()
                        .getSubject();

                return id;
            } catch (Exception e) {
                // 토큰 파싱 실패 시 null 반환
                return null;
            }
        }
        return null;
    }
}
```

## src/main/java/com/codehows/taelimbe/user/controller/LoginController.java
```java
package com.codehows.taelimbe.user.controller;

import com.codehows.taelimbe.user.constant.Role;
import com.codehows.taelimbe.user.dto.LoginDTO;
import com.codehows.taelimbe.user.dto.LoginResponseDTO;
import com.codehows.taelimbe.user.entity.User;
import com.codehows.taelimbe.user.service.JwtService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.security.authentication.AuthenticationManager;

@Controller
@RequiredArgsConstructor
public class LoginController {

    private final JwtService jwtService;
    private final AuthenticationManager authenticationManager;

    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody LoginDTO loginDto) {
        UsernamePasswordAuthenticationToken token = 
                new UsernamePasswordAuthenticationToken(loginDto.getId(), loginDto.getPw());

        Authentication authentication = authenticationManager.authenticate(token);

        // 1. 인증된 사용자의 권한을 확인합니다. ADMIN: 3, MANAGER: 2, USER: 1
        String roleName = authentication.getAuthorities().stream()
                .map(a -> a.getAuthority().replace("ROLE_", "")) // ADMIN, MANAGER, USER
                .findFirst()
                .orElse("USER"); // 기본값 USER

        // enum으로 변환 ==> 숫자 level 꺼내기
        int roleLevel = Role.valueOf(roleName).getLevel();

        // 2. 인증된 사용자 객체에서 storeId, userId를 추출합니다.
        Long storeId = null, userId = null;
        Object principal = authentication.getPrincipal();

        if (principal instanceof User) {
            User authenticatedUser = (User) principal;

            userId = authenticatedUser.getUserId();
            System.out.println("userId :  " + userId);

            // User 엔티티는 Store 엔티티를 가지고 있으므로, Store에서 storeId를 가져옵니다.
            if (authenticatedUser.getStore() != null) {
                storeId = authenticatedUser.getStore().getStoreId();
            }
        }
        // storeId가 null이면 0L 또는 적절한 기본값으로 설정 (LoinReponseDTO에 맞게 Integer 타입 요구에 맞춤)
        Long finalStoreId = storeId != null ? storeId : 0L;

        // 3. JWT 토큰을 발급합니다.
        String jwtToken = jwtService.generateToken(authentication.getName());

        // 4. 응답에 포함할 DTO를 생성합니다.
        LoginResponseDTO response = new LoginResponseDTO(jwtToken, roleLevel, finalStoreId, userId);

        return ResponseEntity.ok()
                .body(response);
//                  .header(HttpHeaders.AUTHORIZATION, "Bearer " + jwtToken)
//                   .build();
    }
}
```

## src/main/java/com/codehows/taelimbe/user/config/SecurityConfig.java
```java
package com.codehows.taelimbe.user.config;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.List;

@Configuration
@RequiredArgsConstructor
public class SecurityConfig {
    private final AuthEntryPoint authEntryPoint;
    private final JwtFilter jwtFilter;
    private final UserDetailsService userDetailsService;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
                .csrf(csrf -> csrf.disable())
                .sessionManagement
                        ((session) -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/login").permitAll()
                        .anyRequest().authenticated())
                .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling((ex) -> ex.authenticationEntryPoint(authEntryPoint));
        return http.build();
    }


    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();   //비밀번호 암호화
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception
    {
        return authConfig.getAuthenticationManager();
    }
}

```

## src/main/java/com/codehows/taelimbe/user/service/UserService.java
```java
package com.codehows.taelimbe.user.service;

import com.codehows.taelimbe.store.entity.Store;
import com.codehows.taelimbe.store.repository.StoreRepository;
import com.codehows.taelimbe.user.dto.UserDTO;
import com.codehows.taelimbe.user.entity.User;
import com.codehows.taelimbe.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
@Transactional
public class UserService {

    private final UserRepository userRepository;
    private final StoreRepository storeRepository;
    private final PasswordEncoder passwordEncoder;

    public void saveUser(User user){
        validateDuplicateUser(user);
        userRepository.save(user);
    }

    public void validateDuplicateUser(User user)
    {
        boolean loginIdExists = userRepository.existsById(user.getId());
        if (loginIdExists)
        {
            throw new IllegalStateException ("이미 사용 중인 아이디입니다.");
        }
    }

    @Transactional
    public UserDTO updateUser(Long userId, UserDTO dto) {
        // 1. 기존 User 엔티티 조회
        User target = userRepository.findById(userId)
                .orElseThrow(() -> new IllegalArgumentException(
                        "업데이트 대상 직원(UserId: " + userId + ")을 찾을 수 없습니다."
                ));

        // 2. 아이디 변경 (중복 확인)
        if (dto.getId() != null && !dto.getId().equals(target.getId())) {
            // 중복 확인
            if (userRepository.existsById(dto.getId())) {
                throw new IllegalStateException("이미 사용 중인 아이디입니다.");
            }
            target.setId(dto.getId());
        }

        // 3. 비밀번호 변경 (입력된 경우만)
        if (dto.getPw() != null && !dto.getPw().isEmpty()) {
            String encodedPassword = passwordEncoder.encode(dto.getPw());
            target.setPw(encodedPassword);
        }

        // 4. 이름, 전화번호, 이메일 업데이트
        if (dto.getName() != null && !dto.getName().isEmpty()) {
            target.setName(dto.getName());
        }

        if (dto.getPhone() != null && !dto.getPhone().isEmpty()) {
            target.setPhone(dto.getPhone());
        }

        if (dto.getEmail() != null && !dto.getEmail().isEmpty()) {
            target.setEmail(dto.getEmail());
        }

        // 5. Store (매장) 업데이트 처리
        if (dto.getStoreId() != null) {
            Store store = storeRepository.findById(dto.getStoreId())
                    .orElseThrow(() -> new IllegalArgumentException(
                            "매장(StoreId: " + dto.getStoreId() + ")을 찾을 수 없습니다."
                    ));
            target.setStore(store);
        }

        // 6. Role (권한) 업데이트 처리
        if (dto.getRole() != null) {
            target.setRole(dto.getRole());
        }

        // 7. 업데이트된 엔티티 저장
        User updated = userRepository.save(target);

        // 8. 업데이트된 엔티티를 DTO로 변환하여 반환
        return UserDTO.from(updated);
    }

    @Transactional
    public void deleteUser(Long userId) {
        userRepository.findById(userId)
                .ifPresentOrElse(
                        user -> userRepository.delete(user),
                        () -> { throw new IllegalArgumentException("해당 ID의 직원을 찾을 수 없습니다: " + userId); }
                );
    }
}
```

## src/main/java/com/codehows/taelimbe/user/config/JwtFilter.java
```java
package com.codehows.taelimbe.user.config;

import com.codehows.taelimbe.user.service.JwtService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.Servlet;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpHeaders;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Collections;

@Component
@RequiredArgsConstructor
public class JwtFilter extends OncePerRequestFilter
{
    private final JwtService jwtService;
    private final Servlet servlet;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {

        // OPTIONS 요청(Preflight)은 JWT 검증 없이 바로 통과
        if ("OPTIONS".equalsIgnoreCase(request.getMethod())) {
            filterChain.doFilter(request, response);
            return;
        }

        // 필터 ==> 요청, 응답을 중간에서 가로챈 다음 ==> 필요한 동작을 수행
        // 1. 요청 헤더 (Authorization)에서 JWT 토큰을 꺼냄
        String jwtToken = request.getHeader(HttpHeaders.AUTHORIZATION);
        if (jwtToken != null)
        {
            // 2. 꺼낸 토큰에서 유저 정보 추출
            String id = jwtService.parseToken(request);
            // 3. 추출된 유저 정보로 Authentication 을 만들어서 SecurityContext에 set
            if(id != null)
            {
                Authentication authentication =
                        new UsernamePasswordAuthenticationToken(id, null, Collections.emptyList());
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        }
        // 마지막에 다음 필터를 호출
        filterChain.doFilter(request, response);
    }
}
```

## src/main/java/com/codehows/taelimbe/user/config/AuthEntryPoint.java
```java
package com.codehows.taelimbe.user.config;

import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.io.PrintWriter;

@Component
public class AuthEntryPoint implements AuthenticationEntryPoint
{
    @Override
    public void commence(HttpServletRequest request,
                         HttpServletResponse response,
                         AuthenticationException authException) throws IOException, ServletException
    {
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);  // SC_UNAUTHORIZED ==> 401 에러(인증불가)
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding("UTF-8");
        PrintWriter out = response.getWriter();
        out.println("인증에 실패했습니다. : " + authException.getMessage());
    }
}

```

## src/main/java/com/codehows/taelimbe/user/constant/Role.java
```java
package com.codehows.taelimbe.user.constant;

public enum Role {
    USER(1),
    MANAGER(2),
    ADMIN(3);

    private final int level;

    Role(int level) {
        this.level = level;
    }

    public int getLevel() {
        return level;
    }
}
```

## src/main/java/com/codehows/taelimbe/user/controller/UserController.java
```java
package com.codehows.taelimbe.user.controller;

import com.codehows.taelimbe.user.dto.UserDTO;
import com.codehows.taelimbe.store.entity.Store;
import com.codehows.taelimbe.user.entity.User;
import com.codehows.taelimbe.store.repository.StoreRepository;
import com.codehows.taelimbe.user.repository.UserRepository;
import com.codehows.taelimbe.user.service.UserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/user")
@RequiredArgsConstructor
public class UserController {
    
    private final UserService userService;
    private final PasswordEncoder passwordEncoder;
    private final UserRepository userRepository;
    private final StoreRepository storeRepository;

    @PostMapping("/signup")
    public ResponseEntity<?> signup(@RequestBody @Valid UserDTO userDto) {
        try {
            Store store = storeRepository.findByStoreId(userDto.getStoreId())
                    .orElseThrow(() -> new IllegalArgumentException("존재하지 않는 매장입니다."));

            User user = User.createUser(userDto, passwordEncoder, store);
            userService.saveUser(user);
            return ResponseEntity.ok("회원가입 성공");
        } catch (IllegalStateException e) {
            return ResponseEntity.status(HttpStatus.CONFLICT).body(e.getMessage());
        }
    }

    // 중복확인 눌렀을때
    @GetMapping("/check_loginid")
    public ResponseEntity<?> checkLoginId(@RequestParam String id) {
        boolean exists = userRepository.existsById(id);
        return ResponseEntity.ok().body(Map.of("exists", exists));
    }

    // 직원 수정
    @PutMapping("/{userId}")
    @ResponseBody // JSON 응답을 위해 추가
    public ResponseEntity<UserDTO> updateStore( // 메서드 이름 수정 및 ResponseEntity<StoreDTO> 반환
                                                 @PathVariable Long userId,
                                                 @RequestBody UserDTO dto
    ) {
        UserDTO updatedDto = userService.updateUser(userId, dto);
        return ResponseEntity.ok(updatedDto);
    }

    // 직원 삭제
    @DeleteMapping("/{userId}")
    public ResponseEntity<String> deleteEmployee(@PathVariable Long userId) {
        try {
            // 서비스 계층에 삭제 로직 위임
            userService.deleteUser(userId);

            // 성공적으로 삭제되었음을 알리는 메시지 반환 (프론트엔드에서 alert에 사용 가능)
            return ResponseEntity.ok("직원이 성공적으로 삭제되었습니다.");

            // 또는 데이터 반환 없이 204 No Content 반환
            // return ResponseEntity.noContent().build();

        } catch (IllegalArgumentException e) {
            // 직원을 찾을 수 없을 때 (예: userId가 유효하지 않은 경우)
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());
        } catch (Exception e) {
            // 그 외 서버 오류
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("직원 삭제 중 서버 오류가 발생했습니다.");
        }
    }
}
```

## src/main/java/com/codehows/taelimbe/user/dto/LoginDTO.java
```java
package com.codehows.taelimbe.user.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.Data;

@Data
public class LoginDTO
{
    @NotBlank(message = "아이디를 입력하세요.")
    private  String id;

    @NotBlank(message = "비밀번호를 입력하세요.")
    private String pw ;
}
```

## src/main/java/com/codehows/taelimbe/user/dto/UserDTO.java
```java
package com.codehows.taelimbe.user.dto;

import com.codehows.taelimbe.user.constant.Role;
import com.codehows.taelimbe.user.entity.User;
import jakarta.validation.constraints.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.validator.constraints.Length;

import java.util.Base64;

@Getter
@Setter
public class UserDTO {

    private Long userId;
    @NotBlank(message = "ID는 필수 입력 값입니다.")
    private String id;

    // 수정시 비밀번호 안변경하면 null로 보내야해서 NotNull 사용X
    @Length(min=8, max=16, message = "비밀번호는 8자 이상,  16자 이하로 입력해주세요.")
    private String pw;

    @NotBlank(message = "이름은 필수 입력 값입니다.")
    private String name;

    @NotNull(message = "전화 번호는 필수 입력 값입니다.")
    @Pattern(regexp = "^\\d{2,3}-\\d{3,4}-\\d{4}$", message = "전화번호는 하이픈(-)을 포함한 올바른 형식(예: 010-1234-5678)으로 입력해주세요.")
    private String phone;

    @NotEmpty(message = "이메일은 필수 입력 값입니다.")
    @Email(message = "이메일 형식으로 입력해주세요.")
    private String email;

    @NotNull(message = "권한은 필수 선택 값입니다.")
    private Role role;

    @NotNull(message = "업체 선택은 필수 선택 값입니다.")
    private Long storeId;

    public static UserDTO from(User user) {
        UserDTO dto = new UserDTO();
        dto.setUserId(user.getUserId());
        dto.setId(user.getId());
        dto.setPw(user.getPw());
        dto.setName(user.getName());
        dto.setPhone(user.getPhone());
        dto.setEmail(user.getEmail());
        dto.setRole(user.getRole());
        dto.setStoreId(user.getStore().getStoreId());
        return dto;
    }

    private static String decode(String encoded) {
        if (encoded == null) return null;
        return new String(Base64.getDecoder().decode(encoded));
    }

}
```

## src/main/java/com/codehows/taelimbe/user/dto/UserResponseDTO.java
```java
package com.codehows.taelimbe.user.dto;

import com.codehows.taelimbe.user.constant.Role;
import com.codehows.taelimbe.user.entity.User;
import lombok.Builder;
import lombok.Getter;

@Getter
@Builder
public class UserResponseDTO {

    private Long userId;
    private String id;
    private String name;
    private String phone;
    private String email;
    private Role role;
    private Long storeId;

    public static UserResponseDTO fromEntity(User user) {
        return UserResponseDTO.builder()
                .userId(user.getUserId())
                .id(user.getId())
                .name(user.getName())
                .phone(user.getPhone())
                .email(user.getEmail())
                .role(user.getRole())
                // store 객체에서 storeId를 추출하여 DTO에 직접 매핑
                .storeId(user.getStore() != null ? user.getStore().getStoreId() : null)
                .build();
    }

}
```

## src/main/java/com/codehows/taelimbe/user/entity/User.java
```java
package com.codehows.taelimbe.user.entity;

import com.codehows.taelimbe.store.entity.Store;
import com.codehows.taelimbe.user.constant.Role;
import com.codehows.taelimbe.user.dto.UserDTO;
import jakarta.persistence.*;
import lombok.*;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.password.PasswordEncoder;
import java.util.Collection;
import java.util.List;

@Entity
@Table(name = "user")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User implements UserDetails {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "user_id")
    private Long userId;

    @Column(name = "id", length = 20, unique = true, nullable = false)
    private String id;

    @Column(name = "pw", length = 255, nullable = false)
    private String pw;

    @Column(name = "name", length = 20, nullable = false)
    private String name;

    @Column(name = "phone", length = 20, nullable = false)
    private String phone;

    @Column(name = "email", length = 50, nullable = false)
    private String email;

    @Enumerated(EnumType.STRING)
    @Column(name = "role", nullable = false)
    private Role role;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "store_id")
    private Store store;

    public static User createUser(UserDTO dto, PasswordEncoder encoder, Store store) {
        return User.builder()
                .id(dto.getId())
                .pw(encoder.encode(dto.getPw()))
                .name(dto.getName())
                .phone(dto.getPhone())
                .email(dto.getEmail())
                .role(dto.getRole())
                .store(store)
                .build();
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return List.of(new SimpleGrantedAuthority("ROLE_" + this.role.toString()));
    }

    @Override
    public String getPassword() {
        return this.pw;
    }

    @Override
    public String getUsername() {
        return this.id;
    }

    @Override
    public boolean isAccountNonExpired() { return true; }

    @Override
    public boolean isAccountNonLocked() { return true; }

    @Override
    public boolean isCredentialsNonExpired() { return true; }

    @Override
    public boolean isEnabled() { return true; }
}
```

## src/main/java/com/codehows/taelimbe/user/repository/UserRepository.java
```java
package com.codehows.taelimbe.user.repository;

import com.codehows.taelimbe.user.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;

import java.util.List;
import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {

    boolean existsById(String id);
    Optional<User> findById(String id);

    // 💡 Fetch Join을 사용하여 User를 로드할 때 Store 정보도 즉시 로드합니다.
    @Query("SELECT u FROM User u JOIN FETCH u.store WHERE u.id = :id")
    Optional<User> findByIdWithStore(String id);

    List<User> findByStore_StoreId(Long storeId);

}
```

## src/main/java/com/codehows/taelimbe/user/service/CustomUserDetailsService.java
```java
package com.codehows.taelimbe.user.service;

import com.codehows.taelimbe.user.entity.User;
import com.codehows.taelimbe.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;


@Service
@RequiredArgsConstructor
public class CustomUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    @Transactional(readOnly = true)
    public UserDetails loadUserByUsername(String id) throws UsernameNotFoundException {
        // username = 사용자가 입력한 loginId (예: "user01")
        User user = userRepository.findByIdWithStore(id)
                .orElseThrow(() -> new UsernameNotFoundException("사용자를 찾을 수 없습니다: " + id));

        return user;
    }

}
```